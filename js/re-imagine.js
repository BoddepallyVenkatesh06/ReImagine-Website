/*! For license information please see bundle.js.LICENSE.txt */
(() => {
  "use strict";
  var t = {
    d: (e, n) => {
      for (var i in n)
        t.o(n, i) &&
          !t.o(e, i) &&
          Object.defineProperty(e, i, { enumerable: !0, get: n[i] });
    },
    o: (t, e) => Object.prototype.hasOwnProperty.call(t, e),
  };
  t.d({}, { hb: () => YT, dg: () => NT });
  const e = "160",
    n = 1,
    i = 2,
    r = 3,
    s = 100,
    a = 0,
    o = 1,
    l = 2,
    c = 0,
    h = 1,
    u = 2,
    d = 3,
    p = 4,
    f = 5,
    m = 6,
    g = "attached",
    _ = 301,
    v = 302,
    y = 306,
    x = 1e3,
    T = 1001,
    M = 1002,
    S = 1003,
    b = 1004,
    E = 1005,
    w = 1006,
    A = 1008,
    R = 1009,
    C = 1012,
    P = 1014,
    L = 1015,
    D = 1016,
    I = 1020,
    U = 1023,
    N = 1026,
    O = 1027,
    F = 33776,
    k = 33777,
    z = 33778,
    B = 33779,
    H = 36492,
    G = 2300,
    V = 2301,
    W = 2302,
    X = 3001,
    j = "",
    q = "srgb",
    Y = "srgb-linear",
    K = "display-p3",
    Z = "display-p3-linear",
    J = "linear",
    Q = "srgb",
    $ = "rec709",
    tt = "p3",
    et = 7680,
    nt = 35044,
    it = "300 es",
    rt = 1035,
    st = 2e3,
    at = 2001;
  class ot {
    addEventListener(t, e) {
      void 0 === this._listeners && (this._listeners = {});
      const n = this._listeners;
      void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
    }
    hasEventListener(t, e) {
      if (void 0 === this._listeners) return !1;
      const n = this._listeners;
      return void 0 !== n[t] && -1 !== n[t].indexOf(e);
    }
    removeEventListener(t, e) {
      if (void 0 === this._listeners) return;
      const n = this._listeners[t];
      if (void 0 !== n) {
        const t = n.indexOf(e);
        -1 !== t && n.splice(t, 1);
      }
    }
    dispatchEvent(t) {
      if (void 0 === this._listeners) return;
      const e = this._listeners[t.type];
      if (void 0 !== e) {
        t.target = this;
        const n = e.slice(0);
        for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
        t.target = null;
      }
    }
  }
  const lt = [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "0a",
    "0b",
    "0c",
    "0d",
    "0e",
    "0f",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "1a",
    "1b",
    "1c",
    "1d",
    "1e",
    "1f",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "2a",
    "2b",
    "2c",
    "2d",
    "2e",
    "2f",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "3a",
    "3b",
    "3c",
    "3d",
    "3e",
    "3f",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "4a",
    "4b",
    "4c",
    "4d",
    "4e",
    "4f",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "5a",
    "5b",
    "5c",
    "5d",
    "5e",
    "5f",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "6a",
    "6b",
    "6c",
    "6d",
    "6e",
    "6f",
    "70",
    "71",
    "72",
    "73",
    "74",
    "75",
    "76",
    "77",
    "78",
    "79",
    "7a",
    "7b",
    "7c",
    "7d",
    "7e",
    "7f",
    "80",
    "81",
    "82",
    "83",
    "84",
    "85",
    "86",
    "87",
    "88",
    "89",
    "8a",
    "8b",
    "8c",
    "8d",
    "8e",
    "8f",
    "90",
    "91",
    "92",
    "93",
    "94",
    "95",
    "96",
    "97",
    "98",
    "99",
    "9a",
    "9b",
    "9c",
    "9d",
    "9e",
    "9f",
    "a0",
    "a1",
    "a2",
    "a3",
    "a4",
    "a5",
    "a6",
    "a7",
    "a8",
    "a9",
    "aa",
    "ab",
    "ac",
    "ad",
    "ae",
    "af",
    "b0",
    "b1",
    "b2",
    "b3",
    "b4",
    "b5",
    "b6",
    "b7",
    "b8",
    "b9",
    "ba",
    "bb",
    "bc",
    "bd",
    "be",
    "bf",
    "c0",
    "c1",
    "c2",
    "c3",
    "c4",
    "c5",
    "c6",
    "c7",
    "c8",
    "c9",
    "ca",
    "cb",
    "cc",
    "cd",
    "ce",
    "cf",
    "d0",
    "d1",
    "d2",
    "d3",
    "d4",
    "d5",
    "d6",
    "d7",
    "d8",
    "d9",
    "da",
    "db",
    "dc",
    "dd",
    "de",
    "df",
    "e0",
    "e1",
    "e2",
    "e3",
    "e4",
    "e5",
    "e6",
    "e7",
    "e8",
    "e9",
    "ea",
    "eb",
    "ec",
    "ed",
    "ee",
    "ef",
    "f0",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "fa",
    "fb",
    "fc",
    "fd",
    "fe",
    "ff",
  ];
  const ct = Math.PI / 180,
    ht = 180 / Math.PI;
  function ut() {
    const t = (4294967295 * Math.random()) | 0,
      e = (4294967295 * Math.random()) | 0,
      n = (4294967295 * Math.random()) | 0,
      i = (4294967295 * Math.random()) | 0;
    return (
      lt[255 & t] +
      lt[(t >> 8) & 255] +
      lt[(t >> 16) & 255] +
      lt[(t >> 24) & 255] +
      "-" +
      lt[255 & e] +
      lt[(e >> 8) & 255] +
      "-" +
      lt[((e >> 16) & 15) | 64] +
      lt[(e >> 24) & 255] +
      "-" +
      lt[(63 & n) | 128] +
      lt[(n >> 8) & 255] +
      "-" +
      lt[(n >> 16) & 255] +
      lt[(n >> 24) & 255] +
      lt[255 & i] +
      lt[(i >> 8) & 255] +
      lt[(i >> 16) & 255] +
      lt[(i >> 24) & 255]
    ).toLowerCase();
  }
  function dt(t, e, n) {
    return Math.max(e, Math.min(n, t));
  }
  function pt(t, e) {
    return ((t % e) + e) % e;
  }
  function ft(t, e, n) {
    return (1 - n) * t + n * e;
  }
  function mt(t) {
    return 0 == (t & (t - 1)) && 0 !== t;
  }
  function gt(t) {
    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
  }
  function _t(t, e) {
    switch (e.constructor) {
      case Float32Array:
        return t;
      case Uint32Array:
        return t / 4294967295;
      case Uint16Array:
        return t / 65535;
      case Uint8Array:
        return t / 255;
      case Int32Array:
        return Math.max(t / 2147483647, -1);
      case Int16Array:
        return Math.max(t / 32767, -1);
      case Int8Array:
        return Math.max(t / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  }
  function vt(t, e) {
    switch (e.constructor) {
      case Float32Array:
        return t;
      case Uint32Array:
        return Math.round(4294967295 * t);
      case Uint16Array:
        return Math.round(65535 * t);
      case Uint8Array:
        return Math.round(255 * t);
      case Int32Array:
        return Math.round(2147483647 * t);
      case Int16Array:
        return Math.round(32767 * t);
      case Int8Array:
        return Math.round(127 * t);
      default:
        throw new Error("Invalid component type.");
    }
  }
  const yt = function (t) {
    return t * ht;
  };
  class xt {
    constructor(t = 0, e = 0) {
      (xt.prototype.isVector2 = !0), (this.x = t), (this.y = e);
    }
    get width() {
      return this.x;
    }
    set width(t) {
      this.x = t;
    }
    get height() {
      return this.y;
    }
    set height(t) {
      this.y = t;
    }
    set(t, e) {
      return (this.x = t), (this.y = e), this;
    }
    setScalar(t) {
      return (this.x = t), (this.y = t), this;
    }
    setX(t) {
      return (this.x = t), this;
    }
    setY(t) {
      return (this.y = t), this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(t) {
      return (this.x = t.x), (this.y = t.y), this;
    }
    add(t) {
      return (this.x += t.x), (this.y += t.y), this;
    }
    addScalar(t) {
      return (this.x += t), (this.y += t), this;
    }
    addVectors(t, e) {
      return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
    }
    addScaledVector(t, e) {
      return (this.x += t.x * e), (this.y += t.y * e), this;
    }
    sub(t) {
      return (this.x -= t.x), (this.y -= t.y), this;
    }
    subScalar(t) {
      return (this.x -= t), (this.y -= t), this;
    }
    subVectors(t, e) {
      return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
    }
    multiply(t) {
      return (this.x *= t.x), (this.y *= t.y), this;
    }
    multiplyScalar(t) {
      return (this.x *= t), (this.y *= t), this;
    }
    divide(t) {
      return (this.x /= t.x), (this.y /= t.y), this;
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    applyMatrix3(t) {
      const e = this.x,
        n = this.y,
        i = t.elements;
      return (
        (this.x = i[0] * e + i[3] * n + i[6]),
        (this.y = i[1] * e + i[4] * n + i[7]),
        this
      );
    }
    min(t) {
      return (
        (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this
      );
    }
    max(t) {
      return (
        (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this
      );
    }
    clamp(t, e) {
      return (
        (this.x = Math.max(t.x, Math.min(e.x, this.x))),
        (this.y = Math.max(t.y, Math.min(e.y, this.y))),
        this
      );
    }
    clampScalar(t, e) {
      return (
        (this.x = Math.max(t, Math.min(e, this.x))),
        (this.y = Math.max(t, Math.min(e, this.y))),
        this
      );
    }
    clampLength(t, e) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(
        Math.max(t, Math.min(e, n))
      );
    }
    floor() {
      return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
    }
    ceil() {
      return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
    }
    round() {
      return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
    }
    roundToZero() {
      return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), this;
    }
    dot(t) {
      return this.x * t.x + this.y * t.y;
    }
    cross(t) {
      return this.x * t.y - this.y * t.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    angleTo(t) {
      const e = Math.sqrt(this.lengthSq() * t.lengthSq());
      if (0 === e) return Math.PI / 2;
      const n = this.dot(t) / e;
      return Math.acos(dt(n, -1, 1));
    }
    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t));
    }
    distanceToSquared(t) {
      const e = this.x - t.x,
        n = this.y - t.y;
      return e * e + n * n;
    }
    manhattanDistanceTo(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return (
        (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
      );
    }
    lerpVectors(t, e, n) {
      return (
        (this.x = t.x + (e.x - t.x) * n), (this.y = t.y + (e.y - t.y) * n), this
      );
    }
    equals(t) {
      return t.x === this.x && t.y === this.y;
    }
    fromArray(t, e = 0) {
      return (this.x = t[e]), (this.y = t[e + 1]), this;
    }
    toArray(t = [], e = 0) {
      return (t[e] = this.x), (t[e + 1] = this.y), t;
    }
    fromBufferAttribute(t, e) {
      return (this.x = t.getX(e)), (this.y = t.getY(e)), this;
    }
    rotateAround(t, e) {
      const n = Math.cos(e),
        i = Math.sin(e),
        r = this.x - t.x,
        s = this.y - t.y;
      return (
        (this.x = r * n - s * i + t.x), (this.y = r * i + s * n + t.y), this
      );
    }
    random() {
      return (this.x = Math.random()), (this.y = Math.random()), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  }
  class Tt {
    constructor(t, e, n, i, r, s, a, o, l) {
      (Tt.prototype.isMatrix3 = !0),
        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        void 0 !== t && this.set(t, e, n, i, r, s, a, o, l);
    }
    set(t, e, n, i, r, s, a, o, l) {
      const c = this.elements;
      return (
        (c[0] = t),
        (c[1] = i),
        (c[2] = a),
        (c[3] = e),
        (c[4] = r),
        (c[5] = o),
        (c[6] = n),
        (c[7] = s),
        (c[8] = l),
        this
      );
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(t) {
      const e = this.elements,
        n = t.elements;
      return (
        (e[0] = n[0]),
        (e[1] = n[1]),
        (e[2] = n[2]),
        (e[3] = n[3]),
        (e[4] = n[4]),
        (e[5] = n[5]),
        (e[6] = n[6]),
        (e[7] = n[7]),
        (e[8] = n[8]),
        this
      );
    }
    extractBasis(t, e, n) {
      return (
        t.setFromMatrix3Column(this, 0),
        e.setFromMatrix3Column(this, 1),
        n.setFromMatrix3Column(this, 2),
        this
      );
    }
    setFromMatrix4(t) {
      const e = t.elements;
      return (
        this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
      );
    }
    multiply(t) {
      return this.multiplyMatrices(this, t);
    }
    premultiply(t) {
      return this.multiplyMatrices(t, this);
    }
    multiplyMatrices(t, e) {
      const n = t.elements,
        i = e.elements,
        r = this.elements,
        s = n[0],
        a = n[3],
        o = n[6],
        l = n[1],
        c = n[4],
        h = n[7],
        u = n[2],
        d = n[5],
        p = n[8],
        f = i[0],
        m = i[3],
        g = i[6],
        _ = i[1],
        v = i[4],
        y = i[7],
        x = i[2],
        T = i[5],
        M = i[8];
      return (
        (r[0] = s * f + a * _ + o * x),
        (r[3] = s * m + a * v + o * T),
        (r[6] = s * g + a * y + o * M),
        (r[1] = l * f + c * _ + h * x),
        (r[4] = l * m + c * v + h * T),
        (r[7] = l * g + c * y + h * M),
        (r[2] = u * f + d * _ + p * x),
        (r[5] = u * m + d * v + p * T),
        (r[8] = u * g + d * y + p * M),
        this
      );
    }
    multiplyScalar(t) {
      const e = this.elements;
      return (
        (e[0] *= t),
        (e[3] *= t),
        (e[6] *= t),
        (e[1] *= t),
        (e[4] *= t),
        (e[7] *= t),
        (e[2] *= t),
        (e[5] *= t),
        (e[8] *= t),
        this
      );
    }
    determinant() {
      const t = this.elements,
        e = t[0],
        n = t[1],
        i = t[2],
        r = t[3],
        s = t[4],
        a = t[5],
        o = t[6],
        l = t[7],
        c = t[8];
      return (
        e * s * c - e * a * l - n * r * c + n * a * o + i * r * l - i * s * o
      );
    }
    invert() {
      const t = this.elements,
        e = t[0],
        n = t[1],
        i = t[2],
        r = t[3],
        s = t[4],
        a = t[5],
        o = t[6],
        l = t[7],
        c = t[8],
        h = c * s - a * l,
        u = a * o - c * r,
        d = l * r - s * o,
        p = e * h + n * u + i * d;
      if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const f = 1 / p;
      return (
        (t[0] = h * f),
        (t[1] = (i * l - c * n) * f),
        (t[2] = (a * n - i * s) * f),
        (t[3] = u * f),
        (t[4] = (c * e - i * o) * f),
        (t[5] = (i * r - a * e) * f),
        (t[6] = d * f),
        (t[7] = (n * o - l * e) * f),
        (t[8] = (s * e - n * r) * f),
        this
      );
    }
    transpose() {
      let t;
      const e = this.elements;
      return (
        (t = e[1]),
        (e[1] = e[3]),
        (e[3] = t),
        (t = e[2]),
        (e[2] = e[6]),
        (e[6] = t),
        (t = e[5]),
        (e[5] = e[7]),
        (e[7] = t),
        this
      );
    }
    getNormalMatrix(t) {
      return this.setFromMatrix4(t).invert().transpose();
    }
    transposeIntoArray(t) {
      const e = this.elements;
      return (
        (t[0] = e[0]),
        (t[1] = e[3]),
        (t[2] = e[6]),
        (t[3] = e[1]),
        (t[4] = e[4]),
        (t[5] = e[7]),
        (t[6] = e[2]),
        (t[7] = e[5]),
        (t[8] = e[8]),
        this
      );
    }
    setUvTransform(t, e, n, i, r, s, a) {
      const o = Math.cos(r),
        l = Math.sin(r);
      return (
        this.set(
          n * o,
          n * l,
          -n * (o * s + l * a) + s + t,
          -i * l,
          i * o,
          -i * (-l * s + o * a) + a + e,
          0,
          0,
          1
        ),
        this
      );
    }
    scale(t, e) {
      return this.premultiply(Mt.makeScale(t, e)), this;
    }
    rotate(t) {
      return this.premultiply(Mt.makeRotation(-t)), this;
    }
    translate(t, e) {
      return this.premultiply(Mt.makeTranslation(t, e)), this;
    }
    makeTranslation(t, e) {
      return (
        t.isVector2
          ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1)
          : this.set(1, 0, t, 0, 1, e, 0, 0, 1),
        this
      );
    }
    makeRotation(t) {
      const e = Math.cos(t),
        n = Math.sin(t);
      return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this;
    }
    makeScale(t, e) {
      return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
    }
    equals(t) {
      const e = this.elements,
        n = t.elements;
      for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;
      return !0;
    }
    fromArray(t, e = 0) {
      for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
      return this;
    }
    toArray(t = [], e = 0) {
      const n = this.elements;
      return (
        (t[e] = n[0]),
        (t[e + 1] = n[1]),
        (t[e + 2] = n[2]),
        (t[e + 3] = n[3]),
        (t[e + 4] = n[4]),
        (t[e + 5] = n[5]),
        (t[e + 6] = n[6]),
        (t[e + 7] = n[7]),
        (t[e + 8] = n[8]),
        t
      );
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  const Mt = new Tt();
  function St(t) {
    for (let e = t.length - 1; e >= 0; --e) if (t[e] >= 65535) return !0;
    return !1;
  }
  function bt(t) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", t);
  }
  function Et() {
    const t = bt("canvas");
    return (t.style.display = "block"), t;
  }
  Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array;
  const wt = {};
  function At(t) {
    t in wt || ((wt[t] = !0), console.warn(t));
  }
  const Rt = new Tt().set(
      0.8224621,
      0.177538,
      0,
      0.0331941,
      0.9668058,
      0,
      0.0170827,
      0.0723974,
      0.9105199
    ),
    Ct = new Tt().set(
      1.2249401,
      -0.2249404,
      0,
      -0.0420569,
      1.0420571,
      0,
      -0.0196376,
      -0.0786361,
      1.0982735
    ),
    Pt = {
      [Y]: {
        transfer: J,
        primaries: $,
        toReference: (t) => t,
        fromReference: (t) => t,
      },
      [q]: {
        transfer: Q,
        primaries: $,
        toReference: (t) => t.convertSRGBToLinear(),
        fromReference: (t) => t.convertLinearToSRGB(),
      },
      [Z]: {
        transfer: J,
        primaries: tt,
        toReference: (t) => t.applyMatrix3(Ct),
        fromReference: (t) => t.applyMatrix3(Rt),
      },
      [K]: {
        transfer: Q,
        primaries: tt,
        toReference: (t) => t.convertSRGBToLinear().applyMatrix3(Ct),
        fromReference: (t) => t.applyMatrix3(Rt).convertLinearToSRGB(),
      },
    },
    Lt = new Set([Y, Z]),
    Dt = {
      enabled: !0,
      _workingColorSpace: Y,
      get workingColorSpace() {
        return this._workingColorSpace;
      },
      set workingColorSpace(t) {
        if (!Lt.has(t))
          throw new Error(`Unsupported working color space, "${t}".`);
        this._workingColorSpace = t;
      },
      convert: function (t, e, n) {
        if (!1 === this.enabled || e === n || !e || !n) return t;
        const i = Pt[e].toReference;
        return (0, Pt[n].fromReference)(i(t));
      },
      fromWorkingColorSpace: function (t, e) {
        return this.convert(t, this._workingColorSpace, e);
      },
      toWorkingColorSpace: function (t, e) {
        return this.convert(t, e, this._workingColorSpace);
      },
      getPrimaries: function (t) {
        return Pt[t].primaries;
      },
      getTransfer: function (t) {
        return t === j ? J : Pt[t].transfer;
      },
    };
  function It(t) {
    return t < 0.04045
      ? 0.0773993808 * t
      : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
  }
  function Ut(t) {
    return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
  }
  let Nt;
  class Ot {
    static getDataURL(t) {
      if (/^data:/i.test(t.src)) return t.src;
      if ("undefined" == typeof HTMLCanvasElement) return t.src;
      let e;
      if (t instanceof HTMLCanvasElement) e = t;
      else {
        void 0 === Nt && (Nt = bt("canvas")),
          (Nt.width = t.width),
          (Nt.height = t.height);
        const n = Nt.getContext("2d");
        t instanceof ImageData
          ? n.putImageData(t, 0, 0)
          : n.drawImage(t, 0, 0, t.width, t.height),
          (e = Nt);
      }
      return e.width > 2048 || e.height > 2048
        ? (console.warn(
            "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
            t
          ),
          e.toDataURL("image/jpeg", 0.6))
        : e.toDataURL("image/png");
    }
    static sRGBToLinear(t) {
      if (
        ("undefined" != typeof HTMLImageElement &&
          t instanceof HTMLImageElement) ||
        ("undefined" != typeof HTMLCanvasElement &&
          t instanceof HTMLCanvasElement) ||
        ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
      ) {
        const e = bt("canvas");
        (e.width = t.width), (e.height = t.height);
        const n = e.getContext("2d");
        n.drawImage(t, 0, 0, t.width, t.height);
        const i = n.getImageData(0, 0, t.width, t.height),
          r = i.data;
        for (let t = 0; t < r.length; t++) r[t] = 255 * It(r[t] / 255);
        return n.putImageData(i, 0, 0), e;
      }
      if (t.data) {
        const e = t.data.slice(0);
        for (let t = 0; t < e.length; t++)
          e instanceof Uint8Array || e instanceof Uint8ClampedArray
            ? (e[t] = Math.floor(255 * It(e[t] / 255)))
            : (e[t] = It(e[t]));
        return { data: e, width: t.width, height: t.height };
      }
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        t
      );
    }
  }
  let Ft = 0;
  class kt {
    constructor(t = null) {
      (this.isSource = !0),
        Object.defineProperty(this, "id", { value: Ft++ }),
        (this.uuid = ut()),
        (this.data = t),
        (this.version = 0);
    }
    set needsUpdate(t) {
      !0 === t && this.version++;
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t;
      if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
      const n = { uuid: this.uuid, url: "" },
        i = this.data;
      if (null !== i) {
        let t;
        if (Array.isArray(i)) {
          t = [];
          for (let e = 0, n = i.length; e < n; e++)
            i[e].isDataTexture ? t.push(zt(i[e].image)) : t.push(zt(i[e]));
        } else t = zt(i);
        n.url = t;
      }
      return e || (t.images[this.uuid] = n), n;
    }
  }
  function zt(t) {
    return ("undefined" != typeof HTMLImageElement &&
      t instanceof HTMLImageElement) ||
      ("undefined" != typeof HTMLCanvasElement &&
        t instanceof HTMLCanvasElement) ||
      ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
      ? Ot.getDataURL(t)
      : t.data
      ? {
          data: Array.from(t.data),
          width: t.width,
          height: t.height,
          type: t.data.constructor.name,
        }
      : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }
  let Bt = 0;
  class Ht extends ot {
    constructor(
      t = Ht.DEFAULT_IMAGE,
      e = Ht.DEFAULT_MAPPING,
      n = 1001,
      i = 1001,
      r = 1006,
      s = 1008,
      a = 1023,
      o = 1009,
      l = Ht.DEFAULT_ANISOTROPY,
      c = ""
    ) {
      super(),
        (this.isTexture = !0),
        Object.defineProperty(this, "id", { value: Bt++ }),
        (this.uuid = ut()),
        (this.name = ""),
        (this.source = new kt(t)),
        (this.mipmaps = []),
        (this.mapping = e),
        (this.channel = 0),
        (this.wrapS = n),
        (this.wrapT = i),
        (this.magFilter = r),
        (this.minFilter = s),
        (this.anisotropy = l),
        (this.format = a),
        (this.internalFormat = null),
        (this.type = o),
        (this.offset = new xt(0, 0)),
        (this.repeat = new xt(1, 1)),
        (this.center = new xt(0, 0)),
        (this.rotation = 0),
        (this.matrixAutoUpdate = !0),
        (this.matrix = new Tt()),
        (this.generateMipmaps = !0),
        (this.premultiplyAlpha = !1),
        (this.flipY = !0),
        (this.unpackAlignment = 4),
        "string" == typeof c
          ? (this.colorSpace = c)
          : (At(
              "THREE.Texture: Property .encoding has been replaced by .colorSpace."
            ),
            (this.colorSpace = c === X ? q : j)),
        (this.userData = {}),
        (this.version = 0),
        (this.onUpdate = null),
        (this.isRenderTargetTexture = !1),
        (this.needsPMREMUpdate = !1);
    }
    get image() {
      return this.source.data;
    }
    set image(t = null) {
      this.source.data = t;
    }
    updateMatrix() {
      this.matrix.setUvTransform(
        this.offset.x,
        this.offset.y,
        this.repeat.x,
        this.repeat.y,
        this.rotation,
        this.center.x,
        this.center.y
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return (
        (this.name = t.name),
        (this.source = t.source),
        (this.mipmaps = t.mipmaps.slice(0)),
        (this.mapping = t.mapping),
        (this.channel = t.channel),
        (this.wrapS = t.wrapS),
        (this.wrapT = t.wrapT),
        (this.magFilter = t.magFilter),
        (this.minFilter = t.minFilter),
        (this.anisotropy = t.anisotropy),
        (this.format = t.format),
        (this.internalFormat = t.internalFormat),
        (this.type = t.type),
        this.offset.copy(t.offset),
        this.repeat.copy(t.repeat),
        this.center.copy(t.center),
        (this.rotation = t.rotation),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        this.matrix.copy(t.matrix),
        (this.generateMipmaps = t.generateMipmaps),
        (this.premultiplyAlpha = t.premultiplyAlpha),
        (this.flipY = t.flipY),
        (this.unpackAlignment = t.unpackAlignment),
        (this.colorSpace = t.colorSpace),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        (this.needsUpdate = !0),
        this
      );
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t;
      if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
      const n = {
        metadata: {
          version: 4.6,
          type: "Texture",
          generator: "Texture.toJSON",
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(t).uuid,
        mapping: this.mapping,
        channel: this.channel,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        internalFormat: this.internalFormat,
        type: this.type,
        colorSpace: this.colorSpace,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        generateMipmaps: this.generateMipmaps,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment,
      };
      return (
        Object.keys(this.userData).length > 0 && (n.userData = this.userData),
        e || (t.textures[this.uuid] = n),
        n
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(t) {
      if (300 !== this.mapping) return t;
      if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
        switch (this.wrapS) {
          case x:
            t.x = t.x - Math.floor(t.x);
            break;
          case T:
            t.x = t.x < 0 ? 0 : 1;
            break;
          case M:
            1 === Math.abs(Math.floor(t.x) % 2)
              ? (t.x = Math.ceil(t.x) - t.x)
              : (t.x = t.x - Math.floor(t.x));
        }
      if (t.y < 0 || t.y > 1)
        switch (this.wrapT) {
          case x:
            t.y = t.y - Math.floor(t.y);
            break;
          case T:
            t.y = t.y < 0 ? 0 : 1;
            break;
          case M:
            1 === Math.abs(Math.floor(t.y) % 2)
              ? (t.y = Math.ceil(t.y) - t.y)
              : (t.y = t.y - Math.floor(t.y));
        }
      return this.flipY && (t.y = 1 - t.y), t;
    }
    set needsUpdate(t) {
      !0 === t && (this.version++, (this.source.needsUpdate = !0));
    }
    get encoding() {
      return (
        At(
          "THREE.Texture: Property .encoding has been replaced by .colorSpace."
        ),
        this.colorSpace === q ? X : 3e3
      );
    }
    set encoding(t) {
      At("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        (this.colorSpace = t === X ? q : j);
    }
  }
  (Ht.DEFAULT_IMAGE = null),
    (Ht.DEFAULT_MAPPING = 300),
    (Ht.DEFAULT_ANISOTROPY = 1);
  class Gt {
    constructor(t = 0, e = 0, n = 0, i = 1) {
      (Gt.prototype.isVector4 = !0),
        (this.x = t),
        (this.y = e),
        (this.z = n),
        (this.w = i);
    }
    get width() {
      return this.z;
    }
    set width(t) {
      this.z = t;
    }
    get height() {
      return this.w;
    }
    set height(t) {
      this.w = t;
    }
    set(t, e, n, i) {
      return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
    }
    setScalar(t) {
      return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
    }
    setX(t) {
      return (this.x = t), this;
    }
    setY(t) {
      return (this.y = t), this;
    }
    setZ(t) {
      return (this.z = t), this;
    }
    setW(t) {
      return (this.w = t), this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        case 3:
          this.w = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(t) {
      return (
        (this.x = t.x),
        (this.y = t.y),
        (this.z = t.z),
        (this.w = void 0 !== t.w ? t.w : 1),
        this
      );
    }
    add(t) {
      return (
        (this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this
      );
    }
    addScalar(t) {
      return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
    }
    addVectors(t, e) {
      return (
        (this.x = t.x + e.x),
        (this.y = t.y + e.y),
        (this.z = t.z + e.z),
        (this.w = t.w + e.w),
        this
      );
    }
    addScaledVector(t, e) {
      return (
        (this.x += t.x * e),
        (this.y += t.y * e),
        (this.z += t.z * e),
        (this.w += t.w * e),
        this
      );
    }
    sub(t) {
      return (
        (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this
      );
    }
    subScalar(t) {
      return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
    }
    subVectors(t, e) {
      return (
        (this.x = t.x - e.x),
        (this.y = t.y - e.y),
        (this.z = t.z - e.z),
        (this.w = t.w - e.w),
        this
      );
    }
    multiply(t) {
      return (
        (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this
      );
    }
    multiplyScalar(t) {
      return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
    }
    applyMatrix4(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = this.w,
        s = t.elements;
      return (
        (this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r),
        (this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r),
        (this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r),
        (this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r),
        this
      );
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    setAxisAngleFromQuaternion(t) {
      this.w = 2 * Math.acos(t.w);
      const e = Math.sqrt(1 - t.w * t.w);
      return (
        e < 1e-4
          ? ((this.x = 1), (this.y = 0), (this.z = 0))
          : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
        this
      );
    }
    setAxisAngleFromRotationMatrix(t) {
      let e, n, i, r;
      const s = 0.01,
        a = 0.1,
        o = t.elements,
        l = o[0],
        c = o[4],
        h = o[8],
        u = o[1],
        d = o[5],
        p = o[9],
        f = o[2],
        m = o[6],
        g = o[10];
      if (Math.abs(c - u) < s && Math.abs(h - f) < s && Math.abs(p - m) < s) {
        if (
          Math.abs(c + u) < a &&
          Math.abs(h + f) < a &&
          Math.abs(p + m) < a &&
          Math.abs(l + d + g - 3) < a
        )
          return this.set(1, 0, 0, 0), this;
        e = Math.PI;
        const t = (l + 1) / 2,
          o = (d + 1) / 2,
          _ = (g + 1) / 2,
          v = (c + u) / 4,
          y = (h + f) / 4,
          x = (p + m) / 4;
        return (
          t > o && t > _
            ? t < s
              ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
              : ((n = Math.sqrt(t)), (i = v / n), (r = y / n))
            : o > _
            ? o < s
              ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
              : ((i = Math.sqrt(o)), (n = v / i), (r = x / i))
            : _ < s
            ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
            : ((r = Math.sqrt(_)), (n = y / r), (i = x / r)),
          this.set(n, i, r, e),
          this
        );
      }
      let _ = Math.sqrt(
        (m - p) * (m - p) + (h - f) * (h - f) + (u - c) * (u - c)
      );
      return (
        Math.abs(_) < 0.001 && (_ = 1),
        (this.x = (m - p) / _),
        (this.y = (h - f) / _),
        (this.z = (u - c) / _),
        (this.w = Math.acos((l + d + g - 1) / 2)),
        this
      );
    }
    min(t) {
      return (
        (this.x = Math.min(this.x, t.x)),
        (this.y = Math.min(this.y, t.y)),
        (this.z = Math.min(this.z, t.z)),
        (this.w = Math.min(this.w, t.w)),
        this
      );
    }
    max(t) {
      return (
        (this.x = Math.max(this.x, t.x)),
        (this.y = Math.max(this.y, t.y)),
        (this.z = Math.max(this.z, t.z)),
        (this.w = Math.max(this.w, t.w)),
        this
      );
    }
    clamp(t, e) {
      return (
        (this.x = Math.max(t.x, Math.min(e.x, this.x))),
        (this.y = Math.max(t.y, Math.min(e.y, this.y))),
        (this.z = Math.max(t.z, Math.min(e.z, this.z))),
        (this.w = Math.max(t.w, Math.min(e.w, this.w))),
        this
      );
    }
    clampScalar(t, e) {
      return (
        (this.x = Math.max(t, Math.min(e, this.x))),
        (this.y = Math.max(t, Math.min(e, this.y))),
        (this.z = Math.max(t, Math.min(e, this.z))),
        (this.w = Math.max(t, Math.min(e, this.w))),
        this
      );
    }
    clampLength(t, e) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(
        Math.max(t, Math.min(e, n))
      );
    }
    floor() {
      return (
        (this.x = Math.floor(this.x)),
        (this.y = Math.floor(this.y)),
        (this.z = Math.floor(this.z)),
        (this.w = Math.floor(this.w)),
        this
      );
    }
    ceil() {
      return (
        (this.x = Math.ceil(this.x)),
        (this.y = Math.ceil(this.y)),
        (this.z = Math.ceil(this.z)),
        (this.w = Math.ceil(this.w)),
        this
      );
    }
    round() {
      return (
        (this.x = Math.round(this.x)),
        (this.y = Math.round(this.y)),
        (this.z = Math.round(this.z)),
        (this.w = Math.round(this.w)),
        this
      );
    }
    roundToZero() {
      return (
        (this.x = Math.trunc(this.x)),
        (this.y = Math.trunc(this.y)),
        (this.z = Math.trunc(this.z)),
        (this.w = Math.trunc(this.w)),
        this
      );
    }
    negate() {
      return (
        (this.x = -this.x),
        (this.y = -this.y),
        (this.z = -this.z),
        (this.w = -this.w),
        this
      );
    }
    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
    }
    lengthSq() {
      return (
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    }
    length() {
      return Math.sqrt(
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    }
    manhattanLength() {
      return (
        Math.abs(this.x) +
        Math.abs(this.y) +
        Math.abs(this.z) +
        Math.abs(this.w)
      );
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return (
        (this.x += (t.x - this.x) * e),
        (this.y += (t.y - this.y) * e),
        (this.z += (t.z - this.z) * e),
        (this.w += (t.w - this.w) * e),
        this
      );
    }
    lerpVectors(t, e, n) {
      return (
        (this.x = t.x + (e.x - t.x) * n),
        (this.y = t.y + (e.y - t.y) * n),
        (this.z = t.z + (e.z - t.z) * n),
        (this.w = t.w + (e.w - t.w) * n),
        this
      );
    }
    equals(t) {
      return (
        t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
      );
    }
    fromArray(t, e = 0) {
      return (
        (this.x = t[e]),
        (this.y = t[e + 1]),
        (this.z = t[e + 2]),
        (this.w = t[e + 3]),
        this
      );
    }
    toArray(t = [], e = 0) {
      return (
        (t[e] = this.x),
        (t[e + 1] = this.y),
        (t[e + 2] = this.z),
        (t[e + 3] = this.w),
        t
      );
    }
    fromBufferAttribute(t, e) {
      return (
        (this.x = t.getX(e)),
        (this.y = t.getY(e)),
        (this.z = t.getZ(e)),
        (this.w = t.getW(e)),
        this
      );
    }
    random() {
      return (
        (this.x = Math.random()),
        (this.y = Math.random()),
        (this.z = Math.random()),
        (this.w = Math.random()),
        this
      );
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z, yield this.w;
    }
  }
  class Vt extends ot {
    constructor(t = 1, e = 1, n = {}) {
      super(),
        (this.isRenderTarget = !0),
        (this.width = t),
        (this.height = e),
        (this.depth = 1),
        (this.scissor = new Gt(0, 0, t, e)),
        (this.scissorTest = !1),
        (this.viewport = new Gt(0, 0, t, e));
      const i = { width: t, height: e, depth: 1 };
      void 0 !== n.encoding &&
        (At(
          "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
        ),
        (n.colorSpace = n.encoding === X ? q : j)),
        (n = Object.assign(
          {
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: w,
            depthBuffer: !0,
            stencilBuffer: !1,
            depthTexture: null,
            samples: 0,
          },
          n
        )),
        (this.texture = new Ht(
          i,
          n.mapping,
          n.wrapS,
          n.wrapT,
          n.magFilter,
          n.minFilter,
          n.format,
          n.type,
          n.anisotropy,
          n.colorSpace
        )),
        (this.texture.isRenderTargetTexture = !0),
        (this.texture.flipY = !1),
        (this.texture.generateMipmaps = n.generateMipmaps),
        (this.texture.internalFormat = n.internalFormat),
        (this.depthBuffer = n.depthBuffer),
        (this.stencilBuffer = n.stencilBuffer),
        (this.depthTexture = n.depthTexture),
        (this.samples = n.samples);
    }
    setSize(t, e, n = 1) {
      (this.width === t && this.height === e && this.depth === n) ||
        ((this.width = t),
        (this.height = e),
        (this.depth = n),
        (this.texture.image.width = t),
        (this.texture.image.height = e),
        (this.texture.image.depth = n),
        this.dispose()),
        this.viewport.set(0, 0, t, e),
        this.scissor.set(0, 0, t, e);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      (this.width = t.width),
        (this.height = t.height),
        (this.depth = t.depth),
        this.scissor.copy(t.scissor),
        (this.scissorTest = t.scissorTest),
        this.viewport.copy(t.viewport),
        (this.texture = t.texture.clone()),
        (this.texture.isRenderTargetTexture = !0);
      const e = Object.assign({}, t.texture.image);
      return (
        (this.texture.source = new kt(e)),
        (this.depthBuffer = t.depthBuffer),
        (this.stencilBuffer = t.stencilBuffer),
        null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()),
        (this.samples = t.samples),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  class Wt extends Vt {
    constructor(t = 1, e = 1, n = {}) {
      super(t, e, n), (this.isWebGLRenderTarget = !0);
    }
  }
  class Xt extends Ht {
    constructor(t = null, e = 1, n = 1, i = 1) {
      super(null),
        (this.isDataArrayTexture = !0),
        (this.image = { data: t, width: e, height: n, depth: i }),
        (this.magFilter = S),
        (this.minFilter = S),
        (this.wrapR = T),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  }
  class jt extends Ht {
    constructor(t = null, e = 1, n = 1, i = 1) {
      super(null),
        (this.isData3DTexture = !0),
        (this.image = { data: t, width: e, height: n, depth: i }),
        (this.magFilter = S),
        (this.minFilter = S),
        (this.wrapR = T),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  }
  class qt {
    constructor(t = 0, e = 0, n = 0, i = 1) {
      (this.isQuaternion = !0),
        (this._x = t),
        (this._y = e),
        (this._z = n),
        (this._w = i);
    }
    static slerpFlat(t, e, n, i, r, s, a) {
      let o = n[i + 0],
        l = n[i + 1],
        c = n[i + 2],
        h = n[i + 3];
      const u = r[s + 0],
        d = r[s + 1],
        p = r[s + 2],
        f = r[s + 3];
      if (0 === a)
        return (
          (t[e + 0] = o), (t[e + 1] = l), (t[e + 2] = c), void (t[e + 3] = h)
        );
      if (1 === a)
        return (
          (t[e + 0] = u), (t[e + 1] = d), (t[e + 2] = p), void (t[e + 3] = f)
        );
      if (h !== f || o !== u || l !== d || c !== p) {
        let t = 1 - a;
        const e = o * u + l * d + c * p + h * f,
          n = e >= 0 ? 1 : -1,
          i = 1 - e * e;
        if (i > Number.EPSILON) {
          const r = Math.sqrt(i),
            s = Math.atan2(r, e * n);
          (t = Math.sin(t * s) / r), (a = Math.sin(a * s) / r);
        }
        const r = a * n;
        if (
          ((o = o * t + u * r),
          (l = l * t + d * r),
          (c = c * t + p * r),
          (h = h * t + f * r),
          t === 1 - a)
        ) {
          const t = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
          (o *= t), (l *= t), (c *= t), (h *= t);
        }
      }
      (t[e] = o), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = h);
    }
    static multiplyQuaternionsFlat(t, e, n, i, r, s) {
      const a = n[i],
        o = n[i + 1],
        l = n[i + 2],
        c = n[i + 3],
        h = r[s],
        u = r[s + 1],
        d = r[s + 2],
        p = r[s + 3];
      return (
        (t[e] = a * p + c * h + o * d - l * u),
        (t[e + 1] = o * p + c * u + l * h - a * d),
        (t[e + 2] = l * p + c * d + a * u - o * h),
        (t[e + 3] = c * p - a * h - o * u - l * d),
        t
      );
    }
    get x() {
      return this._x;
    }
    set x(t) {
      (this._x = t), this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t) {
      (this._y = t), this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t) {
      (this._z = t), this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(t) {
      (this._w = t), this._onChangeCallback();
    }
    set(t, e, n, i) {
      return (
        (this._x = t),
        (this._y = e),
        (this._z = n),
        (this._w = i),
        this._onChangeCallback(),
        this
      );
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(t) {
      return (
        (this._x = t.x),
        (this._y = t.y),
        (this._z = t.z),
        (this._w = t.w),
        this._onChangeCallback(),
        this
      );
    }
    setFromEuler(t, e = !0) {
      const n = t._x,
        i = t._y,
        r = t._z,
        s = t._order,
        a = Math.cos,
        o = Math.sin,
        l = a(n / 2),
        c = a(i / 2),
        h = a(r / 2),
        u = o(n / 2),
        d = o(i / 2),
        p = o(r / 2);
      switch (s) {
        case "XYZ":
          (this._x = u * c * h + l * d * p),
            (this._y = l * d * h - u * c * p),
            (this._z = l * c * p + u * d * h),
            (this._w = l * c * h - u * d * p);
          break;
        case "YXZ":
          (this._x = u * c * h + l * d * p),
            (this._y = l * d * h - u * c * p),
            (this._z = l * c * p - u * d * h),
            (this._w = l * c * h + u * d * p);
          break;
        case "ZXY":
          (this._x = u * c * h - l * d * p),
            (this._y = l * d * h + u * c * p),
            (this._z = l * c * p + u * d * h),
            (this._w = l * c * h - u * d * p);
          break;
        case "ZYX":
          (this._x = u * c * h - l * d * p),
            (this._y = l * d * h + u * c * p),
            (this._z = l * c * p - u * d * h),
            (this._w = l * c * h + u * d * p);
          break;
        case "YZX":
          (this._x = u * c * h + l * d * p),
            (this._y = l * d * h + u * c * p),
            (this._z = l * c * p - u * d * h),
            (this._w = l * c * h - u * d * p);
          break;
        case "XZY":
          (this._x = u * c * h - l * d * p),
            (this._y = l * d * h - u * c * p),
            (this._z = l * c * p + u * d * h),
            (this._w = l * c * h + u * d * p);
          break;
        default:
          console.warn(
            "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
              s
          );
      }
      return !0 === e && this._onChangeCallback(), this;
    }
    setFromAxisAngle(t, e) {
      const n = e / 2,
        i = Math.sin(n);
      return (
        (this._x = t.x * i),
        (this._y = t.y * i),
        (this._z = t.z * i),
        (this._w = Math.cos(n)),
        this._onChangeCallback(),
        this
      );
    }
    setFromRotationMatrix(t) {
      const e = t.elements,
        n = e[0],
        i = e[4],
        r = e[8],
        s = e[1],
        a = e[5],
        o = e[9],
        l = e[2],
        c = e[6],
        h = e[10],
        u = n + a + h;
      if (u > 0) {
        const t = 0.5 / Math.sqrt(u + 1);
        (this._w = 0.25 / t),
          (this._x = (c - o) * t),
          (this._y = (r - l) * t),
          (this._z = (s - i) * t);
      } else if (n > a && n > h) {
        const t = 2 * Math.sqrt(1 + n - a - h);
        (this._w = (c - o) / t),
          (this._x = 0.25 * t),
          (this._y = (i + s) / t),
          (this._z = (r + l) / t);
      } else if (a > h) {
        const t = 2 * Math.sqrt(1 + a - n - h);
        (this._w = (r - l) / t),
          (this._x = (i + s) / t),
          (this._y = 0.25 * t),
          (this._z = (o + c) / t);
      } else {
        const t = 2 * Math.sqrt(1 + h - n - a);
        (this._w = (s - i) / t),
          (this._x = (r + l) / t),
          (this._y = (o + c) / t),
          (this._z = 0.25 * t);
      }
      return this._onChangeCallback(), this;
    }
    setFromUnitVectors(t, e) {
      let n = t.dot(e) + 1;
      return (
        n < Number.EPSILON
          ? ((n = 0),
            Math.abs(t.x) > Math.abs(t.z)
              ? ((this._x = -t.y),
                (this._y = t.x),
                (this._z = 0),
                (this._w = n))
              : ((this._x = 0),
                (this._y = -t.z),
                (this._z = t.y),
                (this._w = n)))
          : ((this._x = t.y * e.z - t.z * e.y),
            (this._y = t.z * e.x - t.x * e.z),
            (this._z = t.x * e.y - t.y * e.x),
            (this._w = n)),
        this.normalize()
      );
    }
    angleTo(t) {
      return 2 * Math.acos(Math.abs(dt(this.dot(t), -1, 1)));
    }
    rotateTowards(t, e) {
      const n = this.angleTo(t);
      if (0 === n) return this;
      const i = Math.min(1, e / n);
      return this.slerp(t, i), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return (
        (this._x *= -1),
        (this._y *= -1),
        (this._z *= -1),
        this._onChangeCallback(),
        this
      );
    }
    dot(t) {
      return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
    }
    lengthSq() {
      return (
        this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
      );
    }
    length() {
      return Math.sqrt(
        this._x * this._x +
          this._y * this._y +
          this._z * this._z +
          this._w * this._w
      );
    }
    normalize() {
      let t = this.length();
      return (
        0 === t
          ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
          : ((t = 1 / t),
            (this._x = this._x * t),
            (this._y = this._y * t),
            (this._z = this._z * t),
            (this._w = this._w * t)),
        this._onChangeCallback(),
        this
      );
    }
    multiply(t) {
      return this.multiplyQuaternions(this, t);
    }
    premultiply(t) {
      return this.multiplyQuaternions(t, this);
    }
    multiplyQuaternions(t, e) {
      const n = t._x,
        i = t._y,
        r = t._z,
        s = t._w,
        a = e._x,
        o = e._y,
        l = e._z,
        c = e._w;
      return (
        (this._x = n * c + s * a + i * l - r * o),
        (this._y = i * c + s * o + r * a - n * l),
        (this._z = r * c + s * l + n * o - i * a),
        (this._w = s * c - n * a - i * o - r * l),
        this._onChangeCallback(),
        this
      );
    }
    slerp(t, e) {
      if (0 === e) return this;
      if (1 === e) return this.copy(t);
      const n = this._x,
        i = this._y,
        r = this._z,
        s = this._w;
      let a = s * t._w + n * t._x + i * t._y + r * t._z;
      if (
        (a < 0
          ? ((this._w = -t._w),
            (this._x = -t._x),
            (this._y = -t._y),
            (this._z = -t._z),
            (a = -a))
          : this.copy(t),
        a >= 1)
      )
        return (this._w = s), (this._x = n), (this._y = i), (this._z = r), this;
      const o = 1 - a * a;
      if (o <= Number.EPSILON) {
        const t = 1 - e;
        return (
          (this._w = t * s + e * this._w),
          (this._x = t * n + e * this._x),
          (this._y = t * i + e * this._y),
          (this._z = t * r + e * this._z),
          this.normalize(),
          this
        );
      }
      const l = Math.sqrt(o),
        c = Math.atan2(l, a),
        h = Math.sin((1 - e) * c) / l,
        u = Math.sin(e * c) / l;
      return (
        (this._w = s * h + this._w * u),
        (this._x = n * h + this._x * u),
        (this._y = i * h + this._y * u),
        (this._z = r * h + this._z * u),
        this._onChangeCallback(),
        this
      );
    }
    slerpQuaternions(t, e, n) {
      return this.copy(t).slerp(e, n);
    }
    random() {
      const t = Math.random(),
        e = Math.sqrt(1 - t),
        n = Math.sqrt(t),
        i = 2 * Math.PI * Math.random(),
        r = 2 * Math.PI * Math.random();
      return this.set(
        e * Math.cos(i),
        n * Math.sin(r),
        n * Math.cos(r),
        e * Math.sin(i)
      );
    }
    equals(t) {
      return (
        t._x === this._x &&
        t._y === this._y &&
        t._z === this._z &&
        t._w === this._w
      );
    }
    fromArray(t, e = 0) {
      return (
        (this._x = t[e]),
        (this._y = t[e + 1]),
        (this._z = t[e + 2]),
        (this._w = t[e + 3]),
        this._onChangeCallback(),
        this
      );
    }
    toArray(t = [], e = 0) {
      return (
        (t[e] = this._x),
        (t[e + 1] = this._y),
        (t[e + 2] = this._z),
        (t[e + 3] = this._w),
        t
      );
    }
    fromBufferAttribute(t, e) {
      return (
        (this._x = t.getX(e)),
        (this._y = t.getY(e)),
        (this._z = t.getZ(e)),
        (this._w = t.getW(e)),
        this._onChangeCallback(),
        this
      );
    }
    toJSON() {
      return this.toArray();
    }
    _onChange(t) {
      return (this._onChangeCallback = t), this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._w;
    }
  }
  class Yt {
    constructor(t = 0, e = 0, n = 0) {
      (Yt.prototype.isVector3 = !0), (this.x = t), (this.y = e), (this.z = n);
    }
    set(t, e, n) {
      return (
        void 0 === n && (n = this.z),
        (this.x = t),
        (this.y = e),
        (this.z = n),
        this
      );
    }
    setScalar(t) {
      return (this.x = t), (this.y = t), (this.z = t), this;
    }
    setX(t) {
      return (this.x = t), this;
    }
    setY(t) {
      return (this.y = t), this;
    }
    setZ(t) {
      return (this.z = t), this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(t) {
      return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
    }
    add(t) {
      return (this.x += t.x), (this.y += t.y), (this.z += t.z), this;
    }
    addScalar(t) {
      return (this.x += t), (this.y += t), (this.z += t), this;
    }
    addVectors(t, e) {
      return (
        (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
      );
    }
    addScaledVector(t, e) {
      return (
        (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
      );
    }
    sub(t) {
      return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this;
    }
    subScalar(t) {
      return (this.x -= t), (this.y -= t), (this.z -= t), this;
    }
    subVectors(t, e) {
      return (
        (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
      );
    }
    multiply(t) {
      return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this;
    }
    multiplyScalar(t) {
      return (this.x *= t), (this.y *= t), (this.z *= t), this;
    }
    multiplyVectors(t, e) {
      return (
        (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
      );
    }
    applyEuler(t) {
      return this.applyQuaternion(Zt.setFromEuler(t));
    }
    applyAxisAngle(t, e) {
      return this.applyQuaternion(Zt.setFromAxisAngle(t, e));
    }
    applyMatrix3(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = t.elements;
      return (
        (this.x = r[0] * e + r[3] * n + r[6] * i),
        (this.y = r[1] * e + r[4] * n + r[7] * i),
        (this.z = r[2] * e + r[5] * n + r[8] * i),
        this
      );
    }
    applyNormalMatrix(t) {
      return this.applyMatrix3(t).normalize();
    }
    applyMatrix4(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = t.elements,
        s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
      return (
        (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s),
        (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s),
        (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s),
        this
      );
    }
    applyQuaternion(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = t.x,
        s = t.y,
        a = t.z,
        o = t.w,
        l = 2 * (s * i - a * n),
        c = 2 * (a * e - r * i),
        h = 2 * (r * n - s * e);
      return (
        (this.x = e + o * l + s * h - a * c),
        (this.y = n + o * c + a * l - r * h),
        (this.z = i + o * h + r * c - s * l),
        this
      );
    }
    project(t) {
      return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
        t.projectionMatrix
      );
    }
    unproject(t) {
      return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
        t.matrixWorld
      );
    }
    transformDirection(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = t.elements;
      return (
        (this.x = r[0] * e + r[4] * n + r[8] * i),
        (this.y = r[1] * e + r[5] * n + r[9] * i),
        (this.z = r[2] * e + r[6] * n + r[10] * i),
        this.normalize()
      );
    }
    divide(t) {
      return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    min(t) {
      return (
        (this.x = Math.min(this.x, t.x)),
        (this.y = Math.min(this.y, t.y)),
        (this.z = Math.min(this.z, t.z)),
        this
      );
    }
    max(t) {
      return (
        (this.x = Math.max(this.x, t.x)),
        (this.y = Math.max(this.y, t.y)),
        (this.z = Math.max(this.z, t.z)),
        this
      );
    }
    clamp(t, e) {
      return (
        (this.x = Math.max(t.x, Math.min(e.x, this.x))),
        (this.y = Math.max(t.y, Math.min(e.y, this.y))),
        (this.z = Math.max(t.z, Math.min(e.z, this.z))),
        this
      );
    }
    clampScalar(t, e) {
      return (
        (this.x = Math.max(t, Math.min(e, this.x))),
        (this.y = Math.max(t, Math.min(e, this.y))),
        (this.z = Math.max(t, Math.min(e, this.z))),
        this
      );
    }
    clampLength(t, e) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(
        Math.max(t, Math.min(e, n))
      );
    }
    floor() {
      return (
        (this.x = Math.floor(this.x)),
        (this.y = Math.floor(this.y)),
        (this.z = Math.floor(this.z)),
        this
      );
    }
    ceil() {
      return (
        (this.x = Math.ceil(this.x)),
        (this.y = Math.ceil(this.y)),
        (this.z = Math.ceil(this.z)),
        this
      );
    }
    round() {
      return (
        (this.x = Math.round(this.x)),
        (this.y = Math.round(this.y)),
        (this.z = Math.round(this.z)),
        this
      );
    }
    roundToZero() {
      return (
        (this.x = Math.trunc(this.x)),
        (this.y = Math.trunc(this.y)),
        (this.z = Math.trunc(this.z)),
        this
      );
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
    }
    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return (
        (this.x += (t.x - this.x) * e),
        (this.y += (t.y - this.y) * e),
        (this.z += (t.z - this.z) * e),
        this
      );
    }
    lerpVectors(t, e, n) {
      return (
        (this.x = t.x + (e.x - t.x) * n),
        (this.y = t.y + (e.y - t.y) * n),
        (this.z = t.z + (e.z - t.z) * n),
        this
      );
    }
    cross(t) {
      return this.crossVectors(this, t);
    }
    crossVectors(t, e) {
      const n = t.x,
        i = t.y,
        r = t.z,
        s = e.x,
        a = e.y,
        o = e.z;
      return (
        (this.x = i * o - r * a),
        (this.y = r * s - n * o),
        (this.z = n * a - i * s),
        this
      );
    }
    projectOnVector(t) {
      const e = t.lengthSq();
      if (0 === e) return this.set(0, 0, 0);
      const n = t.dot(this) / e;
      return this.copy(t).multiplyScalar(n);
    }
    projectOnPlane(t) {
      return Kt.copy(this).projectOnVector(t), this.sub(Kt);
    }
    reflect(t) {
      return this.sub(Kt.copy(t).multiplyScalar(2 * this.dot(t)));
    }
    angleTo(t) {
      const e = Math.sqrt(this.lengthSq() * t.lengthSq());
      if (0 === e) return Math.PI / 2;
      const n = this.dot(t) / e;
      return Math.acos(dt(n, -1, 1));
    }
    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t));
    }
    distanceToSquared(t) {
      const e = this.x - t.x,
        n = this.y - t.y,
        i = this.z - t.z;
      return e * e + n * n + i * i;
    }
    manhattanDistanceTo(t) {
      return (
        Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
      );
    }
    setFromSpherical(t) {
      return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
    }
    setFromSphericalCoords(t, e, n) {
      const i = Math.sin(e) * t;
      return (
        (this.x = i * Math.sin(n)),
        (this.y = Math.cos(e) * t),
        (this.z = i * Math.cos(n)),
        this
      );
    }
    setFromCylindrical(t) {
      return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
    }
    setFromCylindricalCoords(t, e, n) {
      return (
        (this.x = t * Math.sin(e)),
        (this.y = n),
        (this.z = t * Math.cos(e)),
        this
      );
    }
    setFromMatrixPosition(t) {
      const e = t.elements;
      return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
    }
    setFromMatrixScale(t) {
      const e = this.setFromMatrixColumn(t, 0).length(),
        n = this.setFromMatrixColumn(t, 1).length(),
        i = this.setFromMatrixColumn(t, 2).length();
      return (this.x = e), (this.y = n), (this.z = i), this;
    }
    setFromMatrixColumn(t, e) {
      return this.fromArray(t.elements, 4 * e);
    }
    setFromMatrix3Column(t, e) {
      return this.fromArray(t.elements, 3 * e);
    }
    setFromEuler(t) {
      return (this.x = t._x), (this.y = t._y), (this.z = t._z), this;
    }
    setFromColor(t) {
      return (this.x = t.r), (this.y = t.g), (this.z = t.b), this;
    }
    equals(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z;
    }
    fromArray(t, e = 0) {
      return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this;
    }
    toArray(t = [], e = 0) {
      return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
    }
    fromBufferAttribute(t, e) {
      return (
        (this.x = t.getX(e)), (this.y = t.getY(e)), (this.z = t.getZ(e)), this
      );
    }
    random() {
      return (
        (this.x = Math.random()),
        (this.y = Math.random()),
        (this.z = Math.random()),
        this
      );
    }
    randomDirection() {
      const t = 2 * (Math.random() - 0.5),
        e = Math.random() * Math.PI * 2,
        n = Math.sqrt(1 - t ** 2);
      return (
        (this.x = n * Math.cos(e)),
        (this.y = n * Math.sin(e)),
        (this.z = t),
        this
      );
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z;
    }
  }
  const Kt = new Yt(),
    Zt = new qt();
  class Jt {
    constructor(
      t = new Yt(1 / 0, 1 / 0, 1 / 0),
      e = new Yt(-1 / 0, -1 / 0, -1 / 0)
    ) {
      (this.isBox3 = !0), (this.min = t), (this.max = e);
    }
    set(t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    }
    setFromArray(t) {
      this.makeEmpty();
      for (let e = 0, n = t.length; e < n; e += 3)
        this.expandByPoint($t.fromArray(t, e));
      return this;
    }
    setFromBufferAttribute(t) {
      this.makeEmpty();
      for (let e = 0, n = t.count; e < n; e++)
        this.expandByPoint($t.fromBufferAttribute(t, e));
      return this;
    }
    setFromPoints(t) {
      this.makeEmpty();
      for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
      return this;
    }
    setFromCenterAndSize(t, e) {
      const n = $t.copy(e).multiplyScalar(0.5);
      return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
    }
    setFromObject(t, e = !1) {
      return this.makeEmpty(), this.expandByObject(t, e);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    }
    makeEmpty() {
      return (
        (this.min.x = this.min.y = this.min.z = 1 / 0),
        (this.max.x = this.max.y = this.max.z = -1 / 0),
        this
      );
    }
    isEmpty() {
      return (
        this.max.x < this.min.x ||
        this.max.y < this.min.y ||
        this.max.z < this.min.z
      );
    }
    getCenter(t) {
      return this.isEmpty()
        ? t.set(0, 0, 0)
        : t.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(t) {
      return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
    }
    expandByPoint(t) {
      return this.min.min(t), this.max.max(t), this;
    }
    expandByVector(t) {
      return this.min.sub(t), this.max.add(t), this;
    }
    expandByScalar(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    }
    expandByObject(t, e = !1) {
      t.updateWorldMatrix(!1, !1);
      const n = t.geometry;
      if (void 0 !== n) {
        const i = n.getAttribute("position");
        if (!0 === e && void 0 !== i && !0 !== t.isInstancedMesh)
          for (let e = 0, n = i.count; e < n; e++)
            !0 === t.isMesh
              ? t.getVertexPosition(e, $t)
              : $t.fromBufferAttribute(i, e),
              $t.applyMatrix4(t.matrixWorld),
              this.expandByPoint($t);
        else
          void 0 !== t.boundingBox
            ? (null === t.boundingBox && t.computeBoundingBox(),
              te.copy(t.boundingBox))
            : (null === n.boundingBox && n.computeBoundingBox(),
              te.copy(n.boundingBox)),
            te.applyMatrix4(t.matrixWorld),
            this.union(te);
      }
      const i = t.children;
      for (let t = 0, n = i.length; t < n; t++) this.expandByObject(i[t], e);
      return this;
    }
    containsPoint(t) {
      return !(
        t.x < this.min.x ||
        t.x > this.max.x ||
        t.y < this.min.y ||
        t.y > this.max.y ||
        t.z < this.min.z ||
        t.z > this.max.z
      );
    }
    containsBox(t) {
      return (
        this.min.x <= t.min.x &&
        t.max.x <= this.max.x &&
        this.min.y <= t.min.y &&
        t.max.y <= this.max.y &&
        this.min.z <= t.min.z &&
        t.max.z <= this.max.z
      );
    }
    getParameter(t, e) {
      return e.set(
        (t.x - this.min.x) / (this.max.x - this.min.x),
        (t.y - this.min.y) / (this.max.y - this.min.y),
        (t.z - this.min.z) / (this.max.z - this.min.z)
      );
    }
    intersectsBox(t) {
      return !(
        t.max.x < this.min.x ||
        t.min.x > this.max.x ||
        t.max.y < this.min.y ||
        t.min.y > this.max.y ||
        t.max.z < this.min.z ||
        t.min.z > this.max.z
      );
    }
    intersectsSphere(t) {
      return (
        this.clampPoint(t.center, $t),
        $t.distanceToSquared(t.center) <= t.radius * t.radius
      );
    }
    intersectsPlane(t) {
      let e, n;
      return (
        t.normal.x > 0
          ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
          : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
        t.normal.y > 0
          ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
          : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
        t.normal.z > 0
          ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
          : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
        e <= -t.constant && n >= -t.constant
      );
    }
    intersectsTriangle(t) {
      if (this.isEmpty()) return !1;
      this.getCenter(oe),
        le.subVectors(this.max, oe),
        ee.subVectors(t.a, oe),
        ne.subVectors(t.b, oe),
        ie.subVectors(t.c, oe),
        re.subVectors(ne, ee),
        se.subVectors(ie, ne),
        ae.subVectors(ee, ie);
      let e = [
        0,
        -re.z,
        re.y,
        0,
        -se.z,
        se.y,
        0,
        -ae.z,
        ae.y,
        re.z,
        0,
        -re.x,
        se.z,
        0,
        -se.x,
        ae.z,
        0,
        -ae.x,
        -re.y,
        re.x,
        0,
        -se.y,
        se.x,
        0,
        -ae.y,
        ae.x,
        0,
      ];
      return (
        !!ue(e, ee, ne, ie, le) &&
        ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        !!ue(e, ee, ne, ie, le) &&
          (ce.crossVectors(re, se),
          (e = [ce.x, ce.y, ce.z]),
          ue(e, ee, ne, ie, le)))
      );
    }
    clampPoint(t, e) {
      return e.copy(t).clamp(this.min, this.max);
    }
    distanceToPoint(t) {
      return this.clampPoint(t, $t).distanceTo(t);
    }
    getBoundingSphere(t) {
      return (
        this.isEmpty()
          ? t.makeEmpty()
          : (this.getCenter(t.center),
            (t.radius = 0.5 * this.getSize($t).length())),
        t
      );
    }
    intersect(t) {
      return (
        this.min.max(t.min),
        this.max.min(t.max),
        this.isEmpty() && this.makeEmpty(),
        this
      );
    }
    union(t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    }
    applyMatrix4(t) {
      return (
        this.isEmpty() ||
          (Qt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
          Qt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
          Qt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
          Qt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
          Qt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
          Qt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
          Qt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
          Qt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
          this.setFromPoints(Qt)),
        this
      );
    }
    translate(t) {
      return this.min.add(t), this.max.add(t), this;
    }
    equals(t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }
  }
  const Qt = [
      new Yt(),
      new Yt(),
      new Yt(),
      new Yt(),
      new Yt(),
      new Yt(),
      new Yt(),
      new Yt(),
    ],
    $t = new Yt(),
    te = new Jt(),
    ee = new Yt(),
    ne = new Yt(),
    ie = new Yt(),
    re = new Yt(),
    se = new Yt(),
    ae = new Yt(),
    oe = new Yt(),
    le = new Yt(),
    ce = new Yt(),
    he = new Yt();
  function ue(t, e, n, i, r) {
    for (let s = 0, a = t.length - 3; s <= a; s += 3) {
      he.fromArray(t, s);
      const a =
          r.x * Math.abs(he.x) + r.y * Math.abs(he.y) + r.z * Math.abs(he.z),
        o = e.dot(he),
        l = n.dot(he),
        c = i.dot(he);
      if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1;
    }
    return !0;
  }
  const de = new Jt(),
    pe = new Yt(),
    fe = new Yt();
  class me {
    constructor(t = new Yt(), e = -1) {
      (this.isSphere = !0), (this.center = t), (this.radius = e);
    }
    set(t, e) {
      return this.center.copy(t), (this.radius = e), this;
    }
    setFromPoints(t, e) {
      const n = this.center;
      void 0 !== e ? n.copy(e) : de.setFromPoints(t).getCenter(n);
      let i = 0;
      for (let e = 0, r = t.length; e < r; e++)
        i = Math.max(i, n.distanceToSquared(t[e]));
      return (this.radius = Math.sqrt(i)), this;
    }
    copy(t) {
      return this.center.copy(t.center), (this.radius = t.radius), this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), (this.radius = -1), this;
    }
    containsPoint(t) {
      return t.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(t) {
      return t.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(t) {
      const e = this.radius + t.radius;
      return t.center.distanceToSquared(this.center) <= e * e;
    }
    intersectsBox(t) {
      return t.intersectsSphere(this);
    }
    intersectsPlane(t) {
      return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(t, e) {
      const n = this.center.distanceToSquared(t);
      return (
        e.copy(t),
        n > this.radius * this.radius &&
          (e.sub(this.center).normalize(),
          e.multiplyScalar(this.radius).add(this.center)),
        e
      );
    }
    getBoundingBox(t) {
      return this.isEmpty()
        ? (t.makeEmpty(), t)
        : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
    }
    applyMatrix4(t) {
      return (
        this.center.applyMatrix4(t),
        (this.radius = this.radius * t.getMaxScaleOnAxis()),
        this
      );
    }
    translate(t) {
      return this.center.add(t), this;
    }
    expandByPoint(t) {
      if (this.isEmpty()) return this.center.copy(t), (this.radius = 0), this;
      pe.subVectors(t, this.center);
      const e = pe.lengthSq();
      if (e > this.radius * this.radius) {
        const t = Math.sqrt(e),
          n = 0.5 * (t - this.radius);
        this.center.addScaledVector(pe, n / t), (this.radius += n);
      }
      return this;
    }
    union(t) {
      return t.isEmpty()
        ? this
        : this.isEmpty()
        ? (this.copy(t), this)
        : (!0 === this.center.equals(t.center)
            ? (this.radius = Math.max(this.radius, t.radius))
            : (fe.subVectors(t.center, this.center).setLength(t.radius),
              this.expandByPoint(pe.copy(t.center).add(fe)),
              this.expandByPoint(pe.copy(t.center).sub(fe))),
          this);
    }
    equals(t) {
      return t.center.equals(this.center) && t.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const ge = new Yt(),
    _e = new Yt(),
    ve = new Yt(),
    ye = new Yt(),
    xe = new Yt(),
    Te = new Yt(),
    Me = new Yt();
  class Se {
    constructor(t = new Yt(), e = new Yt(0, 0, -1)) {
      (this.origin = t), (this.direction = e);
    }
    set(t, e) {
      return this.origin.copy(t), this.direction.copy(e), this;
    }
    copy(t) {
      return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
    }
    at(t, e) {
      return e.copy(this.origin).addScaledVector(this.direction, t);
    }
    lookAt(t) {
      return this.direction.copy(t).sub(this.origin).normalize(), this;
    }
    recast(t) {
      return this.origin.copy(this.at(t, ge)), this;
    }
    closestPointToPoint(t, e) {
      e.subVectors(t, this.origin);
      const n = e.dot(this.direction);
      return n < 0
        ? e.copy(this.origin)
        : e.copy(this.origin).addScaledVector(this.direction, n);
    }
    distanceToPoint(t) {
      return Math.sqrt(this.distanceSqToPoint(t));
    }
    distanceSqToPoint(t) {
      const e = ge.subVectors(t, this.origin).dot(this.direction);
      return e < 0
        ? this.origin.distanceToSquared(t)
        : (ge.copy(this.origin).addScaledVector(this.direction, e),
          ge.distanceToSquared(t));
    }
    distanceSqToSegment(t, e, n, i) {
      _e.copy(t).add(e).multiplyScalar(0.5),
        ve.copy(e).sub(t).normalize(),
        ye.copy(this.origin).sub(_e);
      const r = 0.5 * t.distanceTo(e),
        s = -this.direction.dot(ve),
        a = ye.dot(this.direction),
        o = -ye.dot(ve),
        l = ye.lengthSq(),
        c = Math.abs(1 - s * s);
      let h, u, d, p;
      if (c > 0)
        if (((h = s * o - a), (u = s * a - o), (p = r * c), h >= 0))
          if (u >= -p)
            if (u <= p) {
              const t = 1 / c;
              (h *= t),
                (u *= t),
                (d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l);
            } else
              (u = r),
                (h = Math.max(0, -(s * u + a))),
                (d = -h * h + u * (u + 2 * o) + l);
          else
            (u = -r),
              (h = Math.max(0, -(s * u + a))),
              (d = -h * h + u * (u + 2 * o) + l);
        else
          u <= -p
            ? ((h = Math.max(0, -(-s * r + a))),
              (u = h > 0 ? -r : Math.min(Math.max(-r, -o), r)),
              (d = -h * h + u * (u + 2 * o) + l))
            : u <= p
            ? ((h = 0),
              (u = Math.min(Math.max(-r, -o), r)),
              (d = u * (u + 2 * o) + l))
            : ((h = Math.max(0, -(s * r + a))),
              (u = h > 0 ? r : Math.min(Math.max(-r, -o), r)),
              (d = -h * h + u * (u + 2 * o) + l));
      else
        (u = s > 0 ? -r : r),
          (h = Math.max(0, -(s * u + a))),
          (d = -h * h + u * (u + 2 * o) + l);
      return (
        n && n.copy(this.origin).addScaledVector(this.direction, h),
        i && i.copy(_e).addScaledVector(ve, u),
        d
      );
    }
    intersectSphere(t, e) {
      ge.subVectors(t.center, this.origin);
      const n = ge.dot(this.direction),
        i = ge.dot(ge) - n * n,
        r = t.radius * t.radius;
      if (i > r) return null;
      const s = Math.sqrt(r - i),
        a = n - s,
        o = n + s;
      return o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e);
    }
    intersectsSphere(t) {
      return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
    }
    distanceToPlane(t) {
      const e = t.normal.dot(this.direction);
      if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
      const n = -(this.origin.dot(t.normal) + t.constant) / e;
      return n >= 0 ? n : null;
    }
    intersectPlane(t, e) {
      const n = this.distanceToPlane(t);
      return null === n ? null : this.at(n, e);
    }
    intersectsPlane(t) {
      const e = t.distanceToPoint(this.origin);
      return 0 === e || t.normal.dot(this.direction) * e < 0;
    }
    intersectBox(t, e) {
      let n, i, r, s, a, o;
      const l = 1 / this.direction.x,
        c = 1 / this.direction.y,
        h = 1 / this.direction.z,
        u = this.origin;
      return (
        l >= 0
          ? ((n = (t.min.x - u.x) * l), (i = (t.max.x - u.x) * l))
          : ((n = (t.max.x - u.x) * l), (i = (t.min.x - u.x) * l)),
        c >= 0
          ? ((r = (t.min.y - u.y) * c), (s = (t.max.y - u.y) * c))
          : ((r = (t.max.y - u.y) * c), (s = (t.min.y - u.y) * c)),
        n > s || r > i
          ? null
          : ((r > n || isNaN(n)) && (n = r),
            (s < i || isNaN(i)) && (i = s),
            h >= 0
              ? ((a = (t.min.z - u.z) * h), (o = (t.max.z - u.z) * h))
              : ((a = (t.max.z - u.z) * h), (o = (t.min.z - u.z) * h)),
            n > o || a > i
              ? null
              : ((a > n || n != n) && (n = a),
                (o < i || i != i) && (i = o),
                i < 0 ? null : this.at(n >= 0 ? n : i, e)))
      );
    }
    intersectsBox(t) {
      return null !== this.intersectBox(t, ge);
    }
    intersectTriangle(t, e, n, i, r) {
      xe.subVectors(e, t), Te.subVectors(n, t), Me.crossVectors(xe, Te);
      let s,
        a = this.direction.dot(Me);
      if (a > 0) {
        if (i) return null;
        s = 1;
      } else {
        if (!(a < 0)) return null;
        (s = -1), (a = -a);
      }
      ye.subVectors(this.origin, t);
      const o = s * this.direction.dot(Te.crossVectors(ye, Te));
      if (o < 0) return null;
      const l = s * this.direction.dot(xe.cross(ye));
      if (l < 0) return null;
      if (o + l > a) return null;
      const c = -s * ye.dot(Me);
      return c < 0 ? null : this.at(c / a, r);
    }
    applyMatrix4(t) {
      return (
        this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
      );
    }
    equals(t) {
      return t.origin.equals(this.origin) && t.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class be {
    constructor(t, e, n, i, r, s, a, o, l, c, h, u, d, p, f, m) {
      (be.prototype.isMatrix4 = !0),
        (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        void 0 !== t &&
          this.set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, f, m);
    }
    set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, f, m) {
      const g = this.elements;
      return (
        (g[0] = t),
        (g[4] = e),
        (g[8] = n),
        (g[12] = i),
        (g[1] = r),
        (g[5] = s),
        (g[9] = a),
        (g[13] = o),
        (g[2] = l),
        (g[6] = c),
        (g[10] = h),
        (g[14] = u),
        (g[3] = d),
        (g[7] = p),
        (g[11] = f),
        (g[15] = m),
        this
      );
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new be().fromArray(this.elements);
    }
    copy(t) {
      const e = this.elements,
        n = t.elements;
      return (
        (e[0] = n[0]),
        (e[1] = n[1]),
        (e[2] = n[2]),
        (e[3] = n[3]),
        (e[4] = n[4]),
        (e[5] = n[5]),
        (e[6] = n[6]),
        (e[7] = n[7]),
        (e[8] = n[8]),
        (e[9] = n[9]),
        (e[10] = n[10]),
        (e[11] = n[11]),
        (e[12] = n[12]),
        (e[13] = n[13]),
        (e[14] = n[14]),
        (e[15] = n[15]),
        this
      );
    }
    copyPosition(t) {
      const e = this.elements,
        n = t.elements;
      return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
    }
    setFromMatrix3(t) {
      const e = t.elements;
      return (
        this.set(
          e[0],
          e[3],
          e[6],
          0,
          e[1],
          e[4],
          e[7],
          0,
          e[2],
          e[5],
          e[8],
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    extractBasis(t, e, n) {
      return (
        t.setFromMatrixColumn(this, 0),
        e.setFromMatrixColumn(this, 1),
        n.setFromMatrixColumn(this, 2),
        this
      );
    }
    makeBasis(t, e, n) {
      return (
        this.set(
          t.x,
          e.x,
          n.x,
          0,
          t.y,
          e.y,
          n.y,
          0,
          t.z,
          e.z,
          n.z,
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    extractRotation(t) {
      const e = this.elements,
        n = t.elements,
        i = 1 / Ee.setFromMatrixColumn(t, 0).length(),
        r = 1 / Ee.setFromMatrixColumn(t, 1).length(),
        s = 1 / Ee.setFromMatrixColumn(t, 2).length();
      return (
        (e[0] = n[0] * i),
        (e[1] = n[1] * i),
        (e[2] = n[2] * i),
        (e[3] = 0),
        (e[4] = n[4] * r),
        (e[5] = n[5] * r),
        (e[6] = n[6] * r),
        (e[7] = 0),
        (e[8] = n[8] * s),
        (e[9] = n[9] * s),
        (e[10] = n[10] * s),
        (e[11] = 0),
        (e[12] = 0),
        (e[13] = 0),
        (e[14] = 0),
        (e[15] = 1),
        this
      );
    }
    makeRotationFromEuler(t) {
      const e = this.elements,
        n = t.x,
        i = t.y,
        r = t.z,
        s = Math.cos(n),
        a = Math.sin(n),
        o = Math.cos(i),
        l = Math.sin(i),
        c = Math.cos(r),
        h = Math.sin(r);
      if ("XYZ" === t.order) {
        const t = s * c,
          n = s * h,
          i = a * c,
          r = a * h;
        (e[0] = o * c),
          (e[4] = -o * h),
          (e[8] = l),
          (e[1] = n + i * l),
          (e[5] = t - r * l),
          (e[9] = -a * o),
          (e[2] = r - t * l),
          (e[6] = i + n * l),
          (e[10] = s * o);
      } else if ("YXZ" === t.order) {
        const t = o * c,
          n = o * h,
          i = l * c,
          r = l * h;
        (e[0] = t + r * a),
          (e[4] = i * a - n),
          (e[8] = s * l),
          (e[1] = s * h),
          (e[5] = s * c),
          (e[9] = -a),
          (e[2] = n * a - i),
          (e[6] = r + t * a),
          (e[10] = s * o);
      } else if ("ZXY" === t.order) {
        const t = o * c,
          n = o * h,
          i = l * c,
          r = l * h;
        (e[0] = t - r * a),
          (e[4] = -s * h),
          (e[8] = i + n * a),
          (e[1] = n + i * a),
          (e[5] = s * c),
          (e[9] = r - t * a),
          (e[2] = -s * l),
          (e[6] = a),
          (e[10] = s * o);
      } else if ("ZYX" === t.order) {
        const t = s * c,
          n = s * h,
          i = a * c,
          r = a * h;
        (e[0] = o * c),
          (e[4] = i * l - n),
          (e[8] = t * l + r),
          (e[1] = o * h),
          (e[5] = r * l + t),
          (e[9] = n * l - i),
          (e[2] = -l),
          (e[6] = a * o),
          (e[10] = s * o);
      } else if ("YZX" === t.order) {
        const t = s * o,
          n = s * l,
          i = a * o,
          r = a * l;
        (e[0] = o * c),
          (e[4] = r - t * h),
          (e[8] = i * h + n),
          (e[1] = h),
          (e[5] = s * c),
          (e[9] = -a * c),
          (e[2] = -l * c),
          (e[6] = n * h + i),
          (e[10] = t - r * h);
      } else if ("XZY" === t.order) {
        const t = s * o,
          n = s * l,
          i = a * o,
          r = a * l;
        (e[0] = o * c),
          (e[4] = -h),
          (e[8] = l * c),
          (e[1] = t * h + r),
          (e[5] = s * c),
          (e[9] = n * h - i),
          (e[2] = i * h - n),
          (e[6] = a * c),
          (e[10] = r * h + t);
      }
      return (
        (e[3] = 0),
        (e[7] = 0),
        (e[11] = 0),
        (e[12] = 0),
        (e[13] = 0),
        (e[14] = 0),
        (e[15] = 1),
        this
      );
    }
    makeRotationFromQuaternion(t) {
      return this.compose(Ae, t, Re);
    }
    lookAt(t, e, n) {
      const i = this.elements;
      return (
        Le.subVectors(t, e),
        0 === Le.lengthSq() && (Le.z = 1),
        Le.normalize(),
        Ce.crossVectors(n, Le),
        0 === Ce.lengthSq() &&
          (1 === Math.abs(n.z) ? (Le.x += 1e-4) : (Le.z += 1e-4),
          Le.normalize(),
          Ce.crossVectors(n, Le)),
        Ce.normalize(),
        Pe.crossVectors(Le, Ce),
        (i[0] = Ce.x),
        (i[4] = Pe.x),
        (i[8] = Le.x),
        (i[1] = Ce.y),
        (i[5] = Pe.y),
        (i[9] = Le.y),
        (i[2] = Ce.z),
        (i[6] = Pe.z),
        (i[10] = Le.z),
        this
      );
    }
    multiply(t) {
      return this.multiplyMatrices(this, t);
    }
    premultiply(t) {
      return this.multiplyMatrices(t, this);
    }
    multiplyMatrices(t, e) {
      const n = t.elements,
        i = e.elements,
        r = this.elements,
        s = n[0],
        a = n[4],
        o = n[8],
        l = n[12],
        c = n[1],
        h = n[5],
        u = n[9],
        d = n[13],
        p = n[2],
        f = n[6],
        m = n[10],
        g = n[14],
        _ = n[3],
        v = n[7],
        y = n[11],
        x = n[15],
        T = i[0],
        M = i[4],
        S = i[8],
        b = i[12],
        E = i[1],
        w = i[5],
        A = i[9],
        R = i[13],
        C = i[2],
        P = i[6],
        L = i[10],
        D = i[14],
        I = i[3],
        U = i[7],
        N = i[11],
        O = i[15];
      return (
        (r[0] = s * T + a * E + o * C + l * I),
        (r[4] = s * M + a * w + o * P + l * U),
        (r[8] = s * S + a * A + o * L + l * N),
        (r[12] = s * b + a * R + o * D + l * O),
        (r[1] = c * T + h * E + u * C + d * I),
        (r[5] = c * M + h * w + u * P + d * U),
        (r[9] = c * S + h * A + u * L + d * N),
        (r[13] = c * b + h * R + u * D + d * O),
        (r[2] = p * T + f * E + m * C + g * I),
        (r[6] = p * M + f * w + m * P + g * U),
        (r[10] = p * S + f * A + m * L + g * N),
        (r[14] = p * b + f * R + m * D + g * O),
        (r[3] = _ * T + v * E + y * C + x * I),
        (r[7] = _ * M + v * w + y * P + x * U),
        (r[11] = _ * S + v * A + y * L + x * N),
        (r[15] = _ * b + v * R + y * D + x * O),
        this
      );
    }
    multiplyScalar(t) {
      const e = this.elements;
      return (
        (e[0] *= t),
        (e[4] *= t),
        (e[8] *= t),
        (e[12] *= t),
        (e[1] *= t),
        (e[5] *= t),
        (e[9] *= t),
        (e[13] *= t),
        (e[2] *= t),
        (e[6] *= t),
        (e[10] *= t),
        (e[14] *= t),
        (e[3] *= t),
        (e[7] *= t),
        (e[11] *= t),
        (e[15] *= t),
        this
      );
    }
    determinant() {
      const t = this.elements,
        e = t[0],
        n = t[4],
        i = t[8],
        r = t[12],
        s = t[1],
        a = t[5],
        o = t[9],
        l = t[13],
        c = t[2],
        h = t[6],
        u = t[10],
        d = t[14];
      return (
        t[3] *
          (+r * o * h -
            i * l * h -
            r * a * u +
            n * l * u +
            i * a * d -
            n * o * d) +
        t[7] *
          (+e * o * d -
            e * l * u +
            r * s * u -
            i * s * d +
            i * l * c -
            r * o * c) +
        t[11] *
          (+e * l * h -
            e * a * d -
            r * s * h +
            n * s * d +
            r * a * c -
            n * l * c) +
        t[15] *
          (-i * a * c -
            e * o * h +
            e * a * u +
            i * s * h -
            n * s * u +
            n * o * c)
      );
    }
    transpose() {
      const t = this.elements;
      let e;
      return (
        (e = t[1]),
        (t[1] = t[4]),
        (t[4] = e),
        (e = t[2]),
        (t[2] = t[8]),
        (t[8] = e),
        (e = t[6]),
        (t[6] = t[9]),
        (t[9] = e),
        (e = t[3]),
        (t[3] = t[12]),
        (t[12] = e),
        (e = t[7]),
        (t[7] = t[13]),
        (t[13] = e),
        (e = t[11]),
        (t[11] = t[14]),
        (t[14] = e),
        this
      );
    }
    setPosition(t, e, n) {
      const i = this.elements;
      return (
        t.isVector3
          ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
          : ((i[12] = t), (i[13] = e), (i[14] = n)),
        this
      );
    }
    invert() {
      const t = this.elements,
        e = t[0],
        n = t[1],
        i = t[2],
        r = t[3],
        s = t[4],
        a = t[5],
        o = t[6],
        l = t[7],
        c = t[8],
        h = t[9],
        u = t[10],
        d = t[11],
        p = t[12],
        f = t[13],
        m = t[14],
        g = t[15],
        _ =
          h * m * l - f * u * l + f * o * d - a * m * d - h * o * g + a * u * g,
        v =
          p * u * l - c * m * l - p * o * d + s * m * d + c * o * g - s * u * g,
        y =
          c * f * l - p * h * l + p * a * d - s * f * d - c * a * g + s * h * g,
        x =
          p * h * o - c * f * o - p * a * u + s * f * u + c * a * m - s * h * m,
        T = e * _ + n * v + i * y + r * x;
      if (0 === T)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const M = 1 / T;
      return (
        (t[0] = _ * M),
        (t[1] =
          (f * u * r -
            h * m * r -
            f * i * d +
            n * m * d +
            h * i * g -
            n * u * g) *
          M),
        (t[2] =
          (a * m * r -
            f * o * r +
            f * i * l -
            n * m * l -
            a * i * g +
            n * o * g) *
          M),
        (t[3] =
          (h * o * r -
            a * u * r -
            h * i * l +
            n * u * l +
            a * i * d -
            n * o * d) *
          M),
        (t[4] = v * M),
        (t[5] =
          (c * m * r -
            p * u * r +
            p * i * d -
            e * m * d -
            c * i * g +
            e * u * g) *
          M),
        (t[6] =
          (p * o * r -
            s * m * r -
            p * i * l +
            e * m * l +
            s * i * g -
            e * o * g) *
          M),
        (t[7] =
          (s * u * r -
            c * o * r +
            c * i * l -
            e * u * l -
            s * i * d +
            e * o * d) *
          M),
        (t[8] = y * M),
        (t[9] =
          (p * h * r -
            c * f * r -
            p * n * d +
            e * f * d +
            c * n * g -
            e * h * g) *
          M),
        (t[10] =
          (s * f * r -
            p * a * r +
            p * n * l -
            e * f * l -
            s * n * g +
            e * a * g) *
          M),
        (t[11] =
          (c * a * r -
            s * h * r -
            c * n * l +
            e * h * l +
            s * n * d -
            e * a * d) *
          M),
        (t[12] = x * M),
        (t[13] =
          (c * f * i -
            p * h * i +
            p * n * u -
            e * f * u -
            c * n * m +
            e * h * m) *
          M),
        (t[14] =
          (p * a * i -
            s * f * i -
            p * n * o +
            e * f * o +
            s * n * m -
            e * a * m) *
          M),
        (t[15] =
          (s * h * i -
            c * a * i +
            c * n * o -
            e * h * o -
            s * n * u +
            e * a * u) *
          M),
        this
      );
    }
    scale(t) {
      const e = this.elements,
        n = t.x,
        i = t.y,
        r = t.z;
      return (
        (e[0] *= n),
        (e[4] *= i),
        (e[8] *= r),
        (e[1] *= n),
        (e[5] *= i),
        (e[9] *= r),
        (e[2] *= n),
        (e[6] *= i),
        (e[10] *= r),
        (e[3] *= n),
        (e[7] *= i),
        (e[11] *= r),
        this
      );
    }
    getMaxScaleOnAxis() {
      const t = this.elements,
        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
        n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
        i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
      return Math.sqrt(Math.max(e, n, i));
    }
    makeTranslation(t, e, n) {
      return (
        t.isVector3
          ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1)
          : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
        this
      );
    }
    makeRotationX(t) {
      const e = Math.cos(t),
        n = Math.sin(t);
      return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(t) {
      const e = Math.cos(t),
        n = Math.sin(t);
      return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(t) {
      const e = Math.cos(t),
        n = Math.sin(t);
      return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(t, e) {
      const n = Math.cos(e),
        i = Math.sin(e),
        r = 1 - n,
        s = t.x,
        a = t.y,
        o = t.z,
        l = r * s,
        c = r * a;
      return (
        this.set(
          l * s + n,
          l * a - i * o,
          l * o + i * a,
          0,
          l * a + i * o,
          c * a + n,
          c * o - i * s,
          0,
          l * o - i * a,
          c * o + i * s,
          r * o * o + n,
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    makeScale(t, e, n) {
      return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
    }
    makeShear(t, e, n, i, r, s) {
      return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this;
    }
    compose(t, e, n) {
      const i = this.elements,
        r = e._x,
        s = e._y,
        a = e._z,
        o = e._w,
        l = r + r,
        c = s + s,
        h = a + a,
        u = r * l,
        d = r * c,
        p = r * h,
        f = s * c,
        m = s * h,
        g = a * h,
        _ = o * l,
        v = o * c,
        y = o * h,
        x = n.x,
        T = n.y,
        M = n.z;
      return (
        (i[0] = (1 - (f + g)) * x),
        (i[1] = (d + y) * x),
        (i[2] = (p - v) * x),
        (i[3] = 0),
        (i[4] = (d - y) * T),
        (i[5] = (1 - (u + g)) * T),
        (i[6] = (m + _) * T),
        (i[7] = 0),
        (i[8] = (p + v) * M),
        (i[9] = (m - _) * M),
        (i[10] = (1 - (u + f)) * M),
        (i[11] = 0),
        (i[12] = t.x),
        (i[13] = t.y),
        (i[14] = t.z),
        (i[15] = 1),
        this
      );
    }
    decompose(t, e, n) {
      const i = this.elements;
      let r = Ee.set(i[0], i[1], i[2]).length();
      const s = Ee.set(i[4], i[5], i[6]).length(),
        a = Ee.set(i[8], i[9], i[10]).length();
      this.determinant() < 0 && (r = -r),
        (t.x = i[12]),
        (t.y = i[13]),
        (t.z = i[14]),
        we.copy(this);
      const o = 1 / r,
        l = 1 / s,
        c = 1 / a;
      return (
        (we.elements[0] *= o),
        (we.elements[1] *= o),
        (we.elements[2] *= o),
        (we.elements[4] *= l),
        (we.elements[5] *= l),
        (we.elements[6] *= l),
        (we.elements[8] *= c),
        (we.elements[9] *= c),
        (we.elements[10] *= c),
        e.setFromRotationMatrix(we),
        (n.x = r),
        (n.y = s),
        (n.z = a),
        this
      );
    }
    makePerspective(t, e, n, i, r, s, a = 2e3) {
      const o = this.elements,
        l = (2 * r) / (e - t),
        c = (2 * r) / (n - i),
        h = (e + t) / (e - t),
        u = (n + i) / (n - i);
      let d, p;
      if (a === st) (d = -(s + r) / (s - r)), (p = (-2 * s * r) / (s - r));
      else {
        if (a !== at)
          throw new Error(
            "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a
          );
        (d = -s / (s - r)), (p = (-s * r) / (s - r));
      }
      return (
        (o[0] = l),
        (o[4] = 0),
        (o[8] = h),
        (o[12] = 0),
        (o[1] = 0),
        (o[5] = c),
        (o[9] = u),
        (o[13] = 0),
        (o[2] = 0),
        (o[6] = 0),
        (o[10] = d),
        (o[14] = p),
        (o[3] = 0),
        (o[7] = 0),
        (o[11] = -1),
        (o[15] = 0),
        this
      );
    }
    makeOrthographic(t, e, n, i, r, s, a = 2e3) {
      const o = this.elements,
        l = 1 / (e - t),
        c = 1 / (n - i),
        h = 1 / (s - r),
        u = (e + t) * l,
        d = (n + i) * c;
      let p, f;
      if (a === st) (p = (s + r) * h), (f = -2 * h);
      else {
        if (a !== at)
          throw new Error(
            "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a
          );
        (p = r * h), (f = -1 * h);
      }
      return (
        (o[0] = 2 * l),
        (o[4] = 0),
        (o[8] = 0),
        (o[12] = -u),
        (o[1] = 0),
        (o[5] = 2 * c),
        (o[9] = 0),
        (o[13] = -d),
        (o[2] = 0),
        (o[6] = 0),
        (o[10] = f),
        (o[14] = -p),
        (o[3] = 0),
        (o[7] = 0),
        (o[11] = 0),
        (o[15] = 1),
        this
      );
    }
    equals(t) {
      const e = this.elements,
        n = t.elements;
      for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;
      return !0;
    }
    fromArray(t, e = 0) {
      for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
      return this;
    }
    toArray(t = [], e = 0) {
      const n = this.elements;
      return (
        (t[e] = n[0]),
        (t[e + 1] = n[1]),
        (t[e + 2] = n[2]),
        (t[e + 3] = n[3]),
        (t[e + 4] = n[4]),
        (t[e + 5] = n[5]),
        (t[e + 6] = n[6]),
        (t[e + 7] = n[7]),
        (t[e + 8] = n[8]),
        (t[e + 9] = n[9]),
        (t[e + 10] = n[10]),
        (t[e + 11] = n[11]),
        (t[e + 12] = n[12]),
        (t[e + 13] = n[13]),
        (t[e + 14] = n[14]),
        (t[e + 15] = n[15]),
        t
      );
    }
  }
  const Ee = new Yt(),
    we = new be(),
    Ae = new Yt(0, 0, 0),
    Re = new Yt(1, 1, 1),
    Ce = new Yt(),
    Pe = new Yt(),
    Le = new Yt(),
    De = new be(),
    Ie = new qt();
  class Ue {
    constructor(t = 0, e = 0, n = 0, i = Ue.DEFAULT_ORDER) {
      (this.isEuler = !0),
        (this._x = t),
        (this._y = e),
        (this._z = n),
        (this._order = i);
    }
    get x() {
      return this._x;
    }
    set x(t) {
      (this._x = t), this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t) {
      (this._y = t), this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t) {
      (this._z = t), this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(t) {
      (this._order = t), this._onChangeCallback();
    }
    set(t, e, n, i = this._order) {
      return (
        (this._x = t),
        (this._y = e),
        (this._z = n),
        (this._order = i),
        this._onChangeCallback(),
        this
      );
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(t) {
      return (
        (this._x = t._x),
        (this._y = t._y),
        (this._z = t._z),
        (this._order = t._order),
        this._onChangeCallback(),
        this
      );
    }
    setFromRotationMatrix(t, e = this._order, n = !0) {
      const i = t.elements,
        r = i[0],
        s = i[4],
        a = i[8],
        o = i[1],
        l = i[5],
        c = i[9],
        h = i[2],
        u = i[6],
        d = i[10];
      switch (e) {
        case "XYZ":
          (this._y = Math.asin(dt(a, -1, 1))),
            Math.abs(a) < 0.9999999
              ? ((this._x = Math.atan2(-c, d)), (this._z = Math.atan2(-s, r)))
              : ((this._x = Math.atan2(u, l)), (this._z = 0));
          break;
        case "YXZ":
          (this._x = Math.asin(-dt(c, -1, 1))),
            Math.abs(c) < 0.9999999
              ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, l)))
              : ((this._y = Math.atan2(-h, r)), (this._z = 0));
          break;
        case "ZXY":
          (this._x = Math.asin(dt(u, -1, 1))),
            Math.abs(u) < 0.9999999
              ? ((this._y = Math.atan2(-h, d)), (this._z = Math.atan2(-s, l)))
              : ((this._y = 0), (this._z = Math.atan2(o, r)));
          break;
        case "ZYX":
          (this._y = Math.asin(-dt(h, -1, 1))),
            Math.abs(h) < 0.9999999
              ? ((this._x = Math.atan2(u, d)), (this._z = Math.atan2(o, r)))
              : ((this._x = 0), (this._z = Math.atan2(-s, l)));
          break;
        case "YZX":
          (this._z = Math.asin(dt(o, -1, 1))),
            Math.abs(o) < 0.9999999
              ? ((this._x = Math.atan2(-c, l)), (this._y = Math.atan2(-h, r)))
              : ((this._x = 0), (this._y = Math.atan2(a, d)));
          break;
        case "XZY":
          (this._z = Math.asin(-dt(s, -1, 1))),
            Math.abs(s) < 0.9999999
              ? ((this._x = Math.atan2(u, l)), (this._y = Math.atan2(a, r)))
              : ((this._x = Math.atan2(-c, d)), (this._y = 0));
          break;
        default:
          console.warn(
            "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
              e
          );
      }
      return (this._order = e), !0 === n && this._onChangeCallback(), this;
    }
    setFromQuaternion(t, e, n) {
      return (
        De.makeRotationFromQuaternion(t), this.setFromRotationMatrix(De, e, n)
      );
    }
    setFromVector3(t, e = this._order) {
      return this.set(t.x, t.y, t.z, e);
    }
    reorder(t) {
      return Ie.setFromEuler(this), this.setFromQuaternion(Ie, t);
    }
    equals(t) {
      return (
        t._x === this._x &&
        t._y === this._y &&
        t._z === this._z &&
        t._order === this._order
      );
    }
    fromArray(t) {
      return (
        (this._x = t[0]),
        (this._y = t[1]),
        (this._z = t[2]),
        void 0 !== t[3] && (this._order = t[3]),
        this._onChangeCallback(),
        this
      );
    }
    toArray(t = [], e = 0) {
      return (
        (t[e] = this._x),
        (t[e + 1] = this._y),
        (t[e + 2] = this._z),
        (t[e + 3] = this._order),
        t
      );
    }
    _onChange(t) {
      return (this._onChangeCallback = t), this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._order;
    }
  }
  Ue.DEFAULT_ORDER = "XYZ";
  class Ne {
    constructor() {
      this.mask = 1;
    }
    set(t) {
      this.mask = ((1 << t) | 0) >>> 0;
    }
    enable(t) {
      this.mask |= (1 << t) | 0;
    }
    enableAll() {
      this.mask = -1;
    }
    toggle(t) {
      this.mask ^= (1 << t) | 0;
    }
    disable(t) {
      this.mask &= ~((1 << t) | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(t) {
      return 0 != (this.mask & t.mask);
    }
    isEnabled(t) {
      return 0 != (this.mask & ((1 << t) | 0));
    }
  }
  let Oe = 0;
  const Fe = new Yt(),
    ke = new qt(),
    ze = new be(),
    Be = new Yt(),
    He = new Yt(),
    Ge = new Yt(),
    Ve = new qt(),
    We = new Yt(1, 0, 0),
    Xe = new Yt(0, 1, 0),
    je = new Yt(0, 0, 1),
    qe = { type: "added" },
    Ye = { type: "removed" };
  class Ke extends ot {
    constructor() {
      super(),
        (this.isObject3D = !0),
        Object.defineProperty(this, "id", { value: Oe++ }),
        (this.uuid = ut()),
        (this.name = ""),
        (this.type = "Object3D"),
        (this.parent = null),
        (this.children = []),
        (this.up = Ke.DEFAULT_UP.clone());
      const t = new Yt(),
        e = new Ue(),
        n = new qt(),
        i = new Yt(1, 1, 1);
      e._onChange(function () {
        n.setFromEuler(e, !1);
      }),
        n._onChange(function () {
          e.setFromQuaternion(n, void 0, !1);
        }),
        Object.defineProperties(this, {
          position: { configurable: !0, enumerable: !0, value: t },
          rotation: { configurable: !0, enumerable: !0, value: e },
          quaternion: { configurable: !0, enumerable: !0, value: n },
          scale: { configurable: !0, enumerable: !0, value: i },
          modelViewMatrix: { value: new be() },
          normalMatrix: { value: new Tt() },
        }),
        (this.matrix = new be()),
        (this.matrixWorld = new be()),
        (this.matrixAutoUpdate = Ke.DEFAULT_MATRIX_AUTO_UPDATE),
        (this.matrixWorldAutoUpdate = Ke.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
        (this.matrixWorldNeedsUpdate = !1),
        (this.layers = new Ne()),
        (this.visible = !0),
        (this.castShadow = !1),
        (this.receiveShadow = !1),
        (this.frustumCulled = !0),
        (this.renderOrder = 0),
        (this.animations = []),
        (this.userData = {});
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(t) {
      this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(t),
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(t) {
      return this.quaternion.premultiply(t), this;
    }
    setRotationFromAxisAngle(t, e) {
      this.quaternion.setFromAxisAngle(t, e);
    }
    setRotationFromEuler(t) {
      this.quaternion.setFromEuler(t, !0);
    }
    setRotationFromMatrix(t) {
      this.quaternion.setFromRotationMatrix(t);
    }
    setRotationFromQuaternion(t) {
      this.quaternion.copy(t);
    }
    rotateOnAxis(t, e) {
      return ke.setFromAxisAngle(t, e), this.quaternion.multiply(ke), this;
    }
    rotateOnWorldAxis(t, e) {
      return ke.setFromAxisAngle(t, e), this.quaternion.premultiply(ke), this;
    }
    rotateX(t) {
      return this.rotateOnAxis(We, t);
    }
    rotateY(t) {
      return this.rotateOnAxis(Xe, t);
    }
    rotateZ(t) {
      return this.rotateOnAxis(je, t);
    }
    translateOnAxis(t, e) {
      return (
        Fe.copy(t).applyQuaternion(this.quaternion),
        this.position.add(Fe.multiplyScalar(e)),
        this
      );
    }
    translateX(t) {
      return this.translateOnAxis(We, t);
    }
    translateY(t) {
      return this.translateOnAxis(Xe, t);
    }
    translateZ(t) {
      return this.translateOnAxis(je, t);
    }
    localToWorld(t) {
      return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        t.applyMatrix4(ze.copy(this.matrixWorld).invert())
      );
    }
    lookAt(t, e, n) {
      t.isVector3 ? Be.copy(t) : Be.set(t, e, n);
      const i = this.parent;
      this.updateWorldMatrix(!0, !1),
        He.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight
          ? ze.lookAt(He, Be, this.up)
          : ze.lookAt(Be, He, this.up),
        this.quaternion.setFromRotationMatrix(ze),
        i &&
          (ze.extractRotation(i.matrixWorld),
          ke.setFromRotationMatrix(ze),
          this.quaternion.premultiply(ke.invert()));
    }
    add(t) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
        return this;
      }
      return t === this
        ? (console.error(
            "THREE.Object3D.add: object can't be added as a child of itself.",
            t
          ),
          this)
        : (t && t.isObject3D
            ? (null !== t.parent && t.parent.remove(t),
              (t.parent = this),
              this.children.push(t),
              t.dispatchEvent(qe))
            : console.error(
                "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                t
              ),
          this);
    }
    remove(t) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
        return this;
      }
      const e = this.children.indexOf(t);
      return (
        -1 !== e &&
          ((t.parent = null), this.children.splice(e, 1), t.dispatchEvent(Ye)),
        this
      );
    }
    removeFromParent() {
      const t = this.parent;
      return null !== t && t.remove(this), this;
    }
    clear() {
      return this.remove(...this.children);
    }
    attach(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        ze.copy(this.matrixWorld).invert(),
        null !== t.parent &&
          (t.parent.updateWorldMatrix(!0, !1),
          ze.multiply(t.parent.matrixWorld)),
        t.applyMatrix4(ze),
        this.add(t),
        t.updateWorldMatrix(!1, !0),
        this
      );
    }
    getObjectById(t) {
      return this.getObjectByProperty("id", t);
    }
    getObjectByName(t) {
      return this.getObjectByProperty("name", t);
    }
    getObjectByProperty(t, e) {
      if (this[t] === e) return this;
      for (let n = 0, i = this.children.length; n < i; n++) {
        const i = this.children[n].getObjectByProperty(t, e);
        if (void 0 !== i) return i;
      }
    }
    getObjectsByProperty(t, e, n = []) {
      this[t] === e && n.push(this);
      const i = this.children;
      for (let r = 0, s = i.length; r < s; r++)
        i[r].getObjectsByProperty(t, e, n);
      return n;
    }
    getWorldPosition(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        t.setFromMatrixPosition(this.matrixWorld)
      );
    }
    getWorldQuaternion(t) {
      return (
        this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(He, t, Ge), t
      );
    }
    getWorldScale(t) {
      return (
        this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(He, Ve, t), t
      );
    }
    getWorldDirection(t) {
      this.updateWorldMatrix(!0, !1);
      const e = this.matrixWorld.elements;
      return t.set(e[8], e[9], e[10]).normalize();
    }
    raycast() {}
    traverse(t) {
      t(this);
      const e = this.children;
      for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
    }
    traverseVisible(t) {
      if (!1 === this.visible) return;
      t(this);
      const e = this.children;
      for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
    }
    traverseAncestors(t) {
      const e = this.parent;
      null !== e && (t(e), e.traverseAncestors(t));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale),
        (this.matrixWorldNeedsUpdate = !0);
    }
    updateMatrixWorld(t) {
      this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || t) &&
          (null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              ),
          (this.matrixWorldNeedsUpdate = !1),
          (t = !0));
      const e = this.children;
      for (let n = 0, i = e.length; n < i; n++) {
        const i = e[n];
        (!0 !== i.matrixWorldAutoUpdate && !0 !== t) || i.updateMatrixWorld(t);
      }
    }
    updateWorldMatrix(t, e) {
      const n = this.parent;
      if (
        (!0 === t &&
          null !== n &&
          !0 === n.matrixWorldAutoUpdate &&
          n.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        null === this.parent
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        !0 === e)
      ) {
        const t = this.children;
        for (let e = 0, n = t.length; e < n; e++) {
          const n = t[e];
          !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0);
        }
      }
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t,
        n = {};
      e &&
        ((t = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
          nodes: {},
        }),
        (n.metadata = {
          version: 4.6,
          type: "Object",
          generator: "Object3D.toJSON",
        }));
      const i = {};
      function r(e, n) {
        return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
      }
      if (
        ((i.uuid = this.uuid),
        (i.type = this.type),
        "" !== this.name && (i.name = this.name),
        !0 === this.castShadow && (i.castShadow = !0),
        !0 === this.receiveShadow && (i.receiveShadow = !0),
        !1 === this.visible && (i.visible = !1),
        !1 === this.frustumCulled && (i.frustumCulled = !1),
        0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        (i.layers = this.layers.mask),
        (i.matrix = this.matrix.toArray()),
        (i.up = this.up.toArray()),
        !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
        this.isInstancedMesh &&
          ((i.type = "InstancedMesh"),
          (i.count = this.count),
          (i.instanceMatrix = this.instanceMatrix.toJSON()),
          null !== this.instanceColor &&
            (i.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh &&
          ((i.type = "BatchedMesh"),
          (i.perObjectFrustumCulled = this.perObjectFrustumCulled),
          (i.sortObjects = this.sortObjects),
          (i.drawRanges = this._drawRanges),
          (i.reservedRanges = this._reservedRanges),
          (i.visibility = this._visibility),
          (i.active = this._active),
          (i.bounds = this._bounds.map((t) => ({
            boxInitialized: t.boxInitialized,
            boxMin: t.box.min.toArray(),
            boxMax: t.box.max.toArray(),
            sphereInitialized: t.sphereInitialized,
            sphereRadius: t.sphere.radius,
            sphereCenter: t.sphere.center.toArray(),
          }))),
          (i.maxGeometryCount = this._maxGeometryCount),
          (i.maxVertexCount = this._maxVertexCount),
          (i.maxIndexCount = this._maxIndexCount),
          (i.geometryInitialized = this._geometryInitialized),
          (i.geometryCount = this._geometryCount),
          (i.matricesTexture = this._matricesTexture.toJSON(t)),
          null !== this.boundingSphere &&
            (i.boundingSphere = {
              center: i.boundingSphere.center.toArray(),
              radius: i.boundingSphere.radius,
            }),
          null !== this.boundingBox &&
            (i.boundingBox = {
              min: i.boundingBox.min.toArray(),
              max: i.boundingBox.max.toArray(),
            })),
        this.isScene)
      )
        this.background &&
          (this.background.isColor
            ? (i.background = this.background.toJSON())
            : this.background.isTexture &&
              (i.background = this.background.toJSON(t).uuid)),
          this.environment &&
            this.environment.isTexture &&
            !0 !== this.environment.isRenderTargetTexture &&
            (i.environment = this.environment.toJSON(t).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        i.geometry = r(t.geometries, this.geometry);
        const e = this.geometry.parameters;
        if (void 0 !== e && void 0 !== e.shapes) {
          const n = e.shapes;
          if (Array.isArray(n))
            for (let e = 0, i = n.length; e < i; e++) {
              const i = n[e];
              r(t.shapes, i);
            }
          else r(t.shapes, n);
        }
      }
      if (
        (this.isSkinnedMesh &&
          ((i.bindMode = this.bindMode),
          (i.bindMatrix = this.bindMatrix.toArray()),
          void 0 !== this.skeleton &&
            (r(t.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
        void 0 !== this.material)
      )
        if (Array.isArray(this.material)) {
          const e = [];
          for (let n = 0, i = this.material.length; n < i; n++)
            e.push(r(t.materials, this.material[n]));
          i.material = e;
        } else i.material = r(t.materials, this.material);
      if (this.children.length > 0) {
        i.children = [];
        for (let e = 0; e < this.children.length; e++)
          i.children.push(this.children[e].toJSON(t).object);
      }
      if (this.animations.length > 0) {
        i.animations = [];
        for (let e = 0; e < this.animations.length; e++) {
          const n = this.animations[e];
          i.animations.push(r(t.animations, n));
        }
      }
      if (e) {
        const e = s(t.geometries),
          i = s(t.materials),
          r = s(t.textures),
          a = s(t.images),
          o = s(t.shapes),
          l = s(t.skeletons),
          c = s(t.animations),
          h = s(t.nodes);
        e.length > 0 && (n.geometries = e),
          i.length > 0 && (n.materials = i),
          r.length > 0 && (n.textures = r),
          a.length > 0 && (n.images = a),
          o.length > 0 && (n.shapes = o),
          l.length > 0 && (n.skeletons = l),
          c.length > 0 && (n.animations = c),
          h.length > 0 && (n.nodes = h);
      }
      return (n.object = i), n;
      function s(t) {
        const e = [];
        for (const n in t) {
          const i = t[n];
          delete i.metadata, e.push(i);
        }
        return e;
      }
    }
    clone(t) {
      return new this.constructor().copy(this, t);
    }
    copy(t, e = !0) {
      if (
        ((this.name = t.name),
        this.up.copy(t.up),
        this.position.copy(t.position),
        (this.rotation.order = t.rotation.order),
        this.quaternion.copy(t.quaternion),
        this.scale.copy(t.scale),
        this.matrix.copy(t.matrix),
        this.matrixWorld.copy(t.matrixWorld),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        (this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate),
        (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
        (this.layers.mask = t.layers.mask),
        (this.visible = t.visible),
        (this.castShadow = t.castShadow),
        (this.receiveShadow = t.receiveShadow),
        (this.frustumCulled = t.frustumCulled),
        (this.renderOrder = t.renderOrder),
        (this.animations = t.animations.slice()),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        !0 === e)
      )
        for (let e = 0; e < t.children.length; e++) {
          const n = t.children[e];
          this.add(n.clone());
        }
      return this;
    }
  }
  (Ke.DEFAULT_UP = new Yt(0, 1, 0)),
    (Ke.DEFAULT_MATRIX_AUTO_UPDATE = !0),
    (Ke.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0);
  const Ze = new Yt(),
    Je = new Yt(),
    Qe = new Yt(),
    $e = new Yt(),
    tn = new Yt(),
    en = new Yt(),
    nn = new Yt(),
    rn = new Yt(),
    sn = new Yt(),
    an = new Yt();
  let on = !1;
  class ln {
    constructor(t = new Yt(), e = new Yt(), n = new Yt()) {
      (this.a = t), (this.b = e), (this.c = n);
    }
    static getNormal(t, e, n, i) {
      i.subVectors(n, e), Ze.subVectors(t, e), i.cross(Ze);
      const r = i.lengthSq();
      return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
    }
    static getBarycoord(t, e, n, i, r) {
      Ze.subVectors(i, e), Je.subVectors(n, e), Qe.subVectors(t, e);
      const s = Ze.dot(Ze),
        a = Ze.dot(Je),
        o = Ze.dot(Qe),
        l = Je.dot(Je),
        c = Je.dot(Qe),
        h = s * l - a * a;
      if (0 === h) return r.set(0, 0, 0), null;
      const u = 1 / h,
        d = (l * o - a * c) * u,
        p = (s * c - a * o) * u;
      return r.set(1 - d - p, p, d);
    }
    static containsPoint(t, e, n, i) {
      return (
        null !== this.getBarycoord(t, e, n, i, $e) &&
        $e.x >= 0 &&
        $e.y >= 0 &&
        $e.x + $e.y <= 1
      );
    }
    static getUV(t, e, n, i, r, s, a, o) {
      return (
        !1 === on &&
          (console.warn(
            "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
          ),
          (on = !0)),
        this.getInterpolation(t, e, n, i, r, s, a, o)
      );
    }
    static getInterpolation(t, e, n, i, r, s, a, o) {
      return null === this.getBarycoord(t, e, n, i, $e)
        ? ((o.x = 0),
          (o.y = 0),
          "z" in o && (o.z = 0),
          "w" in o && (o.w = 0),
          null)
        : (o.setScalar(0),
          o.addScaledVector(r, $e.x),
          o.addScaledVector(s, $e.y),
          o.addScaledVector(a, $e.z),
          o);
    }
    static isFrontFacing(t, e, n, i) {
      return Ze.subVectors(n, e), Je.subVectors(t, e), Ze.cross(Je).dot(i) < 0;
    }
    set(t, e, n) {
      return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
    }
    setFromPointsAndIndices(t, e, n, i) {
      return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
    }
    setFromAttributeAndIndices(t, e, n, i) {
      return (
        this.a.fromBufferAttribute(t, e),
        this.b.fromBufferAttribute(t, n),
        this.c.fromBufferAttribute(t, i),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
    }
    getArea() {
      return (
        Ze.subVectors(this.c, this.b),
        Je.subVectors(this.a, this.b),
        0.5 * Ze.cross(Je).length()
      );
    }
    getMidpoint(t) {
      return t
        .addVectors(this.a, this.b)
        .add(this.c)
        .multiplyScalar(1 / 3);
    }
    getNormal(t) {
      return ln.getNormal(this.a, this.b, this.c, t);
    }
    getPlane(t) {
      return t.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(t, e) {
      return ln.getBarycoord(t, this.a, this.b, this.c, e);
    }
    getUV(t, e, n, i, r) {
      return (
        !1 === on &&
          (console.warn(
            "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
          ),
          (on = !0)),
        ln.getInterpolation(t, this.a, this.b, this.c, e, n, i, r)
      );
    }
    getInterpolation(t, e, n, i, r) {
      return ln.getInterpolation(t, this.a, this.b, this.c, e, n, i, r);
    }
    containsPoint(t) {
      return ln.containsPoint(t, this.a, this.b, this.c);
    }
    isFrontFacing(t) {
      return ln.isFrontFacing(this.a, this.b, this.c, t);
    }
    intersectsBox(t) {
      return t.intersectsTriangle(this);
    }
    closestPointToPoint(t, e) {
      const n = this.a,
        i = this.b,
        r = this.c;
      let s, a;
      tn.subVectors(i, n), en.subVectors(r, n), rn.subVectors(t, n);
      const o = tn.dot(rn),
        l = en.dot(rn);
      if (o <= 0 && l <= 0) return e.copy(n);
      sn.subVectors(t, i);
      const c = tn.dot(sn),
        h = en.dot(sn);
      if (c >= 0 && h <= c) return e.copy(i);
      const u = o * h - c * l;
      if (u <= 0 && o >= 0 && c <= 0)
        return (s = o / (o - c)), e.copy(n).addScaledVector(tn, s);
      an.subVectors(t, r);
      const d = tn.dot(an),
        p = en.dot(an);
      if (p >= 0 && d <= p) return e.copy(r);
      const f = d * l - o * p;
      if (f <= 0 && l >= 0 && p <= 0)
        return (a = l / (l - p)), e.copy(n).addScaledVector(en, a);
      const m = c * p - d * h;
      if (m <= 0 && h - c >= 0 && d - p >= 0)
        return (
          nn.subVectors(r, i),
          (a = (h - c) / (h - c + (d - p))),
          e.copy(i).addScaledVector(nn, a)
        );
      const g = 1 / (m + f + u);
      return (
        (s = f * g),
        (a = u * g),
        e.copy(n).addScaledVector(tn, s).addScaledVector(en, a)
      );
    }
    equals(t) {
      return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
    }
  }
  const cn = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074,
    },
    hn = { h: 0, s: 0, l: 0 },
    un = { h: 0, s: 0, l: 0 };
  function dn(t, e, n) {
    return (
      n < 0 && (n += 1),
      n > 1 && (n -= 1),
      n < 1 / 6
        ? t + 6 * (e - t) * n
        : n < 0.5
        ? e
        : n < 2 / 3
        ? t + 6 * (e - t) * (2 / 3 - n)
        : t
    );
  }
  class pn {
    constructor(t, e, n) {
      return (
        (this.isColor = !0),
        (this.r = 1),
        (this.g = 1),
        (this.b = 1),
        this.set(t, e, n)
      );
    }
    set(t, e, n) {
      if (void 0 === e && void 0 === n) {
        const e = t;
        e && e.isColor
          ? this.copy(e)
          : "number" == typeof e
          ? this.setHex(e)
          : "string" == typeof e && this.setStyle(e);
      } else this.setRGB(t, e, n);
      return this;
    }
    setScalar(t) {
      return (this.r = t), (this.g = t), (this.b = t), this;
    }
    setHex(t, e = q) {
      return (
        (t = Math.floor(t)),
        (this.r = ((t >> 16) & 255) / 255),
        (this.g = ((t >> 8) & 255) / 255),
        (this.b = (255 & t) / 255),
        Dt.toWorkingColorSpace(this, e),
        this
      );
    }
    setRGB(t, e, n, i = Dt.workingColorSpace) {
      return (
        (this.r = t),
        (this.g = e),
        (this.b = n),
        Dt.toWorkingColorSpace(this, i),
        this
      );
    }
    setHSL(t, e, n, i = Dt.workingColorSpace) {
      if (((t = pt(t, 1)), (e = dt(e, 0, 1)), (n = dt(n, 0, 1)), 0 === e))
        this.r = this.g = this.b = n;
      else {
        const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
          r = 2 * n - i;
        (this.r = dn(r, i, t + 1 / 3)),
          (this.g = dn(r, i, t)),
          (this.b = dn(r, i, t - 1 / 3));
      }
      return Dt.toWorkingColorSpace(this, i), this;
    }
    setStyle(t, e = q) {
      function n(e) {
        void 0 !== e &&
          parseFloat(e) < 1 &&
          console.warn(
            "THREE.Color: Alpha component of " + t + " will be ignored."
          );
      }
      let i;
      if ((i = /^(\w+)\(([^\)]*)\)/.exec(t))) {
        let r;
        const s = i[1],
          a = i[2];
        switch (s) {
          case "rgb":
          case "rgba":
            if (
              (r =
                /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  a
                ))
            )
              return (
                n(r[4]),
                this.setRGB(
                  Math.min(255, parseInt(r[1], 10)) / 255,
                  Math.min(255, parseInt(r[2], 10)) / 255,
                  Math.min(255, parseInt(r[3], 10)) / 255,
                  e
                )
              );
            if (
              (r =
                /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  a
                ))
            )
              return (
                n(r[4]),
                this.setRGB(
                  Math.min(100, parseInt(r[1], 10)) / 100,
                  Math.min(100, parseInt(r[2], 10)) / 100,
                  Math.min(100, parseInt(r[3], 10)) / 100,
                  e
                )
              );
            break;
          case "hsl":
          case "hsla":
            if (
              (r =
                /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  a
                ))
            )
              return (
                n(r[4]),
                this.setHSL(
                  parseFloat(r[1]) / 360,
                  parseFloat(r[2]) / 100,
                  parseFloat(r[3]) / 100,
                  e
                )
              );
            break;
          default:
            console.warn("THREE.Color: Unknown color model " + t);
        }
      } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(t))) {
        const n = i[1],
          r = n.length;
        if (3 === r)
          return this.setRGB(
            parseInt(n.charAt(0), 16) / 15,
            parseInt(n.charAt(1), 16) / 15,
            parseInt(n.charAt(2), 16) / 15,
            e
          );
        if (6 === r) return this.setHex(parseInt(n, 16), e);
        console.warn("THREE.Color: Invalid hex color " + t);
      } else if (t && t.length > 0) return this.setColorName(t, e);
      return this;
    }
    setColorName(t, e = q) {
      const n = cn[t.toLowerCase()];
      return (
        void 0 !== n
          ? this.setHex(n, e)
          : console.warn("THREE.Color: Unknown color " + t),
        this
      );
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(t) {
      return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
    }
    copySRGBToLinear(t) {
      return (this.r = It(t.r)), (this.g = It(t.g)), (this.b = It(t.b)), this;
    }
    copyLinearToSRGB(t) {
      return (this.r = Ut(t.r)), (this.g = Ut(t.g)), (this.b = Ut(t.b)), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex(t = q) {
      return (
        Dt.fromWorkingColorSpace(fn.copy(this), t),
        65536 * Math.round(dt(255 * fn.r, 0, 255)) +
          256 * Math.round(dt(255 * fn.g, 0, 255)) +
          Math.round(dt(255 * fn.b, 0, 255))
      );
    }
    getHexString(t = q) {
      return ("000000" + this.getHex(t).toString(16)).slice(-6);
    }
    getHSL(t, e = Dt.workingColorSpace) {
      Dt.fromWorkingColorSpace(fn.copy(this), e);
      const n = fn.r,
        i = fn.g,
        r = fn.b,
        s = Math.max(n, i, r),
        a = Math.min(n, i, r);
      let o, l;
      const c = (a + s) / 2;
      if (a === s) (o = 0), (l = 0);
      else {
        const t = s - a;
        switch (((l = c <= 0.5 ? t / (s + a) : t / (2 - s - a)), s)) {
          case n:
            o = (i - r) / t + (i < r ? 6 : 0);
            break;
          case i:
            o = (r - n) / t + 2;
            break;
          case r:
            o = (n - i) / t + 4;
        }
        o /= 6;
      }
      return (t.h = o), (t.s = l), (t.l = c), t;
    }
    getRGB(t, e = Dt.workingColorSpace) {
      return (
        Dt.fromWorkingColorSpace(fn.copy(this), e),
        (t.r = fn.r),
        (t.g = fn.g),
        (t.b = fn.b),
        t
      );
    }
    getStyle(t = q) {
      Dt.fromWorkingColorSpace(fn.copy(this), t);
      const e = fn.r,
        n = fn.g,
        i = fn.b;
      return t !== q
        ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
        : `rgb(${Math.round(255 * e)},${Math.round(255 * n)},${Math.round(
            255 * i
          )})`;
    }
    offsetHSL(t, e, n) {
      return this.getHSL(hn), this.setHSL(hn.h + t, hn.s + e, hn.l + n);
    }
    add(t) {
      return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
    }
    addColors(t, e) {
      return (
        (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
      );
    }
    addScalar(t) {
      return (this.r += t), (this.g += t), (this.b += t), this;
    }
    sub(t) {
      return (
        (this.r = Math.max(0, this.r - t.r)),
        (this.g = Math.max(0, this.g - t.g)),
        (this.b = Math.max(0, this.b - t.b)),
        this
      );
    }
    multiply(t) {
      return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
    }
    multiplyScalar(t) {
      return (this.r *= t), (this.g *= t), (this.b *= t), this;
    }
    lerp(t, e) {
      return (
        (this.r += (t.r - this.r) * e),
        (this.g += (t.g - this.g) * e),
        (this.b += (t.b - this.b) * e),
        this
      );
    }
    lerpColors(t, e, n) {
      return (
        (this.r = t.r + (e.r - t.r) * n),
        (this.g = t.g + (e.g - t.g) * n),
        (this.b = t.b + (e.b - t.b) * n),
        this
      );
    }
    lerpHSL(t, e) {
      this.getHSL(hn), t.getHSL(un);
      const n = ft(hn.h, un.h, e),
        i = ft(hn.s, un.s, e),
        r = ft(hn.l, un.l, e);
      return this.setHSL(n, i, r), this;
    }
    setFromVector3(t) {
      return (this.r = t.x), (this.g = t.y), (this.b = t.z), this;
    }
    applyMatrix3(t) {
      const e = this.r,
        n = this.g,
        i = this.b,
        r = t.elements;
      return (
        (this.r = r[0] * e + r[3] * n + r[6] * i),
        (this.g = r[1] * e + r[4] * n + r[7] * i),
        (this.b = r[2] * e + r[5] * n + r[8] * i),
        this
      );
    }
    equals(t) {
      return t.r === this.r && t.g === this.g && t.b === this.b;
    }
    fromArray(t, e = 0) {
      return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this;
    }
    toArray(t = [], e = 0) {
      return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
    }
    fromBufferAttribute(t, e) {
      return (
        (this.r = t.getX(e)), (this.g = t.getY(e)), (this.b = t.getZ(e)), this
      );
    }
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r, yield this.g, yield this.b;
    }
  }
  const fn = new pn();
  pn.NAMES = cn;
  let mn = 0;
  class gn extends ot {
    constructor() {
      super(),
        (this.isMaterial = !0),
        Object.defineProperty(this, "id", { value: mn++ }),
        (this.uuid = ut()),
        (this.name = ""),
        (this.type = "Material"),
        (this.blending = 1),
        (this.side = 0),
        (this.vertexColors = !1),
        (this.opacity = 1),
        (this.transparent = !1),
        (this.alphaHash = !1),
        (this.blendSrc = 204),
        (this.blendDst = 205),
        (this.blendEquation = s),
        (this.blendSrcAlpha = null),
        (this.blendDstAlpha = null),
        (this.blendEquationAlpha = null),
        (this.blendColor = new pn(0, 0, 0)),
        (this.blendAlpha = 0),
        (this.depthFunc = 3),
        (this.depthTest = !0),
        (this.depthWrite = !0),
        (this.stencilWriteMask = 255),
        (this.stencilFunc = 519),
        (this.stencilRef = 0),
        (this.stencilFuncMask = 255),
        (this.stencilFail = et),
        (this.stencilZFail = et),
        (this.stencilZPass = et),
        (this.stencilWrite = !1),
        (this.clippingPlanes = null),
        (this.clipIntersection = !1),
        (this.clipShadows = !1),
        (this.shadowSide = null),
        (this.colorWrite = !0),
        (this.precision = null),
        (this.polygonOffset = !1),
        (this.polygonOffsetFactor = 0),
        (this.polygonOffsetUnits = 0),
        (this.dithering = !1),
        (this.alphaToCoverage = !1),
        (this.premultipliedAlpha = !1),
        (this.forceSinglePass = !1),
        (this.visible = !0),
        (this.toneMapped = !0),
        (this.userData = {}),
        (this.version = 0),
        (this._alphaTest = 0);
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(t) {
      this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(t) {
      if (void 0 !== t)
        for (const e in t) {
          const n = t[e];
          if (void 0 === n) {
            console.warn(
              `THREE.Material: parameter '${e}' has value of undefined.`
            );
            continue;
          }
          const i = this[e];
          void 0 !== i
            ? i && i.isColor
              ? i.set(n)
              : i && i.isVector3 && n && n.isVector3
              ? i.copy(n)
              : (this[e] = n)
            : console.warn(
                `THREE.Material: '${e}' is not a property of THREE.${this.type}.`
              );
        }
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t;
      e && (t = { textures: {}, images: {} });
      const n = {
        metadata: {
          version: 4.6,
          type: "Material",
          generator: "Material.toJSON",
        },
      };
      function i(t) {
        const e = [];
        for (const n in t) {
          const i = t[n];
          delete i.metadata, e.push(i);
        }
        return e;
      }
      if (
        ((n.uuid = this.uuid),
        (n.type = this.type),
        "" !== this.name && (n.name = this.name),
        this.color && this.color.isColor && (n.color = this.color.getHex()),
        void 0 !== this.roughness && (n.roughness = this.roughness),
        void 0 !== this.metalness && (n.metalness = this.metalness),
        void 0 !== this.sheen && (n.sheen = this.sheen),
        this.sheenColor &&
          this.sheenColor.isColor &&
          (n.sheenColor = this.sheenColor.getHex()),
        void 0 !== this.sheenRoughness &&
          (n.sheenRoughness = this.sheenRoughness),
        this.emissive &&
          this.emissive.isColor &&
          (n.emissive = this.emissive.getHex()),
        this.emissiveIntensity &&
          1 !== this.emissiveIntensity &&
          (n.emissiveIntensity = this.emissiveIntensity),
        this.specular &&
          this.specular.isColor &&
          (n.specular = this.specular.getHex()),
        void 0 !== this.specularIntensity &&
          (n.specularIntensity = this.specularIntensity),
        this.specularColor &&
          this.specularColor.isColor &&
          (n.specularColor = this.specularColor.getHex()),
        void 0 !== this.shininess && (n.shininess = this.shininess),
        void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
        void 0 !== this.clearcoatRoughness &&
          (n.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap &&
          this.clearcoatMap.isTexture &&
          (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
        this.clearcoatRoughnessMap &&
          this.clearcoatRoughnessMap.isTexture &&
          (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
        this.clearcoatNormalMap &&
          this.clearcoatNormalMap.isTexture &&
          ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
          (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
        void 0 !== this.iridescence && (n.iridescence = this.iridescence),
        void 0 !== this.iridescenceIOR &&
          (n.iridescenceIOR = this.iridescenceIOR),
        void 0 !== this.iridescenceThicknessRange &&
          (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap &&
          this.iridescenceMap.isTexture &&
          (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
        this.iridescenceThicknessMap &&
          this.iridescenceThicknessMap.isTexture &&
          (n.iridescenceThicknessMap =
            this.iridescenceThicknessMap.toJSON(t).uuid),
        void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy),
        void 0 !== this.anisotropyRotation &&
          (n.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap &&
          this.anisotropyMap.isTexture &&
          (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid),
        this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
        this.matcap &&
          this.matcap.isTexture &&
          (n.matcap = this.matcap.toJSON(t).uuid),
        this.alphaMap &&
          this.alphaMap.isTexture &&
          (n.alphaMap = this.alphaMap.toJSON(t).uuid),
        this.lightMap &&
          this.lightMap.isTexture &&
          ((n.lightMap = this.lightMap.toJSON(t).uuid),
          (n.lightMapIntensity = this.lightMapIntensity)),
        this.aoMap &&
          this.aoMap.isTexture &&
          ((n.aoMap = this.aoMap.toJSON(t).uuid),
          (n.aoMapIntensity = this.aoMapIntensity)),
        this.bumpMap &&
          this.bumpMap.isTexture &&
          ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
          (n.bumpScale = this.bumpScale)),
        this.normalMap &&
          this.normalMap.isTexture &&
          ((n.normalMap = this.normalMap.toJSON(t).uuid),
          (n.normalMapType = this.normalMapType),
          (n.normalScale = this.normalScale.toArray())),
        this.displacementMap &&
          this.displacementMap.isTexture &&
          ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
          (n.displacementScale = this.displacementScale),
          (n.displacementBias = this.displacementBias)),
        this.roughnessMap &&
          this.roughnessMap.isTexture &&
          (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
        this.metalnessMap &&
          this.metalnessMap.isTexture &&
          (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
        this.emissiveMap &&
          this.emissiveMap.isTexture &&
          (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
        this.specularMap &&
          this.specularMap.isTexture &&
          (n.specularMap = this.specularMap.toJSON(t).uuid),
        this.specularIntensityMap &&
          this.specularIntensityMap.isTexture &&
          (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
        this.specularColorMap &&
          this.specularColorMap.isTexture &&
          (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
        this.envMap &&
          this.envMap.isTexture &&
          ((n.envMap = this.envMap.toJSON(t).uuid),
          void 0 !== this.combine && (n.combine = this.combine)),
        void 0 !== this.envMapIntensity &&
          (n.envMapIntensity = this.envMapIntensity),
        void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
        void 0 !== this.refractionRatio &&
          (n.refractionRatio = this.refractionRatio),
        this.gradientMap &&
          this.gradientMap.isTexture &&
          (n.gradientMap = this.gradientMap.toJSON(t).uuid),
        void 0 !== this.transmission && (n.transmission = this.transmission),
        this.transmissionMap &&
          this.transmissionMap.isTexture &&
          (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
        void 0 !== this.thickness && (n.thickness = this.thickness),
        this.thicknessMap &&
          this.thicknessMap.isTexture &&
          (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
        void 0 !== this.attenuationDistance &&
          this.attenuationDistance !== 1 / 0 &&
          (n.attenuationDistance = this.attenuationDistance),
        void 0 !== this.attenuationColor &&
          (n.attenuationColor = this.attenuationColor.getHex()),
        void 0 !== this.size && (n.size = this.size),
        null !== this.shadowSide && (n.shadowSide = this.shadowSide),
        void 0 !== this.sizeAttenuation &&
          (n.sizeAttenuation = this.sizeAttenuation),
        1 !== this.blending && (n.blending = this.blending),
        0 !== this.side && (n.side = this.side),
        !0 === this.vertexColors && (n.vertexColors = !0),
        this.opacity < 1 && (n.opacity = this.opacity),
        !0 === this.transparent && (n.transparent = !0),
        204 !== this.blendSrc && (n.blendSrc = this.blendSrc),
        205 !== this.blendDst && (n.blendDst = this.blendDst),
        this.blendEquation !== s && (n.blendEquation = this.blendEquation),
        null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha),
        null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha),
        null !== this.blendEquationAlpha &&
          (n.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor &&
          this.blendColor.isColor &&
          (n.blendColor = this.blendColor.getHex()),
        0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha),
        3 !== this.depthFunc && (n.depthFunc = this.depthFunc),
        !1 === this.depthTest && (n.depthTest = this.depthTest),
        !1 === this.depthWrite && (n.depthWrite = this.depthWrite),
        !1 === this.colorWrite && (n.colorWrite = this.colorWrite),
        255 !== this.stencilWriteMask &&
          (n.stencilWriteMask = this.stencilWriteMask),
        519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc),
        0 !== this.stencilRef && (n.stencilRef = this.stencilRef),
        255 !== this.stencilFuncMask &&
          (n.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== et && (n.stencilFail = this.stencilFail),
        this.stencilZFail !== et && (n.stencilZFail = this.stencilZFail),
        this.stencilZPass !== et && (n.stencilZPass = this.stencilZPass),
        !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite),
        void 0 !== this.rotation &&
          0 !== this.rotation &&
          (n.rotation = this.rotation),
        !0 === this.polygonOffset && (n.polygonOffset = !0),
        0 !== this.polygonOffsetFactor &&
          (n.polygonOffsetFactor = this.polygonOffsetFactor),
        0 !== this.polygonOffsetUnits &&
          (n.polygonOffsetUnits = this.polygonOffsetUnits),
        void 0 !== this.linewidth &&
          1 !== this.linewidth &&
          (n.linewidth = this.linewidth),
        void 0 !== this.dashSize && (n.dashSize = this.dashSize),
        void 0 !== this.gapSize && (n.gapSize = this.gapSize),
        void 0 !== this.scale && (n.scale = this.scale),
        !0 === this.dithering && (n.dithering = !0),
        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
        !0 === this.alphaHash && (n.alphaHash = !0),
        !0 === this.alphaToCoverage && (n.alphaToCoverage = !0),
        !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0),
        !0 === this.forceSinglePass && (n.forceSinglePass = !0),
        !0 === this.wireframe && (n.wireframe = !0),
        this.wireframeLinewidth > 1 &&
          (n.wireframeLinewidth = this.wireframeLinewidth),
        "round" !== this.wireframeLinecap &&
          (n.wireframeLinecap = this.wireframeLinecap),
        "round" !== this.wireframeLinejoin &&
          (n.wireframeLinejoin = this.wireframeLinejoin),
        !0 === this.flatShading && (n.flatShading = !0),
        !1 === this.visible && (n.visible = !1),
        !1 === this.toneMapped && (n.toneMapped = !1),
        !1 === this.fog && (n.fog = !1),
        Object.keys(this.userData).length > 0 && (n.userData = this.userData),
        e)
      ) {
        const e = i(t.textures),
          r = i(t.images);
        e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
      }
      return n;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      (this.name = t.name),
        (this.blending = t.blending),
        (this.side = t.side),
        (this.vertexColors = t.vertexColors),
        (this.opacity = t.opacity),
        (this.transparent = t.transparent),
        (this.blendSrc = t.blendSrc),
        (this.blendDst = t.blendDst),
        (this.blendEquation = t.blendEquation),
        (this.blendSrcAlpha = t.blendSrcAlpha),
        (this.blendDstAlpha = t.blendDstAlpha),
        (this.blendEquationAlpha = t.blendEquationAlpha),
        this.blendColor.copy(t.blendColor),
        (this.blendAlpha = t.blendAlpha),
        (this.depthFunc = t.depthFunc),
        (this.depthTest = t.depthTest),
        (this.depthWrite = t.depthWrite),
        (this.stencilWriteMask = t.stencilWriteMask),
        (this.stencilFunc = t.stencilFunc),
        (this.stencilRef = t.stencilRef),
        (this.stencilFuncMask = t.stencilFuncMask),
        (this.stencilFail = t.stencilFail),
        (this.stencilZFail = t.stencilZFail),
        (this.stencilZPass = t.stencilZPass),
        (this.stencilWrite = t.stencilWrite);
      const e = t.clippingPlanes;
      let n = null;
      if (null !== e) {
        const t = e.length;
        n = new Array(t);
        for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
      }
      return (
        (this.clippingPlanes = n),
        (this.clipIntersection = t.clipIntersection),
        (this.clipShadows = t.clipShadows),
        (this.shadowSide = t.shadowSide),
        (this.colorWrite = t.colorWrite),
        (this.precision = t.precision),
        (this.polygonOffset = t.polygonOffset),
        (this.polygonOffsetFactor = t.polygonOffsetFactor),
        (this.polygonOffsetUnits = t.polygonOffsetUnits),
        (this.dithering = t.dithering),
        (this.alphaTest = t.alphaTest),
        (this.alphaHash = t.alphaHash),
        (this.alphaToCoverage = t.alphaToCoverage),
        (this.premultipliedAlpha = t.premultipliedAlpha),
        (this.forceSinglePass = t.forceSinglePass),
        (this.visible = t.visible),
        (this.toneMapped = t.toneMapped),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(t) {
      !0 === t && this.version++;
    }
  }
  class _n extends gn {
    constructor(t) {
      super(),
        (this.isMeshBasicMaterial = !0),
        (this.type = "MeshBasicMaterial"),
        (this.color = new pn(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = a),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.combine = t.combine),
        (this.reflectivity = t.reflectivity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.fog = t.fog),
        this
      );
    }
  }
  const vn = new Yt(),
    yn = new xt();
  class xn {
    constructor(t, e, n = !1) {
      if (Array.isArray(t))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array."
        );
      (this.isBufferAttribute = !0),
        (this.name = ""),
        (this.array = t),
        (this.itemSize = e),
        (this.count = void 0 !== t ? t.length / e : 0),
        (this.normalized = n),
        (this.usage = nt),
        (this._updateRange = { offset: 0, count: -1 }),
        (this.updateRanges = []),
        (this.gpuType = L),
        (this.version = 0);
    }
    onUploadCallback() {}
    set needsUpdate(t) {
      !0 === t && this.version++;
    }
    get updateRange() {
      return (
        console.warn(
          "THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
        ),
        this._updateRange
      );
    }
    setUsage(t) {
      return (this.usage = t), this;
    }
    addUpdateRange(t, e) {
      this.updateRanges.push({ start: t, count: e });
    }
    clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
    copy(t) {
      return (
        (this.name = t.name),
        (this.array = new t.array.constructor(t.array)),
        (this.itemSize = t.itemSize),
        (this.count = t.count),
        (this.normalized = t.normalized),
        (this.usage = t.usage),
        (this.gpuType = t.gpuType),
        this
      );
    }
    copyAt(t, e, n) {
      (t *= this.itemSize), (n *= e.itemSize);
      for (let i = 0, r = this.itemSize; i < r; i++)
        this.array[t + i] = e.array[n + i];
      return this;
    }
    copyArray(t) {
      return this.array.set(t), this;
    }
    applyMatrix3(t) {
      if (2 === this.itemSize)
        for (let e = 0, n = this.count; e < n; e++)
          yn.fromBufferAttribute(this, e),
            yn.applyMatrix3(t),
            this.setXY(e, yn.x, yn.y);
      else if (3 === this.itemSize)
        for (let e = 0, n = this.count; e < n; e++)
          vn.fromBufferAttribute(this, e),
            vn.applyMatrix3(t),
            this.setXYZ(e, vn.x, vn.y, vn.z);
      return this;
    }
    applyMatrix4(t) {
      for (let e = 0, n = this.count; e < n; e++)
        vn.fromBufferAttribute(this, e),
          vn.applyMatrix4(t),
          this.setXYZ(e, vn.x, vn.y, vn.z);
      return this;
    }
    applyNormalMatrix(t) {
      for (let e = 0, n = this.count; e < n; e++)
        vn.fromBufferAttribute(this, e),
          vn.applyNormalMatrix(t),
          this.setXYZ(e, vn.x, vn.y, vn.z);
      return this;
    }
    transformDirection(t) {
      for (let e = 0, n = this.count; e < n; e++)
        vn.fromBufferAttribute(this, e),
          vn.transformDirection(t),
          this.setXYZ(e, vn.x, vn.y, vn.z);
      return this;
    }
    set(t, e = 0) {
      return this.array.set(t, e), this;
    }
    getComponent(t, e) {
      let n = this.array[t * this.itemSize + e];
      return this.normalized && (n = _t(n, this.array)), n;
    }
    setComponent(t, e, n) {
      return (
        this.normalized && (n = vt(n, this.array)),
        (this.array[t * this.itemSize + e] = n),
        this
      );
    }
    getX(t) {
      let e = this.array[t * this.itemSize];
      return this.normalized && (e = _t(e, this.array)), e;
    }
    setX(t, e) {
      return (
        this.normalized && (e = vt(e, this.array)),
        (this.array[t * this.itemSize] = e),
        this
      );
    }
    getY(t) {
      let e = this.array[t * this.itemSize + 1];
      return this.normalized && (e = _t(e, this.array)), e;
    }
    setY(t, e) {
      return (
        this.normalized && (e = vt(e, this.array)),
        (this.array[t * this.itemSize + 1] = e),
        this
      );
    }
    getZ(t) {
      let e = this.array[t * this.itemSize + 2];
      return this.normalized && (e = _t(e, this.array)), e;
    }
    setZ(t, e) {
      return (
        this.normalized && (e = vt(e, this.array)),
        (this.array[t * this.itemSize + 2] = e),
        this
      );
    }
    getW(t) {
      let e = this.array[t * this.itemSize + 3];
      return this.normalized && (e = _t(e, this.array)), e;
    }
    setW(t, e) {
      return (
        this.normalized && (e = vt(e, this.array)),
        (this.array[t * this.itemSize + 3] = e),
        this
      );
    }
    setXY(t, e, n) {
      return (
        (t *= this.itemSize),
        this.normalized && ((e = vt(e, this.array)), (n = vt(n, this.array))),
        (this.array[t + 0] = e),
        (this.array[t + 1] = n),
        this
      );
    }
    setXYZ(t, e, n, i) {
      return (
        (t *= this.itemSize),
        this.normalized &&
          ((e = vt(e, this.array)),
          (n = vt(n, this.array)),
          (i = vt(i, this.array))),
        (this.array[t + 0] = e),
        (this.array[t + 1] = n),
        (this.array[t + 2] = i),
        this
      );
    }
    setXYZW(t, e, n, i, r) {
      return (
        (t *= this.itemSize),
        this.normalized &&
          ((e = vt(e, this.array)),
          (n = vt(n, this.array)),
          (i = vt(i, this.array)),
          (r = vt(r, this.array))),
        (this.array[t + 0] = e),
        (this.array[t + 1] = n),
        (this.array[t + 2] = i),
        (this.array[t + 3] = r),
        this
      );
    }
    onUpload(t) {
      return (this.onUploadCallback = t), this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const t = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.from(this.array),
        normalized: this.normalized,
      };
      return (
        "" !== this.name && (t.name = this.name),
        this.usage !== nt && (t.usage = this.usage),
        t
      );
    }
  }
  class Tn extends xn {
    constructor(t, e, n) {
      super(new Uint16Array(t), e, n);
    }
  }
  class Mn extends xn {
    constructor(t, e, n) {
      super(new Uint32Array(t), e, n);
    }
  }
  class Sn extends xn {
    constructor(t, e, n) {
      super(new Float32Array(t), e, n);
    }
  }
  let bn = 0;
  const En = new be(),
    wn = new Ke(),
    An = new Yt(),
    Rn = new Jt(),
    Cn = new Jt(),
    Pn = new Yt();
  class Ln extends ot {
    constructor() {
      super(),
        (this.isBufferGeometry = !0),
        Object.defineProperty(this, "id", { value: bn++ }),
        (this.uuid = ut()),
        (this.name = ""),
        (this.type = "BufferGeometry"),
        (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.morphTargetsRelative = !1),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.drawRange = { start: 0, count: 1 / 0 }),
        (this.userData = {});
    }
    getIndex() {
      return this.index;
    }
    setIndex(t) {
      return (
        Array.isArray(t)
          ? (this.index = new (St(t) ? Mn : Tn)(t, 1))
          : (this.index = t),
        this
      );
    }
    getAttribute(t) {
      return this.attributes[t];
    }
    setAttribute(t, e) {
      return (this.attributes[t] = e), this;
    }
    deleteAttribute(t) {
      return delete this.attributes[t], this;
    }
    hasAttribute(t) {
      return void 0 !== this.attributes[t];
    }
    addGroup(t, e, n = 0) {
      this.groups.push({ start: t, count: e, materialIndex: n });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(t, e) {
      (this.drawRange.start = t), (this.drawRange.count = e);
    }
    applyMatrix4(t) {
      const e = this.attributes.position;
      void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
      const n = this.attributes.normal;
      if (void 0 !== n) {
        const e = new Tt().getNormalMatrix(t);
        n.applyNormalMatrix(e), (n.needsUpdate = !0);
      }
      const i = this.attributes.tangent;
      return (
        void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        this
      );
    }
    applyQuaternion(t) {
      return En.makeRotationFromQuaternion(t), this.applyMatrix4(En), this;
    }
    rotateX(t) {
      return En.makeRotationX(t), this.applyMatrix4(En), this;
    }
    rotateY(t) {
      return En.makeRotationY(t), this.applyMatrix4(En), this;
    }
    rotateZ(t) {
      return En.makeRotationZ(t), this.applyMatrix4(En), this;
    }
    translate(t, e, n) {
      return En.makeTranslation(t, e, n), this.applyMatrix4(En), this;
    }
    scale(t, e, n) {
      return En.makeScale(t, e, n), this.applyMatrix4(En), this;
    }
    lookAt(t) {
      return (
        wn.lookAt(t), wn.updateMatrix(), this.applyMatrix4(wn.matrix), this
      );
    }
    center() {
      return (
        this.computeBoundingBox(),
        this.boundingBox.getCenter(An).negate(),
        this.translate(An.x, An.y, An.z),
        this
      );
    }
    setFromPoints(t) {
      const e = [];
      for (let n = 0, i = t.length; n < i; n++) {
        const i = t[n];
        e.push(i.x, i.y, i.z || 0);
      }
      return this.setAttribute("position", new Sn(e, 3)), this;
    }
    computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new Jt());
      const t = this.attributes.position,
        e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute)
        return (
          console.error(
            'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
            this
          ),
          void this.boundingBox.set(
            new Yt(-1 / 0, -1 / 0, -1 / 0),
            new Yt(1 / 0, 1 / 0, 1 / 0)
          )
        );
      if (void 0 !== t) {
        if ((this.boundingBox.setFromBufferAttribute(t), e))
          for (let t = 0, n = e.length; t < n; t++) {
            const n = e[t];
            Rn.setFromBufferAttribute(n),
              this.morphTargetsRelative
                ? (Pn.addVectors(this.boundingBox.min, Rn.min),
                  this.boundingBox.expandByPoint(Pn),
                  Pn.addVectors(this.boundingBox.max, Rn.max),
                  this.boundingBox.expandByPoint(Pn))
                : (this.boundingBox.expandByPoint(Rn.min),
                  this.boundingBox.expandByPoint(Rn.max));
          }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) ||
        isNaN(this.boundingBox.min.y) ||
        isNaN(this.boundingBox.min.z)) &&
        console.error(
          'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
          this
        );
    }
    computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new me());
      const t = this.attributes.position,
        e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute)
        return (
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
            this
          ),
          void this.boundingSphere.set(new Yt(), 1 / 0)
        );
      if (t) {
        const n = this.boundingSphere.center;
        if ((Rn.setFromBufferAttribute(t), e))
          for (let t = 0, n = e.length; t < n; t++) {
            const n = e[t];
            Cn.setFromBufferAttribute(n),
              this.morphTargetsRelative
                ? (Pn.addVectors(Rn.min, Cn.min),
                  Rn.expandByPoint(Pn),
                  Pn.addVectors(Rn.max, Cn.max),
                  Rn.expandByPoint(Pn))
                : (Rn.expandByPoint(Cn.min), Rn.expandByPoint(Cn.max));
          }
        Rn.getCenter(n);
        let i = 0;
        for (let e = 0, r = t.count; e < r; e++)
          Pn.fromBufferAttribute(t, e),
            (i = Math.max(i, n.distanceToSquared(Pn)));
        if (e)
          for (let r = 0, s = e.length; r < s; r++) {
            const s = e[r],
              a = this.morphTargetsRelative;
            for (let e = 0, r = s.count; e < r; e++)
              Pn.fromBufferAttribute(s, e),
                a && (An.fromBufferAttribute(t, e), Pn.add(An)),
                (i = Math.max(i, n.distanceToSquared(Pn)));
          }
        (this.boundingSphere.radius = Math.sqrt(i)),
          isNaN(this.boundingSphere.radius) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
              this
            );
      }
    }
    computeTangents() {
      const t = this.index,
        e = this.attributes;
      if (
        null === t ||
        void 0 === e.position ||
        void 0 === e.normal ||
        void 0 === e.uv
      )
        return void console.error(
          "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
        );
      const n = t.array,
        i = e.position.array,
        r = e.normal.array,
        s = e.uv.array,
        a = i.length / 3;
      !1 === this.hasAttribute("tangent") &&
        this.setAttribute("tangent", new xn(new Float32Array(4 * a), 4));
      const o = this.getAttribute("tangent").array,
        l = [],
        c = [];
      for (let t = 0; t < a; t++) (l[t] = new Yt()), (c[t] = new Yt());
      const h = new Yt(),
        u = new Yt(),
        d = new Yt(),
        p = new xt(),
        f = new xt(),
        m = new xt(),
        g = new Yt(),
        _ = new Yt();
      function v(t, e, n) {
        h.fromArray(i, 3 * t),
          u.fromArray(i, 3 * e),
          d.fromArray(i, 3 * n),
          p.fromArray(s, 2 * t),
          f.fromArray(s, 2 * e),
          m.fromArray(s, 2 * n),
          u.sub(h),
          d.sub(h),
          f.sub(p),
          m.sub(p);
        const r = 1 / (f.x * m.y - m.x * f.y);
        isFinite(r) &&
          (g
            .copy(u)
            .multiplyScalar(m.y)
            .addScaledVector(d, -f.y)
            .multiplyScalar(r),
          _.copy(d)
            .multiplyScalar(f.x)
            .addScaledVector(u, -m.x)
            .multiplyScalar(r),
          l[t].add(g),
          l[e].add(g),
          l[n].add(g),
          c[t].add(_),
          c[e].add(_),
          c[n].add(_));
      }
      let y = this.groups;
      0 === y.length && (y = [{ start: 0, count: n.length }]);
      for (let t = 0, e = y.length; t < e; ++t) {
        const e = y[t],
          i = e.start;
        for (let t = i, r = i + e.count; t < r; t += 3)
          v(n[t + 0], n[t + 1], n[t + 2]);
      }
      const x = new Yt(),
        T = new Yt(),
        M = new Yt(),
        S = new Yt();
      function b(t) {
        M.fromArray(r, 3 * t), S.copy(M);
        const e = l[t];
        x.copy(e),
          x.sub(M.multiplyScalar(M.dot(e))).normalize(),
          T.crossVectors(S, e);
        const n = T.dot(c[t]) < 0 ? -1 : 1;
        (o[4 * t] = x.x),
          (o[4 * t + 1] = x.y),
          (o[4 * t + 2] = x.z),
          (o[4 * t + 3] = n);
      }
      for (let t = 0, e = y.length; t < e; ++t) {
        const e = y[t],
          i = e.start;
        for (let t = i, r = i + e.count; t < r; t += 3)
          b(n[t + 0]), b(n[t + 1]), b(n[t + 2]);
      }
    }
    computeVertexNormals() {
      const t = this.index,
        e = this.getAttribute("position");
      if (void 0 !== e) {
        let n = this.getAttribute("normal");
        if (void 0 === n)
          (n = new xn(new Float32Array(3 * e.count), 3)),
            this.setAttribute("normal", n);
        else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
        const i = new Yt(),
          r = new Yt(),
          s = new Yt(),
          a = new Yt(),
          o = new Yt(),
          l = new Yt(),
          c = new Yt(),
          h = new Yt();
        if (t)
          for (let u = 0, d = t.count; u < d; u += 3) {
            const d = t.getX(u + 0),
              p = t.getX(u + 1),
              f = t.getX(u + 2);
            i.fromBufferAttribute(e, d),
              r.fromBufferAttribute(e, p),
              s.fromBufferAttribute(e, f),
              c.subVectors(s, r),
              h.subVectors(i, r),
              c.cross(h),
              a.fromBufferAttribute(n, d),
              o.fromBufferAttribute(n, p),
              l.fromBufferAttribute(n, f),
              a.add(c),
              o.add(c),
              l.add(c),
              n.setXYZ(d, a.x, a.y, a.z),
              n.setXYZ(p, o.x, o.y, o.z),
              n.setXYZ(f, l.x, l.y, l.z);
          }
        else
          for (let t = 0, a = e.count; t < a; t += 3)
            i.fromBufferAttribute(e, t + 0),
              r.fromBufferAttribute(e, t + 1),
              s.fromBufferAttribute(e, t + 2),
              c.subVectors(s, r),
              h.subVectors(i, r),
              c.cross(h),
              n.setXYZ(t + 0, c.x, c.y, c.z),
              n.setXYZ(t + 1, c.x, c.y, c.z),
              n.setXYZ(t + 2, c.x, c.y, c.z);
        this.normalizeNormals(), (n.needsUpdate = !0);
      }
    }
    normalizeNormals() {
      const t = this.attributes.normal;
      for (let e = 0, n = t.count; e < n; e++)
        Pn.fromBufferAttribute(t, e),
          Pn.normalize(),
          t.setXYZ(e, Pn.x, Pn.y, Pn.z);
    }
    toNonIndexed() {
      function t(t, e) {
        const n = t.array,
          i = t.itemSize,
          r = t.normalized,
          s = new n.constructor(e.length * i);
        let a = 0,
          o = 0;
        for (let r = 0, l = e.length; r < l; r++) {
          a = t.isInterleavedBufferAttribute
            ? e[r] * t.data.stride + t.offset
            : e[r] * i;
          for (let t = 0; t < i; t++) s[o++] = n[a++];
        }
        return new xn(s, i, r);
      }
      if (null === this.index)
        return (
          console.warn(
            "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
          ),
          this
        );
      const e = new Ln(),
        n = this.index.array,
        i = this.attributes;
      for (const r in i) {
        const s = t(i[r], n);
        e.setAttribute(r, s);
      }
      const r = this.morphAttributes;
      for (const i in r) {
        const s = [],
          a = r[i];
        for (let e = 0, i = a.length; e < i; e++) {
          const i = t(a[e], n);
          s.push(i);
        }
        e.morphAttributes[i] = s;
      }
      e.morphTargetsRelative = this.morphTargetsRelative;
      const s = this.groups;
      for (let t = 0, n = s.length; t < n; t++) {
        const n = s[t];
        e.addGroup(n.start, n.count, n.materialIndex);
      }
      return e;
    }
    toJSON() {
      const t = {
        metadata: {
          version: 4.6,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON",
        },
      };
      if (
        ((t.uuid = this.uuid),
        (t.type = this.type),
        "" !== this.name && (t.name = this.name),
        Object.keys(this.userData).length > 0 && (t.userData = this.userData),
        void 0 !== this.parameters)
      ) {
        const e = this.parameters;
        for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
        return t;
      }
      t.data = { attributes: {} };
      const e = this.index;
      null !== e &&
        (t.data.index = {
          type: e.array.constructor.name,
          array: Array.prototype.slice.call(e.array),
        });
      const n = this.attributes;
      for (const e in n) {
        const i = n[e];
        t.data.attributes[e] = i.toJSON(t.data);
      }
      const i = {};
      let r = !1;
      for (const e in this.morphAttributes) {
        const n = this.morphAttributes[e],
          s = [];
        for (let e = 0, i = n.length; e < i; e++) {
          const i = n[e];
          s.push(i.toJSON(t.data));
        }
        s.length > 0 && ((i[e] = s), (r = !0));
      }
      r &&
        ((t.data.morphAttributes = i),
        (t.data.morphTargetsRelative = this.morphTargetsRelative));
      const s = this.groups;
      s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
      const a = this.boundingSphere;
      return (
        null !== a &&
          (t.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius,
          }),
        t
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null);
      const e = {};
      this.name = t.name;
      const n = t.index;
      null !== n && this.setIndex(n.clone(e));
      const i = t.attributes;
      for (const t in i) {
        const n = i[t];
        this.setAttribute(t, n.clone(e));
      }
      const r = t.morphAttributes;
      for (const t in r) {
        const n = [],
          i = r[t];
        for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
        this.morphAttributes[t] = n;
      }
      this.morphTargetsRelative = t.morphTargetsRelative;
      const s = t.groups;
      for (let t = 0, e = s.length; t < e; t++) {
        const e = s[t];
        this.addGroup(e.start, e.count, e.materialIndex);
      }
      const a = t.boundingBox;
      null !== a && (this.boundingBox = a.clone());
      const o = t.boundingSphere;
      return (
        null !== o && (this.boundingSphere = o.clone()),
        (this.drawRange.start = t.drawRange.start),
        (this.drawRange.count = t.drawRange.count),
        (this.userData = t.userData),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  const Dn = new be(),
    In = new Se(),
    Un = new me(),
    Nn = new Yt(),
    On = new Yt(),
    Fn = new Yt(),
    kn = new Yt(),
    zn = new Yt(),
    Bn = new Yt(),
    Hn = new xt(),
    Gn = new xt(),
    Vn = new xt(),
    Wn = new Yt(),
    Xn = new Yt(),
    jn = new Yt(),
    qn = new Yt(),
    Yn = new Yt();
  class Kn extends Ke {
    constructor(t = new Ln(), e = new _n()) {
      super(),
        (this.isMesh = !0),
        (this.type = "Mesh"),
        (this.geometry = t),
        (this.material = e),
        this.updateMorphTargets();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        void 0 !== t.morphTargetInfluences &&
          (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
        void 0 !== t.morphTargetDictionary &&
          (this.morphTargetDictionary = Object.assign(
            {},
            t.morphTargetDictionary
          )),
        (this.material = Array.isArray(t.material)
          ? t.material.slice()
          : t.material),
        (this.geometry = t.geometry),
        this
      );
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes,
        e = Object.keys(t);
      if (e.length > 0) {
        const n = t[e[0]];
        if (void 0 !== n) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let t = 0, e = n.length; t < e; t++) {
            const e = n[t].name || String(t);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[e] = t);
          }
        }
      }
    }
    getVertexPosition(t, e) {
      const n = this.geometry,
        i = n.attributes.position,
        r = n.morphAttributes.position,
        s = n.morphTargetsRelative;
      e.fromBufferAttribute(i, t);
      const a = this.morphTargetInfluences;
      if (r && a) {
        Bn.set(0, 0, 0);
        for (let n = 0, i = r.length; n < i; n++) {
          const i = a[n],
            o = r[n];
          0 !== i &&
            (zn.fromBufferAttribute(o, t),
            s ? Bn.addScaledVector(zn, i) : Bn.addScaledVector(zn.sub(e), i));
        }
        e.add(Bn);
      }
      return e;
    }
    raycast(t, e) {
      const n = this.geometry,
        i = this.material,
        r = this.matrixWorld;
      if (void 0 !== i) {
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          Un.copy(n.boundingSphere),
          Un.applyMatrix4(r),
          In.copy(t.ray).recast(t.near),
          !1 === Un.containsPoint(In.origin))
        ) {
          if (null === In.intersectSphere(Un, Nn)) return;
          if (In.origin.distanceToSquared(Nn) > (t.far - t.near) ** 2) return;
        }
        Dn.copy(r).invert(),
          In.copy(t.ray).applyMatrix4(Dn),
          (null !== n.boundingBox && !1 === In.intersectsBox(n.boundingBox)) ||
            this._computeIntersections(t, e, In);
      }
    }
    _computeIntersections(t, e, n) {
      let i;
      const r = this.geometry,
        s = this.material,
        a = r.index,
        o = r.attributes.position,
        l = r.attributes.uv,
        c = r.attributes.uv1,
        h = r.attributes.normal,
        u = r.groups,
        d = r.drawRange;
      if (null !== a)
        if (Array.isArray(s))
          for (let r = 0, o = u.length; r < o; r++) {
            const o = u[r],
              p = s[o.materialIndex];
            for (
              let r = Math.max(o.start, d.start),
                s = Math.min(
                  a.count,
                  Math.min(o.start + o.count, d.start + d.count)
                );
              r < s;
              r += 3
            )
              (i = Zn(
                this,
                p,
                t,
                n,
                l,
                c,
                h,
                a.getX(r),
                a.getX(r + 1),
                a.getX(r + 2)
              )),
                i &&
                  ((i.faceIndex = Math.floor(r / 3)),
                  (i.face.materialIndex = o.materialIndex),
                  e.push(i));
          }
        else
          for (
            let r = Math.max(0, d.start),
              o = Math.min(a.count, d.start + d.count);
            r < o;
            r += 3
          )
            (i = Zn(
              this,
              s,
              t,
              n,
              l,
              c,
              h,
              a.getX(r),
              a.getX(r + 1),
              a.getX(r + 2)
            )),
              i && ((i.faceIndex = Math.floor(r / 3)), e.push(i));
      else if (void 0 !== o)
        if (Array.isArray(s))
          for (let r = 0, a = u.length; r < a; r++) {
            const a = u[r],
              p = s[a.materialIndex];
            for (
              let r = Math.max(a.start, d.start),
                s = Math.min(
                  o.count,
                  Math.min(a.start + a.count, d.start + d.count)
                );
              r < s;
              r += 3
            )
              (i = Zn(this, p, t, n, l, c, h, r, r + 1, r + 2)),
                i &&
                  ((i.faceIndex = Math.floor(r / 3)),
                  (i.face.materialIndex = a.materialIndex),
                  e.push(i));
          }
        else
          for (
            let r = Math.max(0, d.start),
              a = Math.min(o.count, d.start + d.count);
            r < a;
            r += 3
          )
            (i = Zn(this, s, t, n, l, c, h, r, r + 1, r + 2)),
              i && ((i.faceIndex = Math.floor(r / 3)), e.push(i));
    }
  }
  function Zn(t, e, n, i, r, s, a, o, l, c) {
    t.getVertexPosition(o, On),
      t.getVertexPosition(l, Fn),
      t.getVertexPosition(c, kn);
    const h = (function (t, e, n, i, r, s, a, o) {
      let l;
      if (
        ((l =
          1 === e.side
            ? i.intersectTriangle(a, s, r, !0, o)
            : i.intersectTriangle(r, s, a, 0 === e.side, o)),
        null === l)
      )
        return null;
      Yn.copy(o), Yn.applyMatrix4(t.matrixWorld);
      const c = n.ray.origin.distanceTo(Yn);
      return c < n.near || c > n.far
        ? null
        : { distance: c, point: Yn.clone(), object: t };
    })(t, e, n, i, On, Fn, kn, qn);
    if (h) {
      r &&
        (Hn.fromBufferAttribute(r, o),
        Gn.fromBufferAttribute(r, l),
        Vn.fromBufferAttribute(r, c),
        (h.uv = ln.getInterpolation(qn, On, Fn, kn, Hn, Gn, Vn, new xt()))),
        s &&
          (Hn.fromBufferAttribute(s, o),
          Gn.fromBufferAttribute(s, l),
          Vn.fromBufferAttribute(s, c),
          (h.uv1 = ln.getInterpolation(qn, On, Fn, kn, Hn, Gn, Vn, new xt())),
          (h.uv2 = h.uv1)),
        a &&
          (Wn.fromBufferAttribute(a, o),
          Xn.fromBufferAttribute(a, l),
          jn.fromBufferAttribute(a, c),
          (h.normal = ln.getInterpolation(
            qn,
            On,
            Fn,
            kn,
            Wn,
            Xn,
            jn,
            new Yt()
          )),
          h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
      const t = { a: o, b: l, c, normal: new Yt(), materialIndex: 0 };
      ln.getNormal(On, Fn, kn, t.normal), (h.face = t);
    }
    return h;
  }
  class Jn extends Ln {
    constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
      super(),
        (this.type = "BoxGeometry"),
        (this.parameters = {
          width: t,
          height: e,
          depth: n,
          widthSegments: i,
          heightSegments: r,
          depthSegments: s,
        });
      const a = this;
      (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));
      const o = [],
        l = [],
        c = [],
        h = [];
      let u = 0,
        d = 0;
      function p(t, e, n, i, r, s, p, f, m, g, _) {
        const v = s / m,
          y = p / g,
          x = s / 2,
          T = p / 2,
          M = f / 2,
          S = m + 1,
          b = g + 1;
        let E = 0,
          w = 0;
        const A = new Yt();
        for (let s = 0; s < b; s++) {
          const a = s * y - T;
          for (let o = 0; o < S; o++) {
            const u = o * v - x;
            (A[t] = u * i),
              (A[e] = a * r),
              (A[n] = M),
              l.push(A.x, A.y, A.z),
              (A[t] = 0),
              (A[e] = 0),
              (A[n] = f > 0 ? 1 : -1),
              c.push(A.x, A.y, A.z),
              h.push(o / m),
              h.push(1 - s / g),
              (E += 1);
          }
        }
        for (let t = 0; t < g; t++)
          for (let e = 0; e < m; e++) {
            const n = u + e + S * t,
              i = u + e + S * (t + 1),
              r = u + (e + 1) + S * (t + 1),
              s = u + (e + 1) + S * t;
            o.push(n, i, s), o.push(i, r, s), (w += 6);
          }
        a.addGroup(d, w, _), (d += w), (u += E);
      }
      p("z", "y", "x", -1, -1, n, e, t, s, r, 0),
        p("z", "y", "x", 1, -1, n, e, -t, s, r, 1),
        p("x", "z", "y", 1, 1, t, n, e, i, s, 2),
        p("x", "z", "y", 1, -1, t, n, -e, i, s, 3),
        p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
        p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
        this.setIndex(o),
        this.setAttribute("position", new Sn(l, 3)),
        this.setAttribute("normal", new Sn(c, 3)),
        this.setAttribute("uv", new Sn(h, 2));
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
    static fromJSON(t) {
      return new Jn(
        t.width,
        t.height,
        t.depth,
        t.widthSegments,
        t.heightSegments,
        t.depthSegments
      );
    }
  }
  function Qn(t) {
    const e = {};
    for (const n in t) {
      e[n] = {};
      for (const i in t[n]) {
        const r = t[n][i];
        r &&
        (r.isColor ||
          r.isMatrix3 ||
          r.isMatrix4 ||
          r.isVector2 ||
          r.isVector3 ||
          r.isVector4 ||
          r.isTexture ||
          r.isQuaternion)
          ? r.isRenderTargetTexture
            ? (console.warn(
                "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
              ),
              (e[n][i] = null))
            : (e[n][i] = r.clone())
          : Array.isArray(r)
          ? (e[n][i] = r.slice())
          : (e[n][i] = r);
      }
    }
    return e;
  }
  function $n(t) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
      const i = Qn(t[n]);
      for (const t in i) e[t] = i[t];
    }
    return e;
  }
  function ti(t) {
    return null === t.getRenderTarget()
      ? t.outputColorSpace
      : Dt.workingColorSpace;
  }
  const ei = { clone: Qn, merge: $n };
  class ni extends gn {
    constructor(t) {
      super(),
        (this.isShaderMaterial = !0),
        (this.type = "ShaderMaterial"),
        (this.defines = {}),
        (this.uniforms = {}),
        (this.uniformsGroups = []),
        (this.vertexShader =
          "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
        (this.fragmentShader =
          "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
        (this.linewidth = 1),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        (this.lights = !1),
        (this.clipping = !1),
        (this.forceSinglePass = !0),
        (this.extensions = {
          derivatives: !1,
          fragDepth: !1,
          drawBuffers: !1,
          shaderTextureLOD: !1,
          clipCullDistance: !1,
        }),
        (this.defaultAttributeValues = {
          color: [1, 1, 1],
          uv: [0, 0],
          uv1: [0, 0],
        }),
        (this.index0AttributeName = void 0),
        (this.uniformsNeedUpdate = !1),
        (this.glslVersion = null),
        void 0 !== t && this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.fragmentShader = t.fragmentShader),
        (this.vertexShader = t.vertexShader),
        (this.uniforms = Qn(t.uniforms)),
        (this.uniformsGroups = (function (t) {
          const e = [];
          for (let n = 0; n < t.length; n++) e.push(t[n].clone());
          return e;
        })(t.uniformsGroups)),
        (this.defines = Object.assign({}, t.defines)),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.fog = t.fog),
        (this.lights = t.lights),
        (this.clipping = t.clipping),
        (this.extensions = Object.assign({}, t.extensions)),
        (this.glslVersion = t.glslVersion),
        this
      );
    }
    toJSON(t) {
      const e = super.toJSON(t);
      (e.glslVersion = this.glslVersion), (e.uniforms = {});
      for (const n in this.uniforms) {
        const i = this.uniforms[n].value;
        i && i.isTexture
          ? (e.uniforms[n] = { type: "t", value: i.toJSON(t).uuid })
          : i && i.isColor
          ? (e.uniforms[n] = { type: "c", value: i.getHex() })
          : i && i.isVector2
          ? (e.uniforms[n] = { type: "v2", value: i.toArray() })
          : i && i.isVector3
          ? (e.uniforms[n] = { type: "v3", value: i.toArray() })
          : i && i.isVector4
          ? (e.uniforms[n] = { type: "v4", value: i.toArray() })
          : i && i.isMatrix3
          ? (e.uniforms[n] = { type: "m3", value: i.toArray() })
          : i && i.isMatrix4
          ? (e.uniforms[n] = { type: "m4", value: i.toArray() })
          : (e.uniforms[n] = { value: i });
      }
      Object.keys(this.defines).length > 0 && (e.defines = this.defines),
        (e.vertexShader = this.vertexShader),
        (e.fragmentShader = this.fragmentShader),
        (e.lights = this.lights),
        (e.clipping = this.clipping);
      const n = {};
      for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
      return Object.keys(n).length > 0 && (e.extensions = n), e;
    }
  }
  class ii extends Ke {
    constructor() {
      super(),
        (this.isCamera = !0),
        (this.type = "Camera"),
        (this.matrixWorldInverse = new be()),
        (this.projectionMatrix = new be()),
        (this.projectionMatrixInverse = new be()),
        (this.coordinateSystem = st);
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        this.matrixWorldInverse.copy(t.matrixWorldInverse),
        this.projectionMatrix.copy(t.projectionMatrix),
        this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
        (this.coordinateSystem = t.coordinateSystem),
        this
      );
    }
    getWorldDirection(t) {
      return super.getWorldDirection(t).negate();
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(t, e) {
      super.updateWorldMatrix(t, e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class ri extends ii {
    constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
      super(),
        (this.isPerspectiveCamera = !0),
        (this.type = "PerspectiveCamera"),
        (this.fov = t),
        (this.zoom = 1),
        (this.near = n),
        (this.far = i),
        (this.focus = 10),
        (this.aspect = e),
        (this.view = null),
        (this.filmGauge = 35),
        (this.filmOffset = 0),
        this.updateProjectionMatrix();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.fov = t.fov),
        (this.zoom = t.zoom),
        (this.near = t.near),
        (this.far = t.far),
        (this.focus = t.focus),
        (this.aspect = t.aspect),
        (this.view = null === t.view ? null : Object.assign({}, t.view)),
        (this.filmGauge = t.filmGauge),
        (this.filmOffset = t.filmOffset),
        this
      );
    }
    setFocalLength(t) {
      const e = (0.5 * this.getFilmHeight()) / t;
      (this.fov = 2 * ht * Math.atan(e)), this.updateProjectionMatrix();
    }
    getFocalLength() {
      const t = Math.tan(0.5 * ct * this.fov);
      return (0.5 * this.getFilmHeight()) / t;
    }
    getEffectiveFOV() {
      return 2 * ht * Math.atan(Math.tan(0.5 * ct * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(t, e, n, i, r, s) {
      (this.aspect = t / e),
        null === this.view &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1,
          }),
        (this.view.enabled = !0),
        (this.view.fullWidth = t),
        (this.view.fullHeight = e),
        (this.view.offsetX = n),
        (this.view.offsetY = i),
        (this.view.width = r),
        (this.view.height = s),
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
      null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const t = this.near;
      let e = (t * Math.tan(0.5 * ct * this.fov)) / this.zoom,
        n = 2 * e,
        i = this.aspect * n,
        r = -0.5 * i;
      const s = this.view;
      if (null !== this.view && this.view.enabled) {
        const t = s.fullWidth,
          a = s.fullHeight;
        (r += (s.offsetX * i) / t),
          (e -= (s.offsetY * n) / a),
          (i *= s.width / t),
          (n *= s.height / a);
      }
      const a = this.filmOffset;
      0 !== a && (r += (t * a) / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(
          r,
          r + i,
          e,
          e - n,
          t,
          this.far,
          this.coordinateSystem
        ),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        (e.object.fov = this.fov),
        (e.object.zoom = this.zoom),
        (e.object.near = this.near),
        (e.object.far = this.far),
        (e.object.focus = this.focus),
        (e.object.aspect = this.aspect),
        null !== this.view && (e.object.view = Object.assign({}, this.view)),
        (e.object.filmGauge = this.filmGauge),
        (e.object.filmOffset = this.filmOffset),
        e
      );
    }
  }
  const si = -90;
  class ai extends Ke {
    constructor(t, e, n) {
      super(),
        (this.type = "CubeCamera"),
        (this.renderTarget = n),
        (this.coordinateSystem = null),
        (this.activeMipmapLevel = 0);
      const i = new ri(si, 1, t, e);
      (i.layers = this.layers), this.add(i);
      const r = new ri(si, 1, t, e);
      (r.layers = this.layers), this.add(r);
      const s = new ri(si, 1, t, e);
      (s.layers = this.layers), this.add(s);
      const a = new ri(si, 1, t, e);
      (a.layers = this.layers), this.add(a);
      const o = new ri(si, 1, t, e);
      (o.layers = this.layers), this.add(o);
      const l = new ri(si, 1, t, e);
      (l.layers = this.layers), this.add(l);
    }
    updateCoordinateSystem() {
      const t = this.coordinateSystem,
        e = this.children.concat(),
        [n, i, r, s, a, o] = e;
      for (const t of e) this.remove(t);
      if (t === st)
        n.up.set(0, 1, 0),
          n.lookAt(1, 0, 0),
          i.up.set(0, 1, 0),
          i.lookAt(-1, 0, 0),
          r.up.set(0, 0, -1),
          r.lookAt(0, 1, 0),
          s.up.set(0, 0, 1),
          s.lookAt(0, -1, 0),
          a.up.set(0, 1, 0),
          a.lookAt(0, 0, 1),
          o.up.set(0, 1, 0),
          o.lookAt(0, 0, -1);
      else {
        if (t !== at)
          throw new Error(
            "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
              t
          );
        n.up.set(0, -1, 0),
          n.lookAt(-1, 0, 0),
          i.up.set(0, -1, 0),
          i.lookAt(1, 0, 0),
          r.up.set(0, 0, 1),
          r.lookAt(0, 1, 0),
          s.up.set(0, 0, -1),
          s.lookAt(0, -1, 0),
          a.up.set(0, -1, 0),
          a.lookAt(0, 0, 1),
          o.up.set(0, -1, 0),
          o.lookAt(0, 0, -1);
      }
      for (const t of e) this.add(t), t.updateMatrixWorld();
    }
    update(t, e) {
      null === this.parent && this.updateMatrixWorld();
      const { renderTarget: n, activeMipmapLevel: i } = this;
      this.coordinateSystem !== t.coordinateSystem &&
        ((this.coordinateSystem = t.coordinateSystem),
        this.updateCoordinateSystem());
      const [r, s, a, o, l, c] = this.children,
        h = t.getRenderTarget(),
        u = t.getActiveCubeFace(),
        d = t.getActiveMipmapLevel(),
        p = t.xr.enabled;
      t.xr.enabled = !1;
      const f = n.texture.generateMipmaps;
      (n.texture.generateMipmaps = !1),
        t.setRenderTarget(n, 0, i),
        t.render(e, r),
        t.setRenderTarget(n, 1, i),
        t.render(e, s),
        t.setRenderTarget(n, 2, i),
        t.render(e, a),
        t.setRenderTarget(n, 3, i),
        t.render(e, o),
        t.setRenderTarget(n, 4, i),
        t.render(e, l),
        (n.texture.generateMipmaps = f),
        t.setRenderTarget(n, 5, i),
        t.render(e, c),
        t.setRenderTarget(h, u, d),
        (t.xr.enabled = p),
        (n.texture.needsPMREMUpdate = !0);
    }
  }
  class oi extends Ht {
    constructor(t, e, n, i, r, s, a, o, l, c) {
      super(
        (t = void 0 !== t ? t : []),
        (e = void 0 !== e ? e : _),
        n,
        i,
        r,
        s,
        a,
        o,
        l,
        c
      ),
        (this.isCubeTexture = !0),
        (this.flipY = !1);
    }
    get images() {
      return this.image;
    }
    set images(t) {
      this.image = t;
    }
  }
  class li extends Wt {
    constructor(t = 1, e = {}) {
      super(t, t, e), (this.isWebGLCubeRenderTarget = !0);
      const n = { width: t, height: t, depth: 1 },
        i = [n, n, n, n, n, n];
      void 0 !== e.encoding &&
        (At(
          "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
        ),
        (e.colorSpace = e.encoding === X ? q : j)),
        (this.texture = new oi(
          i,
          e.mapping,
          e.wrapS,
          e.wrapT,
          e.magFilter,
          e.minFilter,
          e.format,
          e.type,
          e.anisotropy,
          e.colorSpace
        )),
        (this.texture.isRenderTargetTexture = !0),
        (this.texture.generateMipmaps =
          void 0 !== e.generateMipmaps && e.generateMipmaps),
        (this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : w);
    }
    fromEquirectangularTexture(t, e) {
      (this.texture.type = e.type),
        (this.texture.colorSpace = e.colorSpace),
        (this.texture.generateMipmaps = e.generateMipmaps),
        (this.texture.minFilter = e.minFilter),
        (this.texture.magFilter = e.magFilter);
      const n = { tEquirect: { value: null } },
        i =
          "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
        r =
          "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
        s = new Jn(5, 5, 5),
        a = new ni({
          name: "CubemapFromEquirect",
          uniforms: Qn(n),
          vertexShader: i,
          fragmentShader: r,
          side: 1,
          blending: 0,
        });
      a.uniforms.tEquirect.value = e;
      const o = new Kn(s, a),
        l = e.minFilter;
      return (
        e.minFilter === A && (e.minFilter = w),
        new ai(1, 10, this).update(t, o),
        (e.minFilter = l),
        o.geometry.dispose(),
        o.material.dispose(),
        this
      );
    }
    clear(t, e, n, i) {
      const r = t.getRenderTarget();
      for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
      t.setRenderTarget(r);
    }
  }
  const ci = new Yt(),
    hi = new Yt(),
    ui = new Tt();
  class di {
    constructor(t = new Yt(1, 0, 0), e = 0) {
      (this.isPlane = !0), (this.normal = t), (this.constant = e);
    }
    set(t, e) {
      return this.normal.copy(t), (this.constant = e), this;
    }
    setComponents(t, e, n, i) {
      return this.normal.set(t, e, n), (this.constant = i), this;
    }
    setFromNormalAndCoplanarPoint(t, e) {
      return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
    }
    setFromCoplanarPoints(t, e, n) {
      const i = ci.subVectors(n, e).cross(hi.subVectors(t, e)).normalize();
      return this.setFromNormalAndCoplanarPoint(i, t), this;
    }
    copy(t) {
      return this.normal.copy(t.normal), (this.constant = t.constant), this;
    }
    normalize() {
      const t = 1 / this.normal.length();
      return this.normal.multiplyScalar(t), (this.constant *= t), this;
    }
    negate() {
      return (this.constant *= -1), this.normal.negate(), this;
    }
    distanceToPoint(t) {
      return this.normal.dot(t) + this.constant;
    }
    distanceToSphere(t) {
      return this.distanceToPoint(t.center) - t.radius;
    }
    projectPoint(t, e) {
      return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t));
    }
    intersectLine(t, e) {
      const n = t.delta(ci),
        i = this.normal.dot(n);
      if (0 === i)
        return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
      const r = -(t.start.dot(this.normal) + this.constant) / i;
      return r < 0 || r > 1 ? null : e.copy(t.start).addScaledVector(n, r);
    }
    intersectsLine(t) {
      const e = this.distanceToPoint(t.start),
        n = this.distanceToPoint(t.end);
      return (e < 0 && n > 0) || (n < 0 && e > 0);
    }
    intersectsBox(t) {
      return t.intersectsPlane(this);
    }
    intersectsSphere(t) {
      return t.intersectsPlane(this);
    }
    coplanarPoint(t) {
      return t.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(t, e) {
      const n = e || ui.getNormalMatrix(t),
        i = this.coplanarPoint(ci).applyMatrix4(t),
        r = this.normal.applyMatrix3(n).normalize();
      return (this.constant = -i.dot(r)), this;
    }
    translate(t) {
      return (this.constant -= t.dot(this.normal)), this;
    }
    equals(t) {
      return t.normal.equals(this.normal) && t.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const pi = new me(),
    fi = new Yt();
  class mi {
    constructor(
      t = new di(),
      e = new di(),
      n = new di(),
      i = new di(),
      r = new di(),
      s = new di()
    ) {
      this.planes = [t, e, n, i, r, s];
    }
    set(t, e, n, i, r, s) {
      const a = this.planes;
      return (
        a[0].copy(t),
        a[1].copy(e),
        a[2].copy(n),
        a[3].copy(i),
        a[4].copy(r),
        a[5].copy(s),
        this
      );
    }
    copy(t) {
      const e = this.planes;
      for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
      return this;
    }
    setFromProjectionMatrix(t, e = 2e3) {
      const n = this.planes,
        i = t.elements,
        r = i[0],
        s = i[1],
        a = i[2],
        o = i[3],
        l = i[4],
        c = i[5],
        h = i[6],
        u = i[7],
        d = i[8],
        p = i[9],
        f = i[10],
        m = i[11],
        g = i[12],
        _ = i[13],
        v = i[14],
        y = i[15];
      if (
        (n[0].setComponents(o - r, u - l, m - d, y - g).normalize(),
        n[1].setComponents(o + r, u + l, m + d, y + g).normalize(),
        n[2].setComponents(o + s, u + c, m + p, y + _).normalize(),
        n[3].setComponents(o - s, u - c, m - p, y - _).normalize(),
        n[4].setComponents(o - a, u - h, m - f, y - v).normalize(),
        e === st)
      )
        n[5].setComponents(o + a, u + h, m + f, y + v).normalize();
      else {
        if (e !== at)
          throw new Error(
            "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
              e
          );
        n[5].setComponents(a, h, f, v).normalize();
      }
      return this;
    }
    intersectsObject(t) {
      if (void 0 !== t.boundingSphere)
        null === t.boundingSphere && t.computeBoundingSphere(),
          pi.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
      else {
        const e = t.geometry;
        null === e.boundingSphere && e.computeBoundingSphere(),
          pi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
      }
      return this.intersectsSphere(pi);
    }
    intersectsSprite(t) {
      return (
        pi.center.set(0, 0, 0),
        (pi.radius = 0.7071067811865476),
        pi.applyMatrix4(t.matrixWorld),
        this.intersectsSphere(pi)
      );
    }
    intersectsSphere(t) {
      const e = this.planes,
        n = t.center,
        i = -t.radius;
      for (let t = 0; t < 6; t++) if (e[t].distanceToPoint(n) < i) return !1;
      return !0;
    }
    intersectsBox(t) {
      const e = this.planes;
      for (let n = 0; n < 6; n++) {
        const i = e[n];
        if (
          ((fi.x = i.normal.x > 0 ? t.max.x : t.min.x),
          (fi.y = i.normal.y > 0 ? t.max.y : t.min.y),
          (fi.z = i.normal.z > 0 ? t.max.z : t.min.z),
          i.distanceToPoint(fi) < 0)
        )
          return !1;
      }
      return !0;
    }
    containsPoint(t) {
      const e = this.planes;
      for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;
      return !0;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  function gi() {
    let t = null,
      e = !1,
      n = null,
      i = null;
    function r(e, s) {
      n(e, s), (i = t.requestAnimationFrame(r));
    }
    return {
      start: function () {
        !0 !== e && null !== n && ((i = t.requestAnimationFrame(r)), (e = !0));
      },
      stop: function () {
        t.cancelAnimationFrame(i), (e = !1);
      },
      setAnimationLoop: function (t) {
        n = t;
      },
      setContext: function (e) {
        t = e;
      },
    };
  }
  function _i(t, e) {
    const n = e.isWebGL2,
      i = new WeakMap();
    return {
      get: function (t) {
        return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
      },
      remove: function (e) {
        e.isInterleavedBufferAttribute && (e = e.data);
        const n = i.get(e);
        n && (t.deleteBuffer(n.buffer), i.delete(e));
      },
      update: function (e, r) {
        if (e.isGLBufferAttribute) {
          const t = i.get(e);
          return void (
            (!t || t.version < e.version) &&
            i.set(e, {
              buffer: e.buffer,
              type: e.type,
              bytesPerElement: e.elementSize,
              version: e.version,
            })
          );
        }
        e.isInterleavedBufferAttribute && (e = e.data);
        const s = i.get(e);
        if (void 0 === s)
          i.set(
            e,
            (function (e, i) {
              const r = e.array,
                s = e.usage,
                a = r.byteLength,
                o = t.createBuffer();
              let l;
              if (
                (t.bindBuffer(i, o),
                t.bufferData(i, r, s),
                e.onUploadCallback(),
                r instanceof Float32Array)
              )
                l = t.FLOAT;
              else if (r instanceof Uint16Array)
                if (e.isFloat16BufferAttribute) {
                  if (!n)
                    throw new Error(
                      "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                    );
                  l = t.HALF_FLOAT;
                } else l = t.UNSIGNED_SHORT;
              else if (r instanceof Int16Array) l = t.SHORT;
              else if (r instanceof Uint32Array) l = t.UNSIGNED_INT;
              else if (r instanceof Int32Array) l = t.INT;
              else if (r instanceof Int8Array) l = t.BYTE;
              else if (r instanceof Uint8Array) l = t.UNSIGNED_BYTE;
              else {
                if (!(r instanceof Uint8ClampedArray))
                  throw new Error(
                    "THREE.WebGLAttributes: Unsupported buffer data format: " +
                      r
                  );
                l = t.UNSIGNED_BYTE;
              }
              return {
                buffer: o,
                type: l,
                bytesPerElement: r.BYTES_PER_ELEMENT,
                version: e.version,
                size: a,
              };
            })(e, r)
          );
        else if (s.version < e.version) {
          if (s.size !== e.array.byteLength)
            throw new Error(
              "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
            );
          !(function (e, i, r) {
            const s = i.array,
              a = i._updateRange,
              o = i.updateRanges;
            if (
              (t.bindBuffer(r, e),
              -1 === a.count && 0 === o.length && t.bufferSubData(r, 0, s),
              0 !== o.length)
            ) {
              for (let e = 0, i = o.length; e < i; e++) {
                const i = o[e];
                n
                  ? t.bufferSubData(
                      r,
                      i.start * s.BYTES_PER_ELEMENT,
                      s,
                      i.start,
                      i.count
                    )
                  : t.bufferSubData(
                      r,
                      i.start * s.BYTES_PER_ELEMENT,
                      s.subarray(i.start, i.start + i.count)
                    );
              }
              i.clearUpdateRanges();
            }
            -1 !== a.count &&
              (n
                ? t.bufferSubData(
                    r,
                    a.offset * s.BYTES_PER_ELEMENT,
                    s,
                    a.offset,
                    a.count
                  )
                : t.bufferSubData(
                    r,
                    a.offset * s.BYTES_PER_ELEMENT,
                    s.subarray(a.offset, a.offset + a.count)
                  ),
              (a.count = -1)),
              i.onUploadCallback();
          })(s.buffer, e, r),
            (s.version = e.version);
        }
      },
    };
  }
  class vi extends Ln {
    constructor(t = 1, e = 1, n = 1, i = 1) {
      super(),
        (this.type = "PlaneGeometry"),
        (this.parameters = {
          width: t,
          height: e,
          widthSegments: n,
          heightSegments: i,
        });
      const r = t / 2,
        s = e / 2,
        a = Math.floor(n),
        o = Math.floor(i),
        l = a + 1,
        c = o + 1,
        h = t / a,
        u = e / o,
        d = [],
        p = [],
        f = [],
        m = [];
      for (let t = 0; t < c; t++) {
        const e = t * u - s;
        for (let n = 0; n < l; n++) {
          const i = n * h - r;
          p.push(i, -e, 0), f.push(0, 0, 1), m.push(n / a), m.push(1 - t / o);
        }
      }
      for (let t = 0; t < o; t++)
        for (let e = 0; e < a; e++) {
          const n = e + l * t,
            i = e + l * (t + 1),
            r = e + 1 + l * (t + 1),
            s = e + 1 + l * t;
          d.push(n, i, s), d.push(i, r, s);
        }
      this.setIndex(d),
        this.setAttribute("position", new Sn(p, 3)),
        this.setAttribute("normal", new Sn(f, 3)),
        this.setAttribute("uv", new Sn(m, 2));
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
    static fromJSON(t) {
      return new vi(t.width, t.height, t.widthSegments, t.heightSegments);
    }
  }
  const yi = {
      alphahash_fragment:
        "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
      alphahash_pars_fragment:
        "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
      alphamap_fragment:
        "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
      alphamap_pars_fragment:
        "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
      alphatest_fragment:
        "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
      alphatest_pars_fragment:
        "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
      aomap_fragment:
        "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
      aomap_pars_fragment:
        "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
      batching_pars_vertex:
        "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
      batching_vertex:
        "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif",
      begin_vertex:
        "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
      beginnormal_vertex:
        "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
      bsdfs:
        "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
      iridescence_fragment:
        "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
      bumpmap_pars_fragment:
        "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
      clipping_planes_fragment:
        "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
      clipping_planes_pars_fragment:
        "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
      clipping_planes_pars_vertex:
        "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
      clipping_planes_vertex:
        "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
      color_fragment:
        "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
      color_pars_fragment:
        "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
      color_pars_vertex:
        "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
      color_vertex:
        "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
      common:
        "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
      cube_uv_reflection_fragment:
        "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
      defaultnormal_vertex:
        "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
      displacementmap_pars_vertex:
        "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
      displacementmap_vertex:
        "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
      emissivemap_fragment:
        "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
      emissivemap_pars_fragment:
        "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
      colorspace_fragment:
        "gl_FragColor = linearToOutputTexel( gl_FragColor );",
      colorspace_pars_fragment:
        "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",
      envmap_fragment:
        "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
      envmap_common_pars_fragment:
        "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
      envmap_pars_fragment:
        "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
      envmap_pars_vertex:
        "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
      envmap_physical_pars_fragment:
        "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
      envmap_vertex:
        "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
      fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
      fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
      fog_fragment:
        "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
      fog_pars_fragment:
        "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
      gradientmap_pars_fragment:
        "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
      lightmap_fragment:
        "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
      lightmap_pars_fragment:
        "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
      lights_lambert_fragment:
        "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
      lights_lambert_pars_fragment:
        "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
      lights_pars_begin:
        "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
      lights_toon_fragment:
        "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
      lights_toon_pars_fragment:
        "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
      lights_phong_fragment:
        "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
      lights_phong_pars_fragment:
        "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
      lights_physical_fragment:
        "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
      lights_physical_pars_fragment:
        "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
      lights_fragment_begin:
        "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
      lights_fragment_maps:
        "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
      lights_fragment_end:
        "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
      logdepthbuf_fragment:
        "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
      logdepthbuf_pars_fragment:
        "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
      logdepthbuf_pars_vertex:
        "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
      logdepthbuf_vertex:
        "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
      map_fragment:
        "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
      map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
      map_particle_fragment:
        "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
      map_particle_pars_fragment:
        "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
      metalnessmap_fragment:
        "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
      metalnessmap_pars_fragment:
        "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
      morphcolor_vertex:
        "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
      morphnormal_vertex:
        "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
      morphtarget_pars_vertex:
        "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
      morphtarget_vertex:
        "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
      normal_fragment_begin:
        "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
      normal_fragment_maps:
        "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
      normal_pars_fragment:
        "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
      normal_pars_vertex:
        "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
      normal_vertex:
        "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
      normalmap_pars_fragment:
        "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
      clearcoat_normal_fragment_begin:
        "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
      clearcoat_normal_fragment_maps:
        "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
      clearcoat_pars_fragment:
        "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
      iridescence_pars_fragment:
        "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
      opaque_fragment:
        "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
      packing:
        "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
      premultiplied_alpha_fragment:
        "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
      project_vertex:
        "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
      dithering_fragment:
        "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
      dithering_pars_fragment:
        "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
      roughnessmap_fragment:
        "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
      roughnessmap_pars_fragment:
        "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
      shadowmap_pars_fragment:
        "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
      shadowmap_pars_vertex:
        "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
      shadowmap_vertex:
        "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
      shadowmask_pars_fragment:
        "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
      skinbase_vertex:
        "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
      skinning_pars_vertex:
        "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
      skinning_vertex:
        "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
      skinnormal_vertex:
        "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
      specularmap_fragment:
        "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
      specularmap_pars_fragment:
        "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
      tonemapping_fragment:
        "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
      tonemapping_pars_fragment:
        "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor *= toneMappingExposure;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\treturn color;\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
      transmission_fragment:
        "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
      transmission_pars_fragment:
        "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
      uv_pars_fragment:
        "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
      uv_pars_vertex:
        "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
      uv_vertex:
        "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
      worldpos_vertex:
        "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
      background_vert:
        "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
      background_frag:
        "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      backgroundCube_vert:
        "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
      backgroundCube_frag:
        "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      cube_vert:
        "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
      cube_frag:
        "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      depth_vert:
        "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
      depth_frag:
        "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
      distanceRGBA_vert:
        "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
      distanceRGBA_frag:
        "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
      equirect_vert:
        "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
      equirect_frag:
        "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      linedashed_vert:
        "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      linedashed_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
      meshbasic_vert:
        "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
      meshbasic_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshlambert_vert:
        "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshlambert_frag:
        "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshmatcap_vert:
        "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
      meshmatcap_frag:
        "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshnormal_vert:
        "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
      meshnormal_frag:
        "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
      meshphong_vert:
        "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshphong_frag:
        "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshphysical_vert:
        "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
      meshphysical_frag:
        "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshtoon_vert:
        "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshtoon_frag:
        "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      points_vert:
        "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
      points_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
      shadow_vert:
        "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      shadow_frag:
        "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
      sprite_vert:
        "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      sprite_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
    },
    xi = {
      common: {
        diffuse: { value: new pn(16777215) },
        opacity: { value: 1 },
        map: { value: null },
        mapTransform: { value: new Tt() },
        alphaMap: { value: null },
        alphaMapTransform: { value: new Tt() },
        alphaTest: { value: 0 },
      },
      specularmap: {
        specularMap: { value: null },
        specularMapTransform: { value: new Tt() },
      },
      envmap: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        reflectivity: { value: 1 },
        ior: { value: 1.5 },
        refractionRatio: { value: 0.98 },
      },
      aomap: {
        aoMap: { value: null },
        aoMapIntensity: { value: 1 },
        aoMapTransform: { value: new Tt() },
      },
      lightmap: {
        lightMap: { value: null },
        lightMapIntensity: { value: 1 },
        lightMapTransform: { value: new Tt() },
      },
      bumpmap: {
        bumpMap: { value: null },
        bumpMapTransform: { value: new Tt() },
        bumpScale: { value: 1 },
      },
      normalmap: {
        normalMap: { value: null },
        normalMapTransform: { value: new Tt() },
        normalScale: { value: new xt(1, 1) },
      },
      displacementmap: {
        displacementMap: { value: null },
        displacementMapTransform: { value: new Tt() },
        displacementScale: { value: 1 },
        displacementBias: { value: 0 },
      },
      emissivemap: {
        emissiveMap: { value: null },
        emissiveMapTransform: { value: new Tt() },
      },
      metalnessmap: {
        metalnessMap: { value: null },
        metalnessMapTransform: { value: new Tt() },
      },
      roughnessmap: {
        roughnessMap: { value: null },
        roughnessMapTransform: { value: new Tt() },
      },
      gradientmap: { gradientMap: { value: null } },
      fog: {
        fogDensity: { value: 25e-5 },
        fogNear: { value: 1 },
        fogFar: { value: 2e3 },
        fogColor: { value: new pn(16777215) },
      },
      lights: {
        ambientLightColor: { value: [] },
        lightProbe: { value: [] },
        directionalLights: {
          value: [],
          properties: { direction: {}, color: {} },
        },
        directionalLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        directionalShadowMap: { value: [] },
        directionalShadowMatrix: { value: [] },
        spotLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {},
          },
        },
        spotLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        spotLightMap: { value: [] },
        spotShadowMap: { value: [] },
        spotLightMatrix: { value: [] },
        pointLights: {
          value: [],
          properties: { color: {}, position: {}, decay: {}, distance: {} },
        },
        pointLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {},
          },
        },
        pointShadowMap: { value: [] },
        pointShadowMatrix: { value: [] },
        hemisphereLights: {
          value: [],
          properties: { direction: {}, skyColor: {}, groundColor: {} },
        },
        rectAreaLights: {
          value: [],
          properties: { color: {}, position: {}, width: {}, height: {} },
        },
        ltc_1: { value: null },
        ltc_2: { value: null },
      },
      points: {
        diffuse: { value: new pn(16777215) },
        opacity: { value: 1 },
        size: { value: 1 },
        scale: { value: 1 },
        map: { value: null },
        alphaMap: { value: null },
        alphaMapTransform: { value: new Tt() },
        alphaTest: { value: 0 },
        uvTransform: { value: new Tt() },
      },
      sprite: {
        diffuse: { value: new pn(16777215) },
        opacity: { value: 1 },
        center: { value: new xt(0.5, 0.5) },
        rotation: { value: 0 },
        map: { value: null },
        mapTransform: { value: new Tt() },
        alphaMap: { value: null },
        alphaMapTransform: { value: new Tt() },
        alphaTest: { value: 0 },
      },
    },
    Ti = {
      basic: {
        uniforms: $n([
          xi.common,
          xi.specularmap,
          xi.envmap,
          xi.aomap,
          xi.lightmap,
          xi.fog,
        ]),
        vertexShader: yi.meshbasic_vert,
        fragmentShader: yi.meshbasic_frag,
      },
      lambert: {
        uniforms: $n([
          xi.common,
          xi.specularmap,
          xi.envmap,
          xi.aomap,
          xi.lightmap,
          xi.emissivemap,
          xi.bumpmap,
          xi.normalmap,
          xi.displacementmap,
          xi.fog,
          xi.lights,
          { emissive: { value: new pn(0) } },
        ]),
        vertexShader: yi.meshlambert_vert,
        fragmentShader: yi.meshlambert_frag,
      },
      phong: {
        uniforms: $n([
          xi.common,
          xi.specularmap,
          xi.envmap,
          xi.aomap,
          xi.lightmap,
          xi.emissivemap,
          xi.bumpmap,
          xi.normalmap,
          xi.displacementmap,
          xi.fog,
          xi.lights,
          {
            emissive: { value: new pn(0) },
            specular: { value: new pn(1118481) },
            shininess: { value: 30 },
          },
        ]),
        vertexShader: yi.meshphong_vert,
        fragmentShader: yi.meshphong_frag,
      },
      standard: {
        uniforms: $n([
          xi.common,
          xi.envmap,
          xi.aomap,
          xi.lightmap,
          xi.emissivemap,
          xi.bumpmap,
          xi.normalmap,
          xi.displacementmap,
          xi.roughnessmap,
          xi.metalnessmap,
          xi.fog,
          xi.lights,
          {
            emissive: { value: new pn(0) },
            roughness: { value: 1 },
            metalness: { value: 0 },
            envMapIntensity: { value: 1 },
          },
        ]),
        vertexShader: yi.meshphysical_vert,
        fragmentShader: yi.meshphysical_frag,
      },
      toon: {
        uniforms: $n([
          xi.common,
          xi.aomap,
          xi.lightmap,
          xi.emissivemap,
          xi.bumpmap,
          xi.normalmap,
          xi.displacementmap,
          xi.gradientmap,
          xi.fog,
          xi.lights,
          { emissive: { value: new pn(0) } },
        ]),
        vertexShader: yi.meshtoon_vert,
        fragmentShader: yi.meshtoon_frag,
      },
      matcap: {
        uniforms: $n([
          xi.common,
          xi.bumpmap,
          xi.normalmap,
          xi.displacementmap,
          xi.fog,
          { matcap: { value: null } },
        ]),
        vertexShader: yi.meshmatcap_vert,
        fragmentShader: yi.meshmatcap_frag,
      },
      points: {
        uniforms: $n([xi.points, xi.fog]),
        vertexShader: yi.points_vert,
        fragmentShader: yi.points_frag,
      },
      dashed: {
        uniforms: $n([
          xi.common,
          xi.fog,
          {
            scale: { value: 1 },
            dashSize: { value: 1 },
            totalSize: { value: 2 },
          },
        ]),
        vertexShader: yi.linedashed_vert,
        fragmentShader: yi.linedashed_frag,
      },
      depth: {
        uniforms: $n([xi.common, xi.displacementmap]),
        vertexShader: yi.depth_vert,
        fragmentShader: yi.depth_frag,
      },
      normal: {
        uniforms: $n([
          xi.common,
          xi.bumpmap,
          xi.normalmap,
          xi.displacementmap,
          { opacity: { value: 1 } },
        ]),
        vertexShader: yi.meshnormal_vert,
        fragmentShader: yi.meshnormal_frag,
      },
      sprite: {
        uniforms: $n([xi.sprite, xi.fog]),
        vertexShader: yi.sprite_vert,
        fragmentShader: yi.sprite_frag,
      },
      background: {
        uniforms: {
          uvTransform: { value: new Tt() },
          t2D: { value: null },
          backgroundIntensity: { value: 1 },
        },
        vertexShader: yi.background_vert,
        fragmentShader: yi.background_frag,
      },
      backgroundCube: {
        uniforms: {
          envMap: { value: null },
          flipEnvMap: { value: -1 },
          backgroundBlurriness: { value: 0 },
          backgroundIntensity: { value: 1 },
        },
        vertexShader: yi.backgroundCube_vert,
        fragmentShader: yi.backgroundCube_frag,
      },
      cube: {
        uniforms: {
          tCube: { value: null },
          tFlip: { value: -1 },
          opacity: { value: 1 },
        },
        vertexShader: yi.cube_vert,
        fragmentShader: yi.cube_frag,
      },
      equirect: {
        uniforms: { tEquirect: { value: null } },
        vertexShader: yi.equirect_vert,
        fragmentShader: yi.equirect_frag,
      },
      distanceRGBA: {
        uniforms: $n([
          xi.common,
          xi.displacementmap,
          {
            referencePosition: { value: new Yt() },
            nearDistance: { value: 1 },
            farDistance: { value: 1e3 },
          },
        ]),
        vertexShader: yi.distanceRGBA_vert,
        fragmentShader: yi.distanceRGBA_frag,
      },
      shadow: {
        uniforms: $n([
          xi.lights,
          xi.fog,
          { color: { value: new pn(0) }, opacity: { value: 1 } },
        ]),
        vertexShader: yi.shadow_vert,
        fragmentShader: yi.shadow_frag,
      },
    };
  Ti.physical = {
    uniforms: $n([
      Ti.standard.uniforms,
      {
        clearcoat: { value: 0 },
        clearcoatMap: { value: null },
        clearcoatMapTransform: { value: new Tt() },
        clearcoatNormalMap: { value: null },
        clearcoatNormalMapTransform: { value: new Tt() },
        clearcoatNormalScale: { value: new xt(1, 1) },
        clearcoatRoughness: { value: 0 },
        clearcoatRoughnessMap: { value: null },
        clearcoatRoughnessMapTransform: { value: new Tt() },
        iridescence: { value: 0 },
        iridescenceMap: { value: null },
        iridescenceMapTransform: { value: new Tt() },
        iridescenceIOR: { value: 1.3 },
        iridescenceThicknessMinimum: { value: 100 },
        iridescenceThicknessMaximum: { value: 400 },
        iridescenceThicknessMap: { value: null },
        iridescenceThicknessMapTransform: { value: new Tt() },
        sheen: { value: 0 },
        sheenColor: { value: new pn(0) },
        sheenColorMap: { value: null },
        sheenColorMapTransform: { value: new Tt() },
        sheenRoughness: { value: 1 },
        sheenRoughnessMap: { value: null },
        sheenRoughnessMapTransform: { value: new Tt() },
        transmission: { value: 0 },
        transmissionMap: { value: null },
        transmissionMapTransform: { value: new Tt() },
        transmissionSamplerSize: { value: new xt() },
        transmissionSamplerMap: { value: null },
        thickness: { value: 0 },
        thicknessMap: { value: null },
        thicknessMapTransform: { value: new Tt() },
        attenuationDistance: { value: 0 },
        attenuationColor: { value: new pn(0) },
        specularColor: { value: new pn(1, 1, 1) },
        specularColorMap: { value: null },
        specularColorMapTransform: { value: new Tt() },
        specularIntensity: { value: 1 },
        specularIntensityMap: { value: null },
        specularIntensityMapTransform: { value: new Tt() },
        anisotropyVector: { value: new xt() },
        anisotropyMap: { value: null },
        anisotropyMapTransform: { value: new Tt() },
      },
    ]),
    vertexShader: yi.meshphysical_vert,
    fragmentShader: yi.meshphysical_frag,
  };
  const Mi = { r: 0, b: 0, g: 0 };
  function Si(t, e, n, i, r, s, a) {
    const o = new pn(0);
    let l,
      c,
      h = !0 === s ? 0 : 1,
      u = null,
      d = 0,
      p = null;
    function f(e, n) {
      e.getRGB(Mi, ti(t)), i.buffers.color.setClear(Mi.r, Mi.g, Mi.b, n, a);
    }
    return {
      getClearColor: function () {
        return o;
      },
      setClearColor: function (t, e = 1) {
        o.set(t), (h = e), f(o, h);
      },
      getClearAlpha: function () {
        return h;
      },
      setClearAlpha: function (t) {
        (h = t), f(o, h);
      },
      render: function (s, m) {
        let g = !1,
          _ = !0 === m.isScene ? m.background : null;
        _ && _.isTexture && (_ = (m.backgroundBlurriness > 0 ? n : e).get(_)),
          null === _ ? f(o, h) : _ && _.isColor && (f(_, 1), (g = !0));
        const v = t.xr.getEnvironmentBlendMode();
        "additive" === v
          ? i.buffers.color.setClear(0, 0, 0, 1, a)
          : "alpha-blend" === v && i.buffers.color.setClear(0, 0, 0, 0, a),
          (t.autoClear || g) &&
            t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
          _ && (_.isCubeTexture || _.mapping === y)
            ? (void 0 === c &&
                ((c = new Kn(
                  new Jn(1, 1, 1),
                  new ni({
                    name: "BackgroundCubeMaterial",
                    uniforms: Qn(Ti.backgroundCube.uniforms),
                    vertexShader: Ti.backgroundCube.vertexShader,
                    fragmentShader: Ti.backgroundCube.fragmentShader,
                    side: 1,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                  })
                )),
                c.geometry.deleteAttribute("normal"),
                c.geometry.deleteAttribute("uv"),
                (c.onBeforeRender = function (t, e, n) {
                  this.matrixWorld.copyPosition(n.matrixWorld);
                }),
                Object.defineProperty(c.material, "envMap", {
                  get: function () {
                    return this.uniforms.envMap.value;
                  },
                }),
                r.update(c)),
              (c.material.uniforms.envMap.value = _),
              (c.material.uniforms.flipEnvMap.value =
                _.isCubeTexture && !1 === _.isRenderTargetTexture ? -1 : 1),
              (c.material.uniforms.backgroundBlurriness.value =
                m.backgroundBlurriness),
              (c.material.uniforms.backgroundIntensity.value =
                m.backgroundIntensity),
              (c.material.toneMapped = Dt.getTransfer(_.colorSpace) !== Q),
              (u === _ && d === _.version && p === t.toneMapping) ||
                ((c.material.needsUpdate = !0),
                (u = _),
                (d = _.version),
                (p = t.toneMapping)),
              c.layers.enableAll(),
              s.unshift(c, c.geometry, c.material, 0, 0, null))
            : _ &&
              _.isTexture &&
              (void 0 === l &&
                ((l = new Kn(
                  new vi(2, 2),
                  new ni({
                    name: "BackgroundMaterial",
                    uniforms: Qn(Ti.background.uniforms),
                    vertexShader: Ti.background.vertexShader,
                    fragmentShader: Ti.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                  })
                )),
                l.geometry.deleteAttribute("normal"),
                Object.defineProperty(l.material, "map", {
                  get: function () {
                    return this.uniforms.t2D.value;
                  },
                }),
                r.update(l)),
              (l.material.uniforms.t2D.value = _),
              (l.material.uniforms.backgroundIntensity.value =
                m.backgroundIntensity),
              (l.material.toneMapped = Dt.getTransfer(_.colorSpace) !== Q),
              !0 === _.matrixAutoUpdate && _.updateMatrix(),
              l.material.uniforms.uvTransform.value.copy(_.matrix),
              (u === _ && d === _.version && p === t.toneMapping) ||
                ((l.material.needsUpdate = !0),
                (u = _),
                (d = _.version),
                (p = t.toneMapping)),
              l.layers.enableAll(),
              s.unshift(l, l.geometry, l.material, 0, 0, null));
      },
    };
  }
  function bi(t, e, n, i) {
    const r = t.getParameter(t.MAX_VERTEX_ATTRIBS),
      s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
      a = i.isWebGL2 || null !== s,
      o = {},
      l = p(null);
    let c = l,
      h = !1;
    function u(e) {
      return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e);
    }
    function d(e) {
      return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e);
    }
    function p(t) {
      const e = [],
        n = [],
        i = [];
      for (let t = 0; t < r; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0);
      return {
        geometry: null,
        program: null,
        wireframe: !1,
        newAttributes: e,
        enabledAttributes: n,
        attributeDivisors: i,
        object: t,
        attributes: {},
        index: null,
      };
    }
    function f() {
      const t = c.newAttributes;
      for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
    }
    function m(t) {
      g(t, 0);
    }
    function g(n, r) {
      const s = c.newAttributes,
        a = c.enabledAttributes,
        o = c.attributeDivisors;
      (s[n] = 1),
        0 === a[n] && (t.enableVertexAttribArray(n), (a[n] = 1)),
        o[n] !== r &&
          ((i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
            i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
          ](n, r),
          (o[n] = r));
    }
    function _() {
      const e = c.newAttributes,
        n = c.enabledAttributes;
      for (let i = 0, r = n.length; i < r; i++)
        n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
    }
    function v(e, n, i, r, s, a, o) {
      !0 === o
        ? t.vertexAttribIPointer(e, n, i, s, a)
        : t.vertexAttribPointer(e, n, i, r, s, a);
    }
    function y() {
      x(), (h = !0), c !== l && ((c = l), u(c.object));
    }
    function x() {
      (l.geometry = null), (l.program = null), (l.wireframe = !1);
    }
    return {
      setup: function (r, l, d, y, x) {
        let T = !1;
        if (a) {
          const e = (function (e, n, r) {
            const a = !0 === r.wireframe;
            let l = o[e.id];
            void 0 === l && ((l = {}), (o[e.id] = l));
            let c = l[n.id];
            void 0 === c && ((c = {}), (l[n.id] = c));
            let h = c[a];
            return (
              void 0 === h &&
                ((h = p(
                  i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()
                )),
                (c[a] = h)),
              h
            );
          })(y, d, l);
          c !== e && ((c = e), u(c.object)),
            (T = (function (t, e, n, i) {
              const r = c.attributes,
                s = e.attributes;
              let a = 0;
              const o = n.getAttributes();
              for (const e in o)
                if (o[e].location >= 0) {
                  const n = r[e];
                  let i = s[e];
                  if (
                    (void 0 === i &&
                      ("instanceMatrix" === e &&
                        t.instanceMatrix &&
                        (i = t.instanceMatrix),
                      "instanceColor" === e &&
                        t.instanceColor &&
                        (i = t.instanceColor)),
                    void 0 === n)
                  )
                    return !0;
                  if (n.attribute !== i) return !0;
                  if (i && n.data !== i.data) return !0;
                  a++;
                }
              return c.attributesNum !== a || c.index !== i;
            })(r, y, d, x)),
            T &&
              (function (t, e, n, i) {
                const r = {},
                  s = e.attributes;
                let a = 0;
                const o = n.getAttributes();
                for (const e in o)
                  if (o[e].location >= 0) {
                    let n = s[e];
                    void 0 === n &&
                      ("instanceMatrix" === e &&
                        t.instanceMatrix &&
                        (n = t.instanceMatrix),
                      "instanceColor" === e &&
                        t.instanceColor &&
                        (n = t.instanceColor));
                    const i = {};
                    (i.attribute = n),
                      n && n.data && (i.data = n.data),
                      (r[e] = i),
                      a++;
                  }
                (c.attributes = r), (c.attributesNum = a), (c.index = i);
              })(r, y, d, x);
        } else {
          const t = !0 === l.wireframe;
          (c.geometry === y.id && c.program === d.id && c.wireframe === t) ||
            ((c.geometry = y.id),
            (c.program = d.id),
            (c.wireframe = t),
            (T = !0));
        }
        null !== x && n.update(x, t.ELEMENT_ARRAY_BUFFER),
          (T || h) &&
            ((h = !1),
            (function (r, s, a, o) {
              if (
                !1 === i.isWebGL2 &&
                (r.isInstancedMesh || o.isInstancedBufferGeometry) &&
                null === e.get("ANGLE_instanced_arrays")
              )
                return;
              f();
              const l = o.attributes,
                c = a.getAttributes(),
                h = s.defaultAttributeValues;
              for (const e in c) {
                const s = c[e];
                if (s.location >= 0) {
                  let a = l[e];
                  if (
                    (void 0 === a &&
                      ("instanceMatrix" === e &&
                        r.instanceMatrix &&
                        (a = r.instanceMatrix),
                      "instanceColor" === e &&
                        r.instanceColor &&
                        (a = r.instanceColor)),
                    void 0 !== a)
                  ) {
                    const e = a.normalized,
                      l = a.itemSize,
                      c = n.get(a);
                    if (void 0 === c) continue;
                    const h = c.buffer,
                      u = c.type,
                      d = c.bytesPerElement,
                      p =
                        !0 === i.isWebGL2 &&
                        (u === t.INT ||
                          u === t.UNSIGNED_INT ||
                          1013 === a.gpuType);
                    if (a.isInterleavedBufferAttribute) {
                      const n = a.data,
                        i = n.stride,
                        c = a.offset;
                      if (n.isInstancedInterleavedBuffer) {
                        for (let t = 0; t < s.locationSize; t++)
                          g(s.location + t, n.meshPerAttribute);
                        !0 !== r.isInstancedMesh &&
                          void 0 === o._maxInstanceCount &&
                          (o._maxInstanceCount = n.meshPerAttribute * n.count);
                      } else
                        for (let t = 0; t < s.locationSize; t++)
                          m(s.location + t);
                      t.bindBuffer(t.ARRAY_BUFFER, h);
                      for (let t = 0; t < s.locationSize; t++)
                        v(
                          s.location + t,
                          l / s.locationSize,
                          u,
                          e,
                          i * d,
                          (c + (l / s.locationSize) * t) * d,
                          p
                        );
                    } else {
                      if (a.isInstancedBufferAttribute) {
                        for (let t = 0; t < s.locationSize; t++)
                          g(s.location + t, a.meshPerAttribute);
                        !0 !== r.isInstancedMesh &&
                          void 0 === o._maxInstanceCount &&
                          (o._maxInstanceCount = a.meshPerAttribute * a.count);
                      } else
                        for (let t = 0; t < s.locationSize; t++)
                          m(s.location + t);
                      t.bindBuffer(t.ARRAY_BUFFER, h);
                      for (let t = 0; t < s.locationSize; t++)
                        v(
                          s.location + t,
                          l / s.locationSize,
                          u,
                          e,
                          l * d,
                          (l / s.locationSize) * t * d,
                          p
                        );
                    }
                  } else if (void 0 !== h) {
                    const n = h[e];
                    if (void 0 !== n)
                      switch (n.length) {
                        case 2:
                          t.vertexAttrib2fv(s.location, n);
                          break;
                        case 3:
                          t.vertexAttrib3fv(s.location, n);
                          break;
                        case 4:
                          t.vertexAttrib4fv(s.location, n);
                          break;
                        default:
                          t.vertexAttrib1fv(s.location, n);
                      }
                  }
                }
              }
              _();
            })(r, l, d, y),
            null !== x &&
              t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(x).buffer));
      },
      reset: y,
      resetDefaultState: x,
      dispose: function () {
        y();
        for (const t in o) {
          const e = o[t];
          for (const t in e) {
            const n = e[t];
            for (const t in n) d(n[t].object), delete n[t];
            delete e[t];
          }
          delete o[t];
        }
      },
      releaseStatesOfGeometry: function (t) {
        if (void 0 === o[t.id]) return;
        const e = o[t.id];
        for (const t in e) {
          const n = e[t];
          for (const t in n) d(n[t].object), delete n[t];
          delete e[t];
        }
        delete o[t.id];
      },
      releaseStatesOfProgram: function (t) {
        for (const e in o) {
          const n = o[e];
          if (void 0 === n[t.id]) continue;
          const i = n[t.id];
          for (const t in i) d(i[t].object), delete i[t];
          delete n[t.id];
        }
      },
      initAttributes: f,
      enableAttribute: m,
      disableUnusedAttributes: _,
    };
  }
  function Ei(t, e, n, i) {
    const r = i.isWebGL2;
    let s;
    (this.setMode = function (t) {
      s = t;
    }),
      (this.render = function (e, i) {
        t.drawArrays(s, e, i), n.update(i, s, 1);
      }),
      (this.renderInstances = function (i, a, o) {
        if (0 === o) return;
        let l, c;
        if (r) (l = t), (c = "drawArraysInstanced");
        else if (
          ((l = e.get("ANGLE_instanced_arrays")),
          (c = "drawArraysInstancedANGLE"),
          null === l)
        )
          return void console.error(
            "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
          );
        l[c](s, i, a, o), n.update(a, s, o);
      }),
      (this.renderMultiDraw = function (t, i, r) {
        if (0 === r) return;
        const a = e.get("WEBGL_multi_draw");
        if (null === a) for (let e = 0; e < r; e++) this.render(t[e], i[e]);
        else {
          a.multiDrawArraysWEBGL(s, t, 0, i, 0, r);
          let e = 0;
          for (let t = 0; t < r; t++) e += i[t];
          n.update(e, s, 1);
        }
      });
  }
  function wi(t, e, n) {
    let i;
    function r(e) {
      if ("highp" === e) {
        if (
          t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision >
            0 &&
          t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT)
            .precision > 0
        )
          return "highp";
        e = "mediump";
      }
      return "mediump" === e &&
        t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision >
          0 &&
        t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT)
          .precision > 0
        ? "mediump"
        : "lowp";
    }
    const s =
      "undefined" != typeof WebGL2RenderingContext &&
      "WebGL2RenderingContext" === t.constructor.name;
    let a = void 0 !== n.precision ? n.precision : "highp";
    const o = r(a);
    o !== a &&
      (console.warn(
        "THREE.WebGLRenderer:",
        a,
        "not supported, using",
        o,
        "instead."
      ),
      (a = o));
    const l = s || e.has("WEBGL_draw_buffers"),
      c = !0 === n.logarithmicDepthBuffer,
      h = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
      u = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
      d = t.getParameter(t.MAX_TEXTURE_SIZE),
      p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
      f = t.getParameter(t.MAX_VERTEX_ATTRIBS),
      m = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
      g = t.getParameter(t.MAX_VARYING_VECTORS),
      _ = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
      v = u > 0,
      y = s || e.has("OES_texture_float");
    return {
      isWebGL2: s,
      drawBuffers: l,
      getMaxAnisotropy: function () {
        if (void 0 !== i) return i;
        if (!0 === e.has("EXT_texture_filter_anisotropic")) {
          const n = e.get("EXT_texture_filter_anisotropic");
          i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else i = 0;
        return i;
      },
      getMaxPrecision: r,
      precision: a,
      logarithmicDepthBuffer: c,
      maxTextures: h,
      maxVertexTextures: u,
      maxTextureSize: d,
      maxCubemapSize: p,
      maxAttributes: f,
      maxVertexUniforms: m,
      maxVaryings: g,
      maxFragmentUniforms: _,
      vertexTextures: v,
      floatFragmentTextures: y,
      floatVertexTextures: v && y,
      maxSamples: s ? t.getParameter(t.MAX_SAMPLES) : 0,
    };
  }
  function Ai(t) {
    const e = this;
    let n = null,
      i = 0,
      r = !1,
      s = !1;
    const a = new di(),
      o = new Tt(),
      l = { value: null, needsUpdate: !1 };
    function c(t, n, i, r) {
      const s = null !== t ? t.length : 0;
      let c = null;
      if (0 !== s) {
        if (((c = l.value), !0 !== r || null === c)) {
          const e = i + 4 * s,
            r = n.matrixWorldInverse;
          o.getNormalMatrix(r),
            (null === c || c.length < e) && (c = new Float32Array(e));
          for (let e = 0, n = i; e !== s; ++e, n += 4)
            a.copy(t[e]).applyMatrix4(r, o),
              a.normal.toArray(c, n),
              (c[n + 3] = a.constant);
        }
        (l.value = c), (l.needsUpdate = !0);
      }
      return (e.numPlanes = s), (e.numIntersection = 0), c;
    }
    (this.uniform = l),
      (this.numPlanes = 0),
      (this.numIntersection = 0),
      (this.init = function (t, e) {
        const n = 0 !== t.length || e || 0 !== i || r;
        return (r = e), (i = t.length), n;
      }),
      (this.beginShadows = function () {
        (s = !0), c(null);
      }),
      (this.endShadows = function () {
        s = !1;
      }),
      (this.setGlobalState = function (t, e) {
        n = c(t, e, 0);
      }),
      (this.setState = function (a, o, h) {
        const u = a.clippingPlanes,
          d = a.clipIntersection,
          p = a.clipShadows,
          f = t.get(a);
        if (!r || null === u || 0 === u.length || (s && !p))
          s
            ? c(null)
            : (l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
              (e.numPlanes = i),
              (e.numIntersection = 0));
        else {
          const t = s ? 0 : i,
            e = 4 * t;
          let r = f.clippingState || null;
          (l.value = r), (r = c(u, o, e, h));
          for (let t = 0; t !== e; ++t) r[t] = n[t];
          (f.clippingState = r),
            (this.numIntersection = d ? this.numPlanes : 0),
            (this.numPlanes += t);
        }
      });
  }
  function Ri(t) {
    let e = new WeakMap();
    function n(t, e) {
      return 303 === e ? (t.mapping = _) : 304 === e && (t.mapping = v), t;
    }
    function i(t) {
      const n = t.target;
      n.removeEventListener("dispose", i);
      const r = e.get(n);
      void 0 !== r && (e.delete(n), r.dispose());
    }
    return {
      get: function (r) {
        if (r && r.isTexture) {
          const s = r.mapping;
          if (303 === s || 304 === s) {
            if (e.has(r)) return n(e.get(r).texture, r.mapping);
            {
              const s = r.image;
              if (s && s.height > 0) {
                const a = new li(s.height / 2);
                return (
                  a.fromEquirectangularTexture(t, r),
                  e.set(r, a),
                  r.addEventListener("dispose", i),
                  n(a.texture, r.mapping)
                );
              }
              return null;
            }
          }
        }
        return r;
      },
      dispose: function () {
        e = new WeakMap();
      },
    };
  }
  class Ci extends ii {
    constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
      super(),
        (this.isOrthographicCamera = !0),
        (this.type = "OrthographicCamera"),
        (this.zoom = 1),
        (this.view = null),
        (this.left = t),
        (this.right = e),
        (this.top = n),
        (this.bottom = i),
        (this.near = r),
        (this.far = s),
        this.updateProjectionMatrix();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.left = t.left),
        (this.right = t.right),
        (this.top = t.top),
        (this.bottom = t.bottom),
        (this.near = t.near),
        (this.far = t.far),
        (this.zoom = t.zoom),
        (this.view = null === t.view ? null : Object.assign({}, t.view)),
        this
      );
    }
    setViewOffset(t, e, n, i, r, s) {
      null === this.view &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
        (this.view.enabled = !0),
        (this.view.fullWidth = t),
        (this.view.fullHeight = e),
        (this.view.offsetX = n),
        (this.view.offsetY = i),
        (this.view.width = r),
        (this.view.height = s),
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
      null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const t = (this.right - this.left) / (2 * this.zoom),
        e = (this.top - this.bottom) / (2 * this.zoom),
        n = (this.right + this.left) / 2,
        i = (this.top + this.bottom) / 2;
      let r = n - t,
        s = n + t,
        a = i + e,
        o = i - e;
      if (null !== this.view && this.view.enabled) {
        const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
          e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        (r += t * this.view.offsetX),
          (s = r + t * this.view.width),
          (a -= e * this.view.offsetY),
          (o = a - e * this.view.height);
      }
      this.projectionMatrix.makeOrthographic(
        r,
        s,
        a,
        o,
        this.near,
        this.far,
        this.coordinateSystem
      ),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        (e.object.zoom = this.zoom),
        (e.object.left = this.left),
        (e.object.right = this.right),
        (e.object.top = this.top),
        (e.object.bottom = this.bottom),
        (e.object.near = this.near),
        (e.object.far = this.far),
        null !== this.view && (e.object.view = Object.assign({}, this.view)),
        e
      );
    }
  }
  const Pi = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
    Li = new Ci(),
    Di = new pn();
  let Ii = null,
    Ui = 0,
    Ni = 0;
  const Oi = (1 + Math.sqrt(5)) / 2,
    Fi = 1 / Oi,
    ki = [
      new Yt(1, 1, 1),
      new Yt(-1, 1, 1),
      new Yt(1, 1, -1),
      new Yt(-1, 1, -1),
      new Yt(0, Oi, Fi),
      new Yt(0, Oi, -Fi),
      new Yt(Fi, 0, Oi),
      new Yt(-Fi, 0, Oi),
      new Yt(Oi, Fi, 0),
      new Yt(-Oi, Fi, 0),
    ];
  class zi {
    constructor(t) {
      (this._renderer = t),
        (this._pingPongRenderTarget = null),
        (this._lodMax = 0),
        (this._cubeSize = 0),
        (this._lodPlanes = []),
        (this._sizeLods = []),
        (this._sigmas = []),
        (this._blurMaterial = null),
        (this._cubemapMaterial = null),
        (this._equirectMaterial = null),
        this._compileMaterial(this._blurMaterial);
    }
    fromScene(t, e = 0, n = 0.1, i = 100) {
      (Ii = this._renderer.getRenderTarget()),
        (Ui = this._renderer.getActiveCubeFace()),
        (Ni = this._renderer.getActiveMipmapLevel()),
        this._setSize(256);
      const r = this._allocateTargets();
      return (
        (r.depthBuffer = !0),
        this._sceneToCubeUV(t, n, i, r),
        e > 0 && this._blur(r, 0, 0, e),
        this._applyPMREM(r),
        this._cleanup(r),
        r
      );
    }
    fromEquirectangular(t, e = null) {
      return this._fromTexture(t, e);
    }
    fromCubemap(t, e = null) {
      return this._fromTexture(t, e);
    }
    compileCubemapShader() {
      null === this._cubemapMaterial &&
        ((this._cubemapMaterial = Vi()),
        this._compileMaterial(this._cubemapMaterial));
    }
    compileEquirectangularShader() {
      null === this._equirectMaterial &&
        ((this._equirectMaterial = Gi()),
        this._compileMaterial(this._equirectMaterial));
    }
    dispose() {
      this._dispose(),
        null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
        null !== this._equirectMaterial && this._equirectMaterial.dispose();
    }
    _setSize(t) {
      (this._lodMax = Math.floor(Math.log2(t))),
        (this._cubeSize = Math.pow(2, this._lodMax));
    }
    _dispose() {
      null !== this._blurMaterial && this._blurMaterial.dispose(),
        null !== this._pingPongRenderTarget &&
          this._pingPongRenderTarget.dispose();
      for (let t = 0; t < this._lodPlanes.length; t++)
        this._lodPlanes[t].dispose();
    }
    _cleanup(t) {
      this._renderer.setRenderTarget(Ii, Ui, Ni),
        (t.scissorTest = !1),
        Hi(t, 0, 0, t.width, t.height);
    }
    _fromTexture(t, e) {
      t.mapping === _ || t.mapping === v
        ? this._setSize(
            0 === t.image.length
              ? 16
              : t.image[0].width || t.image[0].image.width
          )
        : this._setSize(t.image.width / 4),
        (Ii = this._renderer.getRenderTarget()),
        (Ui = this._renderer.getActiveCubeFace()),
        (Ni = this._renderer.getActiveMipmapLevel());
      const n = e || this._allocateTargets();
      return (
        this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
      );
    }
    _allocateTargets() {
      const t = 3 * Math.max(this._cubeSize, 112),
        e = 4 * this._cubeSize,
        n = {
          magFilter: w,
          minFilter: w,
          generateMipmaps: !1,
          type: D,
          format: U,
          colorSpace: Y,
          depthBuffer: !1,
        },
        i = Bi(t, e, n);
      if (
        null === this._pingPongRenderTarget ||
        this._pingPongRenderTarget.width !== t ||
        this._pingPongRenderTarget.height !== e
      ) {
        null !== this._pingPongRenderTarget && this._dispose(),
          (this._pingPongRenderTarget = Bi(t, e, n));
        const { _lodMax: i } = this;
        ({
          sizeLods: this._sizeLods,
          lodPlanes: this._lodPlanes,
          sigmas: this._sigmas,
        } = (function (t) {
          const e = [],
            n = [],
            i = [];
          let r = t;
          const s = t - 4 + 1 + Pi.length;
          for (let a = 0; a < s; a++) {
            const s = Math.pow(2, r);
            n.push(s);
            let o = 1 / s;
            a > t - 4 ? (o = Pi[a - t + 4 - 1]) : 0 === a && (o = 0), i.push(o);
            const l = 1 / (s - 2),
              c = -l,
              h = 1 + l,
              u = [c, c, h, c, h, h, c, c, h, h, c, h],
              d = 6,
              p = 6,
              f = 3,
              m = 2,
              g = 1,
              _ = new Float32Array(f * p * d),
              v = new Float32Array(m * p * d),
              y = new Float32Array(g * p * d);
            for (let t = 0; t < d; t++) {
              const e = ((t % 3) * 2) / 3 - 1,
                n = t > 2 ? 0 : -1,
                i = [
                  e,
                  n,
                  0,
                  e + 2 / 3,
                  n,
                  0,
                  e + 2 / 3,
                  n + 1,
                  0,
                  e,
                  n,
                  0,
                  e + 2 / 3,
                  n + 1,
                  0,
                  e,
                  n + 1,
                  0,
                ];
              _.set(i, f * p * t), v.set(u, m * p * t);
              const r = [t, t, t, t, t, t];
              y.set(r, g * p * t);
            }
            const x = new Ln();
            x.setAttribute("position", new xn(_, f)),
              x.setAttribute("uv", new xn(v, m)),
              x.setAttribute("faceIndex", new xn(y, g)),
              e.push(x),
              r > 4 && r--;
          }
          return { lodPlanes: e, sizeLods: n, sigmas: i };
        })(i)),
          (this._blurMaterial = (function (t, e, n) {
            const i = new Float32Array(20),
              r = new Yt(0, 1, 0);
            return new ni({
              name: "SphericalGaussianBlur",
              defines: {
                n: 20,
                CUBEUV_TEXEL_WIDTH: 1 / e,
                CUBEUV_TEXEL_HEIGHT: 1 / n,
                CUBEUV_MAX_MIP: `${t}.0`,
              },
              uniforms: {
                envMap: { value: null },
                samples: { value: 1 },
                weights: { value: i },
                latitudinal: { value: !1 },
                dTheta: { value: 0 },
                mipInt: { value: 0 },
                poleAxis: { value: r },
              },
              vertexShader:
                "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
              fragmentShader:
                "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
              blending: 0,
              depthTest: !1,
              depthWrite: !1,
            });
          })(i, t, e));
      }
      return i;
    }
    _compileMaterial(t) {
      const e = new Kn(this._lodPlanes[0], t);
      this._renderer.compile(e, Li);
    }
    _sceneToCubeUV(t, e, n, i) {
      const r = new ri(90, 1, e, n),
        s = [1, -1, 1, 1, 1, 1],
        a = [1, 1, 1, -1, -1, -1],
        o = this._renderer,
        l = o.autoClear,
        h = o.toneMapping;
      o.getClearColor(Di), (o.toneMapping = c), (o.autoClear = !1);
      const u = new _n({
          name: "PMREM.Background",
          side: 1,
          depthWrite: !1,
          depthTest: !1,
        }),
        d = new Kn(new Jn(), u);
      let p = !1;
      const f = t.background;
      f
        ? f.isColor && (u.color.copy(f), (t.background = null), (p = !0))
        : (u.color.copy(Di), (p = !0));
      for (let e = 0; e < 6; e++) {
        const n = e % 3;
        0 === n
          ? (r.up.set(0, s[e], 0), r.lookAt(a[e], 0, 0))
          : 1 === n
          ? (r.up.set(0, 0, s[e]), r.lookAt(0, a[e], 0))
          : (r.up.set(0, s[e], 0), r.lookAt(0, 0, a[e]));
        const l = this._cubeSize;
        Hi(i, n * l, e > 2 ? l : 0, l, l),
          o.setRenderTarget(i),
          p && o.render(d, r),
          o.render(t, r);
      }
      d.geometry.dispose(),
        d.material.dispose(),
        (o.toneMapping = h),
        (o.autoClear = l),
        (t.background = f);
    }
    _textureToCubeUV(t, e) {
      const n = this._renderer,
        i = t.mapping === _ || t.mapping === v;
      i
        ? (null === this._cubemapMaterial && (this._cubemapMaterial = Vi()),
          (this._cubemapMaterial.uniforms.flipEnvMap.value =
            !1 === t.isRenderTargetTexture ? -1 : 1))
        : null === this._equirectMaterial && (this._equirectMaterial = Gi());
      const r = i ? this._cubemapMaterial : this._equirectMaterial,
        s = new Kn(this._lodPlanes[0], r);
      r.uniforms.envMap.value = t;
      const a = this._cubeSize;
      Hi(e, 0, 0, 3 * a, 2 * a), n.setRenderTarget(e), n.render(s, Li);
    }
    _applyPMREM(t) {
      const e = this._renderer,
        n = e.autoClear;
      e.autoClear = !1;
      for (let e = 1; e < this._lodPlanes.length; e++) {
        const n = Math.sqrt(
            this._sigmas[e] * this._sigmas[e] -
              this._sigmas[e - 1] * this._sigmas[e - 1]
          ),
          i = ki[(e - 1) % ki.length];
        this._blur(t, e - 1, e, n, i);
      }
      e.autoClear = n;
    }
    _blur(t, e, n, i, r) {
      const s = this._pingPongRenderTarget;
      this._halfBlur(t, s, e, n, i, "latitudinal", r),
        this._halfBlur(s, t, n, n, i, "longitudinal", r);
    }
    _halfBlur(t, e, n, i, r, s, a) {
      const o = this._renderer,
        l = this._blurMaterial;
      "latitudinal" !== s &&
        "longitudinal" !== s &&
        console.error(
          "blur direction must be either latitudinal or longitudinal!"
        );
      const c = new Kn(this._lodPlanes[i], l),
        h = l.uniforms,
        u = this._sizeLods[n] - 1,
        d = isFinite(r) ? Math.PI / (2 * u) : (2 * Math.PI) / 39,
        p = r / d,
        f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
      f > 20 &&
        console.warn(
          `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`
        );
      const m = [];
      let g = 0;
      for (let t = 0; t < 20; ++t) {
        const e = t / p,
          n = Math.exp((-e * e) / 2);
        m.push(n), 0 === t ? (g += n) : t < f && (g += 2 * n);
      }
      for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
      (h.envMap.value = t.texture),
        (h.samples.value = f),
        (h.weights.value = m),
        (h.latitudinal.value = "latitudinal" === s),
        a && (h.poleAxis.value = a);
      const { _lodMax: _ } = this;
      (h.dTheta.value = d), (h.mipInt.value = _ - n);
      const v = this._sizeLods[i];
      Hi(
        e,
        3 * v * (i > _ - 4 ? i - _ + 4 : 0),
        4 * (this._cubeSize - v),
        3 * v,
        2 * v
      ),
        o.setRenderTarget(e),
        o.render(c, Li);
    }
  }
  function Bi(t, e, n) {
    const i = new Wt(t, e, n);
    return (
      (i.texture.mapping = y),
      (i.texture.name = "PMREM.cubeUv"),
      (i.scissorTest = !0),
      i
    );
  }
  function Hi(t, e, n, i, r) {
    t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
  }
  function Gi() {
    return new ni({
      name: "EquirectangularToCubeUV",
      uniforms: { envMap: { value: null } },
      vertexShader:
        "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
      fragmentShader:
        "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
      blending: 0,
      depthTest: !1,
      depthWrite: !1,
    });
  }
  function Vi() {
    return new ni({
      name: "CubemapToCubeUV",
      uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
      vertexShader:
        "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
      fragmentShader:
        "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
      blending: 0,
      depthTest: !1,
      depthWrite: !1,
    });
  }
  function Wi(t) {
    let e = new WeakMap(),
      n = null;
    function i(t) {
      const n = t.target;
      n.removeEventListener("dispose", i);
      const r = e.get(n);
      void 0 !== r && (e.delete(n), r.dispose());
    }
    return {
      get: function (r) {
        if (r && r.isTexture) {
          const s = r.mapping,
            a = 303 === s || 304 === s,
            o = s === _ || s === v;
          if (a || o) {
            if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
              r.needsPMREMUpdate = !1;
              let i = e.get(r);
              return (
                null === n && (n = new zi(t)),
                (i = a ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i)),
                e.set(r, i),
                i.texture
              );
            }
            if (e.has(r)) return e.get(r).texture;
            {
              const s = r.image;
              if (
                (a && s && s.height > 0) ||
                (o &&
                  s &&
                  (function (t) {
                    let e = 0;
                    for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                    return 6 === e;
                  })(s))
              ) {
                null === n && (n = new zi(t));
                const s = a ? n.fromEquirectangular(r) : n.fromCubemap(r);
                return e.set(r, s), r.addEventListener("dispose", i), s.texture;
              }
              return null;
            }
          }
        }
        return r;
      },
      dispose: function () {
        (e = new WeakMap()), null !== n && (n.dispose(), (n = null));
      },
    };
  }
  function Xi(t) {
    const e = {};
    function n(n) {
      if (void 0 !== e[n]) return e[n];
      let i;
      switch (n) {
        case "WEBGL_depth_texture":
          i =
            t.getExtension("WEBGL_depth_texture") ||
            t.getExtension("MOZ_WEBGL_depth_texture") ||
            t.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          i =
            t.getExtension("EXT_texture_filter_anisotropic") ||
            t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
            t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          i =
            t.getExtension("WEBGL_compressed_texture_s3tc") ||
            t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
            t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          i =
            t.getExtension("WEBGL_compressed_texture_pvrtc") ||
            t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          i = t.getExtension(n);
      }
      return (e[n] = i), i;
    }
    return {
      has: function (t) {
        return null !== n(t);
      },
      init: function (t) {
        t.isWebGL2
          ? (n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance"))
          : (n("WEBGL_depth_texture"),
            n("OES_texture_float"),
            n("OES_texture_half_float"),
            n("OES_texture_half_float_linear"),
            n("OES_standard_derivatives"),
            n("OES_element_index_uint"),
            n("OES_vertex_array_object"),
            n("ANGLE_instanced_arrays")),
          n("OES_texture_float_linear"),
          n("EXT_color_buffer_half_float"),
          n("WEBGL_multisampled_render_to_texture");
      },
      get: function (t) {
        const e = n(t);
        return (
          null === e &&
            console.warn(
              "THREE.WebGLRenderer: " + t + " extension not supported."
            ),
          e
        );
      },
    };
  }
  function ji(t, e, n, i) {
    const r = {},
      s = new WeakMap();
    function a(t) {
      const o = t.target;
      null !== o.index && e.remove(o.index);
      for (const t in o.attributes) e.remove(o.attributes[t]);
      for (const t in o.morphAttributes) {
        const n = o.morphAttributes[t];
        for (let t = 0, i = n.length; t < i; t++) e.remove(n[t]);
      }
      o.removeEventListener("dispose", a), delete r[o.id];
      const l = s.get(o);
      l && (e.remove(l), s.delete(o)),
        i.releaseStatesOfGeometry(o),
        !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
        n.memory.geometries--;
    }
    function o(t) {
      const n = [],
        i = t.index,
        r = t.attributes.position;
      let a = 0;
      if (null !== i) {
        const t = i.array;
        a = i.version;
        for (let e = 0, i = t.length; e < i; e += 3) {
          const i = t[e + 0],
            r = t[e + 1],
            s = t[e + 2];
          n.push(i, r, r, s, s, i);
        }
      } else {
        if (void 0 === r) return;
        {
          const t = r.array;
          a = r.version;
          for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
            const t = e + 0,
              i = e + 1,
              r = e + 2;
            n.push(t, i, i, r, r, t);
          }
        }
      }
      const o = new (St(n) ? Mn : Tn)(n, 1);
      o.version = a;
      const l = s.get(t);
      l && e.remove(l), s.set(t, o);
    }
    return {
      get: function (t, e) {
        return (
          !0 === r[e.id] ||
            (e.addEventListener("dispose", a),
            (r[e.id] = !0),
            n.memory.geometries++),
          e
        );
      },
      update: function (n) {
        const i = n.attributes;
        for (const n in i) e.update(i[n], t.ARRAY_BUFFER);
        const r = n.morphAttributes;
        for (const n in r) {
          const i = r[n];
          for (let n = 0, r = i.length; n < r; n++)
            e.update(i[n], t.ARRAY_BUFFER);
        }
      },
      getWireframeAttribute: function (t) {
        const e = s.get(t);
        if (e) {
          const n = t.index;
          null !== n && e.version < n.version && o(t);
        } else o(t);
        return s.get(t);
      },
    };
  }
  function qi(t, e, n, i) {
    const r = i.isWebGL2;
    let s, a, o;
    (this.setMode = function (t) {
      s = t;
    }),
      (this.setIndex = function (t) {
        (a = t.type), (o = t.bytesPerElement);
      }),
      (this.render = function (e, i) {
        t.drawElements(s, i, a, e * o), n.update(i, s, 1);
      }),
      (this.renderInstances = function (i, l, c) {
        if (0 === c) return;
        let h, u;
        if (r) (h = t), (u = "drawElementsInstanced");
        else if (
          ((h = e.get("ANGLE_instanced_arrays")),
          (u = "drawElementsInstancedANGLE"),
          null === h)
        )
          return void console.error(
            "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
          );
        h[u](s, l, a, i * o, c), n.update(l, s, c);
      }),
      (this.renderMultiDraw = function (t, i, r) {
        if (0 === r) return;
        const l = e.get("WEBGL_multi_draw");
        if (null === l) for (let e = 0; e < r; e++) this.render(t[e] / o, i[e]);
        else {
          l.multiDrawElementsWEBGL(s, i, 0, a, t, 0, r);
          let e = 0;
          for (let t = 0; t < r; t++) e += i[t];
          n.update(e, s, 1);
        }
      });
  }
  function Yi(t) {
    const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return {
      memory: { geometries: 0, textures: 0 },
      render: e,
      programs: null,
      autoReset: !0,
      reset: function () {
        (e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0);
      },
      update: function (n, i, r) {
        switch ((e.calls++, i)) {
          case t.TRIANGLES:
            e.triangles += r * (n / 3);
            break;
          case t.LINES:
            e.lines += r * (n / 2);
            break;
          case t.LINE_STRIP:
            e.lines += r * (n - 1);
            break;
          case t.LINE_LOOP:
            e.lines += r * n;
            break;
          case t.POINTS:
            e.points += r * n;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", i);
        }
      },
    };
  }
  function Ki(t, e) {
    return t[0] - e[0];
  }
  function Zi(t, e) {
    return Math.abs(e[1]) - Math.abs(t[1]);
  }
  function Ji(t, e, n) {
    const i = {},
      r = new Float32Array(8),
      s = new WeakMap(),
      a = new Gt(),
      o = [];
    for (let t = 0; t < 8; t++) o[t] = [t, 0];
    return {
      update: function (l, c, h) {
        const u = l.morphTargetInfluences;
        if (!0 === e.isWebGL2) {
          const d =
              c.morphAttributes.position ||
              c.morphAttributes.normal ||
              c.morphAttributes.color,
            p = void 0 !== d ? d.length : 0;
          let f = s.get(c);
          if (void 0 === f || f.count !== p) {
            void 0 !== f && f.texture.dispose();
            const _ = void 0 !== c.morphAttributes.position,
              v = void 0 !== c.morphAttributes.normal,
              y = void 0 !== c.morphAttributes.color,
              x = c.morphAttributes.position || [],
              T = c.morphAttributes.normal || [],
              M = c.morphAttributes.color || [];
            let S = 0;
            !0 === _ && (S = 1), !0 === v && (S = 2), !0 === y && (S = 3);
            let b = c.attributes.position.count * S,
              E = 1;
            b > e.maxTextureSize &&
              ((E = Math.ceil(b / e.maxTextureSize)), (b = e.maxTextureSize));
            const w = new Float32Array(b * E * 4 * p),
              A = new Xt(w, b, E, p);
            (A.type = L), (A.needsUpdate = !0);
            const R = 4 * S;
            for (let P = 0; P < p; P++) {
              const D = x[P],
                I = T[P],
                U = M[P],
                N = b * E * 4 * P;
              for (let O = 0; O < D.count; O++) {
                const F = O * R;
                !0 === _ &&
                  (a.fromBufferAttribute(D, O),
                  (w[N + F + 0] = a.x),
                  (w[N + F + 1] = a.y),
                  (w[N + F + 2] = a.z),
                  (w[N + F + 3] = 0)),
                  !0 === v &&
                    (a.fromBufferAttribute(I, O),
                    (w[N + F + 4] = a.x),
                    (w[N + F + 5] = a.y),
                    (w[N + F + 6] = a.z),
                    (w[N + F + 7] = 0)),
                  !0 === y &&
                    (a.fromBufferAttribute(U, O),
                    (w[N + F + 8] = a.x),
                    (w[N + F + 9] = a.y),
                    (w[N + F + 10] = a.z),
                    (w[N + F + 11] = 4 === U.itemSize ? a.w : 1));
              }
            }
            function C() {
              A.dispose(), s.delete(c), c.removeEventListener("dispose", C);
            }
            (f = { count: p, texture: A, size: new xt(b, E) }),
              s.set(c, f),
              c.addEventListener("dispose", C);
          }
          let m = 0;
          for (let k = 0; k < u.length; k++) m += u[k];
          const g = c.morphTargetsRelative ? 1 : 1 - m;
          h.getUniforms().setValue(t, "morphTargetBaseInfluence", g),
            h.getUniforms().setValue(t, "morphTargetInfluences", u),
            h.getUniforms().setValue(t, "morphTargetsTexture", f.texture, n),
            h.getUniforms().setValue(t, "morphTargetsTextureSize", f.size);
        } else {
          const z = void 0 === u ? 0 : u.length;
          let B = i[c.id];
          if (void 0 === B || B.length !== z) {
            B = [];
            for (let X = 0; X < z; X++) B[X] = [X, 0];
            i[c.id] = B;
          }
          for (let j = 0; j < z; j++) {
            const q = B[j];
            (q[0] = j), (q[1] = u[j]);
          }
          B.sort(Zi);
          for (let Y = 0; Y < 8; Y++)
            Y < z && B[Y][1]
              ? ((o[Y][0] = B[Y][0]), (o[Y][1] = B[Y][1]))
              : ((o[Y][0] = Number.MAX_SAFE_INTEGER), (o[Y][1] = 0));
          o.sort(Ki);
          const H = c.morphAttributes.position,
            G = c.morphAttributes.normal;
          let V = 0;
          for (let K = 0; K < 8; K++) {
            const Z = o[K],
              J = Z[0],
              Q = Z[1];
            J !== Number.MAX_SAFE_INTEGER && Q
              ? (H &&
                  c.getAttribute("morphTarget" + K) !== H[J] &&
                  c.setAttribute("morphTarget" + K, H[J]),
                G &&
                  c.getAttribute("morphNormal" + K) !== G[J] &&
                  c.setAttribute("morphNormal" + K, G[J]),
                (r[K] = Q),
                (V += Q))
              : (H &&
                  !0 === c.hasAttribute("morphTarget" + K) &&
                  c.deleteAttribute("morphTarget" + K),
                G &&
                  !0 === c.hasAttribute("morphNormal" + K) &&
                  c.deleteAttribute("morphNormal" + K),
                (r[K] = 0));
          }
          const W = c.morphTargetsRelative ? 1 : 1 - V;
          h.getUniforms().setValue(t, "morphTargetBaseInfluence", W),
            h.getUniforms().setValue(t, "morphTargetInfluences", r);
        }
      },
    };
  }
  function Qi(t, e, n, i) {
    let r = new WeakMap();
    function s(t) {
      const e = t.target;
      e.removeEventListener("dispose", s),
        n.remove(e.instanceMatrix),
        null !== e.instanceColor && n.remove(e.instanceColor);
    }
    return {
      update: function (a) {
        const o = i.render.frame,
          l = a.geometry,
          c = e.get(a, l);
        if (
          (r.get(c) !== o && (e.update(c), r.set(c, o)),
          a.isInstancedMesh &&
            (!1 === a.hasEventListener("dispose", s) &&
              a.addEventListener("dispose", s),
            r.get(a) !== o &&
              (n.update(a.instanceMatrix, t.ARRAY_BUFFER),
              null !== a.instanceColor &&
                n.update(a.instanceColor, t.ARRAY_BUFFER),
              r.set(a, o))),
          a.isSkinnedMesh)
        ) {
          const t = a.skeleton;
          r.get(t) !== o && (t.update(), r.set(t, o));
        }
        return c;
      },
      dispose: function () {
        r = new WeakMap();
      },
    };
  }
  class $i extends Ht {
    constructor(t, e, n, i, r, s, a, o, l, c) {
      if ((c = void 0 !== c ? c : N) !== N && c !== O)
        throw new Error(
          "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
        );
      void 0 === n && c === N && (n = P),
        void 0 === n && c === O && (n = I),
        super(null, i, r, s, a, o, c, n, l),
        (this.isDepthTexture = !0),
        (this.image = { width: t, height: e }),
        (this.magFilter = void 0 !== a ? a : S),
        (this.minFilter = void 0 !== o ? o : S),
        (this.flipY = !1),
        (this.generateMipmaps = !1),
        (this.compareFunction = null);
    }
    copy(t) {
      return super.copy(t), (this.compareFunction = t.compareFunction), this;
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        null !== this.compareFunction &&
          (e.compareFunction = this.compareFunction),
        e
      );
    }
  }
  const tr = new Ht(),
    er = new $i(1, 1);
  er.compareFunction = 515;
  const nr = new Xt(),
    ir = new jt(),
    rr = new oi(),
    sr = [],
    ar = [],
    or = new Float32Array(16),
    lr = new Float32Array(9),
    cr = new Float32Array(4);
  function hr(t, e, n) {
    const i = t[0];
    if (i <= 0 || i > 0) return t;
    const r = e * n;
    let s = sr[r];
    if ((void 0 === s && ((s = new Float32Array(r)), (sr[r] = s)), 0 !== e)) {
      i.toArray(s, 0);
      for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(s, r);
    }
    return s;
  }
  function ur(t, e) {
    if (t.length !== e.length) return !1;
    for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
    return !0;
  }
  function dr(t, e) {
    for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
  }
  function pr(t, e) {
    let n = ar[e];
    void 0 === n && ((n = new Int32Array(e)), (ar[e] = n));
    for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
    return n;
  }
  function fr(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
  }
  function mr(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y) ||
        (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
    else {
      if (ur(n, e)) return;
      t.uniform2fv(this.addr, e), dr(n, e);
    }
  }
  function gr(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
        (t.uniform3f(this.addr, e.x, e.y, e.z),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z));
    else if (void 0 !== e.r)
      (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
        (t.uniform3f(this.addr, e.r, e.g, e.b),
        (n[0] = e.r),
        (n[1] = e.g),
        (n[2] = e.b));
    else {
      if (ur(n, e)) return;
      t.uniform3fv(this.addr, e), dr(n, e);
    }
  }
  function _r(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
        (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z),
        (n[3] = e.w));
    else {
      if (ur(n, e)) return;
      t.uniform4fv(this.addr, e), dr(n, e);
    }
  }
  function vr(t, e) {
    const n = this.cache,
      i = e.elements;
    if (void 0 === i) {
      if (ur(n, e)) return;
      t.uniformMatrix2fv(this.addr, !1, e), dr(n, e);
    } else {
      if (ur(n, i)) return;
      cr.set(i), t.uniformMatrix2fv(this.addr, !1, cr), dr(n, i);
    }
  }
  function yr(t, e) {
    const n = this.cache,
      i = e.elements;
    if (void 0 === i) {
      if (ur(n, e)) return;
      t.uniformMatrix3fv(this.addr, !1, e), dr(n, e);
    } else {
      if (ur(n, i)) return;
      lr.set(i), t.uniformMatrix3fv(this.addr, !1, lr), dr(n, i);
    }
  }
  function xr(t, e) {
    const n = this.cache,
      i = e.elements;
    if (void 0 === i) {
      if (ur(n, e)) return;
      t.uniformMatrix4fv(this.addr, !1, e), dr(n, e);
    } else {
      if (ur(n, i)) return;
      or.set(i), t.uniformMatrix4fv(this.addr, !1, or), dr(n, i);
    }
  }
  function Tr(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
  }
  function Mr(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y) ||
        (t.uniform2i(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
    else {
      if (ur(n, e)) return;
      t.uniform2iv(this.addr, e), dr(n, e);
    }
  }
  function Sr(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
        (t.uniform3i(this.addr, e.x, e.y, e.z),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z));
    else {
      if (ur(n, e)) return;
      t.uniform3iv(this.addr, e), dr(n, e);
    }
  }
  function br(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
        (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z),
        (n[3] = e.w));
    else {
      if (ur(n, e)) return;
      t.uniform4iv(this.addr, e), dr(n, e);
    }
  }
  function Er(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
  }
  function wr(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y) ||
        (t.uniform2ui(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
    else {
      if (ur(n, e)) return;
      t.uniform2uiv(this.addr, e), dr(n, e);
    }
  }
  function Ar(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
        (t.uniform3ui(this.addr, e.x, e.y, e.z),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z));
    else {
      if (ur(n, e)) return;
      t.uniform3uiv(this.addr, e), dr(n, e);
    }
  }
  function Rr(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
        (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z),
        (n[3] = e.w));
    else {
      if (ur(n, e)) return;
      t.uniform4uiv(this.addr, e), dr(n, e);
    }
  }
  function Cr(t, e, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r));
    const s = this.type === t.SAMPLER_2D_SHADOW ? er : tr;
    n.setTexture2D(e || s, r);
  }
  function Pr(t, e, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
      n.setTexture3D(e || ir, r);
  }
  function Lr(t, e, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
      n.setTextureCube(e || rr, r);
  }
  function Dr(t, e, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
      n.setTexture2DArray(e || nr, r);
  }
  function Ir(t, e) {
    t.uniform1fv(this.addr, e);
  }
  function Ur(t, e) {
    const n = hr(e, this.size, 2);
    t.uniform2fv(this.addr, n);
  }
  function Nr(t, e) {
    const n = hr(e, this.size, 3);
    t.uniform3fv(this.addr, n);
  }
  function Or(t, e) {
    const n = hr(e, this.size, 4);
    t.uniform4fv(this.addr, n);
  }
  function Fr(t, e) {
    const n = hr(e, this.size, 4);
    t.uniformMatrix2fv(this.addr, !1, n);
  }
  function kr(t, e) {
    const n = hr(e, this.size, 9);
    t.uniformMatrix3fv(this.addr, !1, n);
  }
  function zr(t, e) {
    const n = hr(e, this.size, 16);
    t.uniformMatrix4fv(this.addr, !1, n);
  }
  function Br(t, e) {
    t.uniform1iv(this.addr, e);
  }
  function Hr(t, e) {
    t.uniform2iv(this.addr, e);
  }
  function Gr(t, e) {
    t.uniform3iv(this.addr, e);
  }
  function Vr(t, e) {
    t.uniform4iv(this.addr, e);
  }
  function Wr(t, e) {
    t.uniform1uiv(this.addr, e);
  }
  function Xr(t, e) {
    t.uniform2uiv(this.addr, e);
  }
  function jr(t, e) {
    t.uniform3uiv(this.addr, e);
  }
  function qr(t, e) {
    t.uniform4uiv(this.addr, e);
  }
  function Yr(t, e, n) {
    const i = this.cache,
      r = e.length,
      s = pr(n, r);
    ur(i, s) || (t.uniform1iv(this.addr, s), dr(i, s));
    for (let t = 0; t !== r; ++t) n.setTexture2D(e[t] || tr, s[t]);
  }
  function Kr(t, e, n) {
    const i = this.cache,
      r = e.length,
      s = pr(n, r);
    ur(i, s) || (t.uniform1iv(this.addr, s), dr(i, s));
    for (let t = 0; t !== r; ++t) n.setTexture3D(e[t] || ir, s[t]);
  }
  function Zr(t, e, n) {
    const i = this.cache,
      r = e.length,
      s = pr(n, r);
    ur(i, s) || (t.uniform1iv(this.addr, s), dr(i, s));
    for (let t = 0; t !== r; ++t) n.setTextureCube(e[t] || rr, s[t]);
  }
  function Jr(t, e, n) {
    const i = this.cache,
      r = e.length,
      s = pr(n, r);
    ur(i, s) || (t.uniform1iv(this.addr, s), dr(i, s));
    for (let t = 0; t !== r; ++t) n.setTexture2DArray(e[t] || nr, s[t]);
  }
  class Qr {
    constructor(t, e, n) {
      (this.id = t),
        (this.addr = n),
        (this.cache = []),
        (this.type = e.type),
        (this.setValue = (function (t) {
          switch (t) {
            case 5126:
              return fr;
            case 35664:
              return mr;
            case 35665:
              return gr;
            case 35666:
              return _r;
            case 35674:
              return vr;
            case 35675:
              return yr;
            case 35676:
              return xr;
            case 5124:
            case 35670:
              return Tr;
            case 35667:
            case 35671:
              return Mr;
            case 35668:
            case 35672:
              return Sr;
            case 35669:
            case 35673:
              return br;
            case 5125:
              return Er;
            case 36294:
              return wr;
            case 36295:
              return Ar;
            case 36296:
              return Rr;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return Cr;
            case 35679:
            case 36299:
            case 36307:
              return Pr;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return Lr;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return Dr;
          }
        })(e.type));
    }
  }
  class $r {
    constructor(t, e, n) {
      (this.id = t),
        (this.addr = n),
        (this.cache = []),
        (this.type = e.type),
        (this.size = e.size),
        (this.setValue = (function (t) {
          switch (t) {
            case 5126:
              return Ir;
            case 35664:
              return Ur;
            case 35665:
              return Nr;
            case 35666:
              return Or;
            case 35674:
              return Fr;
            case 35675:
              return kr;
            case 35676:
              return zr;
            case 5124:
            case 35670:
              return Br;
            case 35667:
            case 35671:
              return Hr;
            case 35668:
            case 35672:
              return Gr;
            case 35669:
            case 35673:
              return Vr;
            case 5125:
              return Wr;
            case 36294:
              return Xr;
            case 36295:
              return jr;
            case 36296:
              return qr;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return Yr;
            case 35679:
            case 36299:
            case 36307:
              return Kr;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return Zr;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return Jr;
          }
        })(e.type));
    }
  }
  class ts {
    constructor(t) {
      (this.id = t), (this.seq = []), (this.map = {});
    }
    setValue(t, e, n) {
      const i = this.seq;
      for (let r = 0, s = i.length; r !== s; ++r) {
        const s = i[r];
        s.setValue(t, e[s.id], n);
      }
    }
  }
  const es = /(\w+)(\])?(\[|\.)?/g;
  function ns(t, e) {
    t.seq.push(e), (t.map[e.id] = e);
  }
  function is(t, e, n) {
    const i = t.name,
      r = i.length;
    for (es.lastIndex = 0; ; ) {
      const s = es.exec(i),
        a = es.lastIndex;
      let o = s[1];
      const l = "]" === s[2],
        c = s[3];
      if ((l && (o |= 0), void 0 === c || ("[" === c && a + 2 === r))) {
        ns(n, void 0 === c ? new Qr(o, t, e) : new $r(o, t, e));
        break;
      }
      {
        let t = n.map[o];
        void 0 === t && ((t = new ts(o)), ns(n, t)), (n = t);
      }
    }
  }
  class rs {
    constructor(t, e) {
      (this.seq = []), (this.map = {});
      const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
      for (let i = 0; i < n; ++i) {
        const n = t.getActiveUniform(e, i);
        is(n, t.getUniformLocation(e, n.name), this);
      }
    }
    setValue(t, e, n, i) {
      const r = this.map[e];
      void 0 !== r && r.setValue(t, n, i);
    }
    setOptional(t, e, n) {
      const i = e[n];
      void 0 !== i && this.setValue(t, n, i);
    }
    static upload(t, e, n, i) {
      for (let r = 0, s = e.length; r !== s; ++r) {
        const s = e[r],
          a = n[s.id];
        !1 !== a.needsUpdate && s.setValue(t, a.value, i);
      }
    }
    static seqWithValue(t, e) {
      const n = [];
      for (let i = 0, r = t.length; i !== r; ++i) {
        const r = t[i];
        r.id in e && n.push(r);
      }
      return n;
    }
  }
  function ss(t, e, n) {
    const i = t.createShader(e);
    return t.shaderSource(i, n), t.compileShader(i), i;
  }
  const as = 37297;
  let os = 0;
  function ls(t, e, n) {
    const i = t.getShaderParameter(e, t.COMPILE_STATUS),
      r = t.getShaderInfoLog(e).trim();
    if (i && "" === r) return "";
    const s = /ERROR: 0:(\d+)/.exec(r);
    if (s) {
      const i = parseInt(s[1]);
      return (
        n.toUpperCase() +
        "\n\n" +
        r +
        "\n\n" +
        (function (t, e) {
          const n = t.split("\n"),
            i = [],
            r = Math.max(e - 6, 0),
            s = Math.min(e + 6, n.length);
          for (let t = r; t < s; t++) {
            const r = t + 1;
            i.push(`${r === e ? ">" : " "} ${r}: ${n[t]}`);
          }
          return i.join("\n");
        })(t.getShaderSource(e), i)
      );
    }
    return r;
  }
  function cs(t, e) {
    const n = (function (t) {
      const e = Dt.getPrimaries(Dt.workingColorSpace),
        n = Dt.getPrimaries(t);
      let i;
      switch (
        (e === n
          ? (i = "")
          : e === tt && n === $
          ? (i = "LinearDisplayP3ToLinearSRGB")
          : e === $ && n === tt && (i = "LinearSRGBToLinearDisplayP3"),
        t)
      ) {
        case Y:
        case Z:
          return [i, "LinearTransferOETF"];
        case q:
        case K:
          return [i, "sRGBTransferOETF"];
        default:
          return (
            console.warn("THREE.WebGLProgram: Unsupported color space:", t),
            [i, "LinearTransferOETF"]
          );
      }
    })(e);
    return `vec4 ${t}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`;
  }
  function hs(t, e) {
    let n;
    switch (e) {
      case h:
        n = "Linear";
        break;
      case u:
        n = "Reinhard";
        break;
      case d:
        n = "OptimizedCineon";
        break;
      case p:
        n = "ACESFilmic";
        break;
      case m:
        n = "AgX";
        break;
      case f:
        n = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
          (n = "Linear");
    }
    return (
      "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    );
  }
  function us(t) {
    return "" !== t;
  }
  function ds(t, e) {
    const n =
      e.numSpotLightShadows +
      e.numSpotLightMaps -
      e.numSpotLightShadowsWithMaps;
    return t
      .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
      .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
      .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
      .replace(/NUM_SPOT_LIGHT_COORDS/g, n)
      .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
      .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
      .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
      .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
      .replace(
        /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
        e.numSpotLightShadowsWithMaps
      )
      .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
      .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
  }
  function ps(t, e) {
    return t
      .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
      .replace(
        /UNION_CLIPPING_PLANES/g,
        e.numClippingPlanes - e.numClipIntersection
      );
  }
  const fs = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function ms(t) {
    return t.replace(fs, _s);
  }
  const gs = new Map([
    ["encodings_fragment", "colorspace_fragment"],
    ["encodings_pars_fragment", "colorspace_pars_fragment"],
    ["output_fragment", "opaque_fragment"],
  ]);
  function _s(t, e) {
    let n = yi[e];
    if (void 0 === n) {
      const t = gs.get(e);
      if (void 0 === t) throw new Error("Can not resolve #include <" + e + ">");
      (n = yi[t]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          t
        );
    }
    return ms(n);
  }
  const vs =
    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function ys(t) {
    return t.replace(vs, xs);
  }
  function xs(t, e, n, i) {
    let r = "";
    for (let t = parseInt(e); t < parseInt(n); t++)
      r += i
        .replace(/\[\s*i\s*\]/g, "[ " + t + " ]")
        .replace(/UNROLLED_LOOP_INDEX/g, t);
    return r;
  }
  function Ts(t) {
    let e =
      "precision " +
      t.precision +
      " float;\nprecision " +
      t.precision +
      " int;";
    return (
      "highp" === t.precision
        ? (e += "\n#define HIGH_PRECISION")
        : "mediump" === t.precision
        ? (e += "\n#define MEDIUM_PRECISION")
        : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
      e
    );
  }
  function Ms(t, e, s, h) {
    const u = t.getContext(),
      d = s.defines;
    let p = s.vertexShader,
      f = s.fragmentShader;
    const m = (function (t) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return (
          t.shadowMapType === n
            ? (e = "SHADOWMAP_TYPE_PCF")
            : t.shadowMapType === i
            ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
            : t.shadowMapType === r && (e = "SHADOWMAP_TYPE_VSM"),
          e
        );
      })(s),
      g = (function (t) {
        let e = "ENVMAP_TYPE_CUBE";
        if (t.envMap)
          switch (t.envMapMode) {
            case _:
            case v:
              e = "ENVMAP_TYPE_CUBE";
              break;
            case y:
              e = "ENVMAP_TYPE_CUBE_UV";
          }
        return e;
      })(s),
      x = (function (t) {
        let e = "ENVMAP_MODE_REFLECTION";
        return (
          t.envMap && t.envMapMode === v && (e = "ENVMAP_MODE_REFRACTION"), e
        );
      })(s),
      T = (function (t) {
        let e = "ENVMAP_BLENDING_NONE";
        if (t.envMap)
          switch (t.combine) {
            case a:
              e = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case o:
              e = "ENVMAP_BLENDING_MIX";
              break;
            case l:
              e = "ENVMAP_BLENDING_ADD";
          }
        return e;
      })(s),
      M = (function (t) {
        const e = t.envMapCubeUVHeight;
        if (null === e) return null;
        const n = Math.log2(e) - 2,
          i = 1 / e;
        return {
          texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
          texelHeight: i,
          maxMip: n,
        };
      })(s),
      S = s.isWebGL2
        ? ""
        : (function (t) {
            return [
              t.extensionDerivatives ||
              t.envMapCubeUVHeight ||
              t.bumpMap ||
              t.normalMapTangentSpace ||
              t.clearcoatNormalMap ||
              t.flatShading ||
              "physical" === t.shaderID
                ? "#extension GL_OES_standard_derivatives : enable"
                : "",
              (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
              t.rendererExtensionFragDepth
                ? "#extension GL_EXT_frag_depth : enable"
                : "",
              t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                ? "#extension GL_EXT_draw_buffers : require"
                : "",
              (t.extensionShaderTextureLOD || t.envMap || t.transmission) &&
              t.rendererExtensionShaderTextureLod
                ? "#extension GL_EXT_shader_texture_lod : enable"
                : "",
            ]
              .filter(us)
              .join("\n");
          })(s),
      b = (function (t) {
        return [
          t.extensionClipCullDistance
            ? "#extension GL_ANGLE_clip_cull_distance : require"
            : "",
        ]
          .filter(us)
          .join("\n");
      })(s),
      E = (function (t) {
        const e = [];
        for (const n in t) {
          const i = t[n];
          !1 !== i && e.push("#define " + n + " " + i);
        }
        return e.join("\n");
      })(d),
      w = u.createProgram();
    let A,
      R,
      C = s.glslVersion ? "#version " + s.glslVersion + "\n" : "";
    s.isRawShaderMaterial
      ? ((A = [
          "#define SHADER_TYPE " + s.shaderType,
          "#define SHADER_NAME " + s.shaderName,
          E,
        ]
          .filter(us)
          .join("\n")),
        A.length > 0 && (A += "\n"),
        (R = [
          S,
          "#define SHADER_TYPE " + s.shaderType,
          "#define SHADER_NAME " + s.shaderName,
          E,
        ]
          .filter(us)
          .join("\n")),
        R.length > 0 && (R += "\n"))
      : ((A = [
          Ts(s),
          "#define SHADER_TYPE " + s.shaderType,
          "#define SHADER_NAME " + s.shaderName,
          E,
          s.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
          s.batching ? "#define USE_BATCHING" : "",
          s.instancing ? "#define USE_INSTANCING" : "",
          s.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
          s.useFog && s.fog ? "#define USE_FOG" : "",
          s.useFog && s.fogExp2 ? "#define FOG_EXP2" : "",
          s.map ? "#define USE_MAP" : "",
          s.envMap ? "#define USE_ENVMAP" : "",
          s.envMap ? "#define " + x : "",
          s.lightMap ? "#define USE_LIGHTMAP" : "",
          s.aoMap ? "#define USE_AOMAP" : "",
          s.bumpMap ? "#define USE_BUMPMAP" : "",
          s.normalMap ? "#define USE_NORMALMAP" : "",
          s.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          s.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          s.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
          s.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          s.anisotropy ? "#define USE_ANISOTROPY" : "",
          s.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          s.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          s.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          s.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          s.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          s.iridescenceThicknessMap
            ? "#define USE_IRIDESCENCE_THICKNESSMAP"
            : "",
          s.specularMap ? "#define USE_SPECULARMAP" : "",
          s.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          s.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          s.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          s.metalnessMap ? "#define USE_METALNESSMAP" : "",
          s.alphaMap ? "#define USE_ALPHAMAP" : "",
          s.alphaHash ? "#define USE_ALPHAHASH" : "",
          s.transmission ? "#define USE_TRANSMISSION" : "",
          s.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          s.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          s.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          s.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          s.mapUv ? "#define MAP_UV " + s.mapUv : "",
          s.alphaMapUv ? "#define ALPHAMAP_UV " + s.alphaMapUv : "",
          s.lightMapUv ? "#define LIGHTMAP_UV " + s.lightMapUv : "",
          s.aoMapUv ? "#define AOMAP_UV " + s.aoMapUv : "",
          s.emissiveMapUv ? "#define EMISSIVEMAP_UV " + s.emissiveMapUv : "",
          s.bumpMapUv ? "#define BUMPMAP_UV " + s.bumpMapUv : "",
          s.normalMapUv ? "#define NORMALMAP_UV " + s.normalMapUv : "",
          s.displacementMapUv
            ? "#define DISPLACEMENTMAP_UV " + s.displacementMapUv
            : "",
          s.metalnessMapUv ? "#define METALNESSMAP_UV " + s.metalnessMapUv : "",
          s.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + s.roughnessMapUv : "",
          s.anisotropyMapUv
            ? "#define ANISOTROPYMAP_UV " + s.anisotropyMapUv
            : "",
          s.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + s.clearcoatMapUv : "",
          s.clearcoatNormalMapUv
            ? "#define CLEARCOAT_NORMALMAP_UV " + s.clearcoatNormalMapUv
            : "",
          s.clearcoatRoughnessMapUv
            ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + s.clearcoatRoughnessMapUv
            : "",
          s.iridescenceMapUv
            ? "#define IRIDESCENCEMAP_UV " + s.iridescenceMapUv
            : "",
          s.iridescenceThicknessMapUv
            ? "#define IRIDESCENCE_THICKNESSMAP_UV " +
              s.iridescenceThicknessMapUv
            : "",
          s.sheenColorMapUv
            ? "#define SHEEN_COLORMAP_UV " + s.sheenColorMapUv
            : "",
          s.sheenRoughnessMapUv
            ? "#define SHEEN_ROUGHNESSMAP_UV " + s.sheenRoughnessMapUv
            : "",
          s.specularMapUv ? "#define SPECULARMAP_UV " + s.specularMapUv : "",
          s.specularColorMapUv
            ? "#define SPECULAR_COLORMAP_UV " + s.specularColorMapUv
            : "",
          s.specularIntensityMapUv
            ? "#define SPECULAR_INTENSITYMAP_UV " + s.specularIntensityMapUv
            : "",
          s.transmissionMapUv
            ? "#define TRANSMISSIONMAP_UV " + s.transmissionMapUv
            : "",
          s.thicknessMapUv ? "#define THICKNESSMAP_UV " + s.thicknessMapUv : "",
          s.vertexTangents && !1 === s.flatShading ? "#define USE_TANGENT" : "",
          s.vertexColors ? "#define USE_COLOR" : "",
          s.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          s.vertexUv1s ? "#define USE_UV1" : "",
          s.vertexUv2s ? "#define USE_UV2" : "",
          s.vertexUv3s ? "#define USE_UV3" : "",
          s.pointsUvs ? "#define USE_POINTS_UV" : "",
          s.flatShading ? "#define FLAT_SHADED" : "",
          s.skinning ? "#define USE_SKINNING" : "",
          s.morphTargets ? "#define USE_MORPHTARGETS" : "",
          s.morphNormals && !1 === s.flatShading
            ? "#define USE_MORPHNORMALS"
            : "",
          s.morphColors && s.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
          s.morphTargetsCount > 0 && s.isWebGL2
            ? "#define MORPHTARGETS_TEXTURE"
            : "",
          s.morphTargetsCount > 0 && s.isWebGL2
            ? "#define MORPHTARGETS_TEXTURE_STRIDE " + s.morphTextureStride
            : "",
          s.morphTargetsCount > 0 && s.isWebGL2
            ? "#define MORPHTARGETS_COUNT " + s.morphTargetsCount
            : "",
          s.doubleSided ? "#define DOUBLE_SIDED" : "",
          s.flipSided ? "#define FLIP_SIDED" : "",
          s.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          s.shadowMapEnabled ? "#define " + m : "",
          s.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
          s.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
          s.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
          s.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          s.logarithmicDepthBuffer && s.rendererExtensionFragDepth
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          "uniform mat4 modelMatrix;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform mat4 viewMatrix;",
          "uniform mat3 normalMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          "#ifdef USE_INSTANCING",
          "\tattribute mat4 instanceMatrix;",
          "#endif",
          "#ifdef USE_INSTANCING_COLOR",
          "\tattribute vec3 instanceColor;",
          "#endif",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec2 uv;",
          "#ifdef USE_UV1",
          "\tattribute vec2 uv1;",
          "#endif",
          "#ifdef USE_UV2",
          "\tattribute vec2 uv2;",
          "#endif",
          "#ifdef USE_UV3",
          "\tattribute vec2 uv3;",
          "#endif",
          "#ifdef USE_TANGENT",
          "\tattribute vec4 tangent;",
          "#endif",
          "#if defined( USE_COLOR_ALPHA )",
          "\tattribute vec4 color;",
          "#elif defined( USE_COLOR )",
          "\tattribute vec3 color;",
          "#endif",
          "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
          "\tattribute vec3 morphTarget0;",
          "\tattribute vec3 morphTarget1;",
          "\tattribute vec3 morphTarget2;",
          "\tattribute vec3 morphTarget3;",
          "\t#ifdef USE_MORPHNORMALS",
          "\t\tattribute vec3 morphNormal0;",
          "\t\tattribute vec3 morphNormal1;",
          "\t\tattribute vec3 morphNormal2;",
          "\t\tattribute vec3 morphNormal3;",
          "\t#else",
          "\t\tattribute vec3 morphTarget4;",
          "\t\tattribute vec3 morphTarget5;",
          "\t\tattribute vec3 morphTarget6;",
          "\t\tattribute vec3 morphTarget7;",
          "\t#endif",
          "#endif",
          "#ifdef USE_SKINNING",
          "\tattribute vec4 skinIndex;",
          "\tattribute vec4 skinWeight;",
          "#endif",
          "\n",
        ]
          .filter(us)
          .join("\n")),
        (R = [
          S,
          Ts(s),
          "#define SHADER_TYPE " + s.shaderType,
          "#define SHADER_NAME " + s.shaderName,
          E,
          s.useFog && s.fog ? "#define USE_FOG" : "",
          s.useFog && s.fogExp2 ? "#define FOG_EXP2" : "",
          s.map ? "#define USE_MAP" : "",
          s.matcap ? "#define USE_MATCAP" : "",
          s.envMap ? "#define USE_ENVMAP" : "",
          s.envMap ? "#define " + g : "",
          s.envMap ? "#define " + x : "",
          s.envMap ? "#define " + T : "",
          M ? "#define CUBEUV_TEXEL_WIDTH " + M.texelWidth : "",
          M ? "#define CUBEUV_TEXEL_HEIGHT " + M.texelHeight : "",
          M ? "#define CUBEUV_MAX_MIP " + M.maxMip + ".0" : "",
          s.lightMap ? "#define USE_LIGHTMAP" : "",
          s.aoMap ? "#define USE_AOMAP" : "",
          s.bumpMap ? "#define USE_BUMPMAP" : "",
          s.normalMap ? "#define USE_NORMALMAP" : "",
          s.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          s.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          s.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          s.anisotropy ? "#define USE_ANISOTROPY" : "",
          s.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          s.clearcoat ? "#define USE_CLEARCOAT" : "",
          s.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          s.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          s.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          s.iridescence ? "#define USE_IRIDESCENCE" : "",
          s.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          s.iridescenceThicknessMap
            ? "#define USE_IRIDESCENCE_THICKNESSMAP"
            : "",
          s.specularMap ? "#define USE_SPECULARMAP" : "",
          s.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          s.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          s.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          s.metalnessMap ? "#define USE_METALNESSMAP" : "",
          s.alphaMap ? "#define USE_ALPHAMAP" : "",
          s.alphaTest ? "#define USE_ALPHATEST" : "",
          s.alphaHash ? "#define USE_ALPHAHASH" : "",
          s.sheen ? "#define USE_SHEEN" : "",
          s.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          s.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          s.transmission ? "#define USE_TRANSMISSION" : "",
          s.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          s.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          s.vertexTangents && !1 === s.flatShading ? "#define USE_TANGENT" : "",
          s.vertexColors || s.instancingColor ? "#define USE_COLOR" : "",
          s.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          s.vertexUv1s ? "#define USE_UV1" : "",
          s.vertexUv2s ? "#define USE_UV2" : "",
          s.vertexUv3s ? "#define USE_UV3" : "",
          s.pointsUvs ? "#define USE_POINTS_UV" : "",
          s.gradientMap ? "#define USE_GRADIENTMAP" : "",
          s.flatShading ? "#define FLAT_SHADED" : "",
          s.doubleSided ? "#define DOUBLE_SIDED" : "",
          s.flipSided ? "#define FLIP_SIDED" : "",
          s.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          s.shadowMapEnabled ? "#define " + m : "",
          s.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
          s.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
          s.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
          s.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
          s.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          s.logarithmicDepthBuffer && s.rendererExtensionFragDepth
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          s.toneMapping !== c ? "#define TONE_MAPPING" : "",
          s.toneMapping !== c ? yi.tonemapping_pars_fragment : "",
          s.toneMapping !== c ? hs("toneMapping", s.toneMapping) : "",
          s.dithering ? "#define DITHERING" : "",
          s.opaque ? "#define OPAQUE" : "",
          yi.colorspace_pars_fragment,
          cs("linearToOutputTexel", s.outputColorSpace),
          s.useDepthPacking ? "#define DEPTH_PACKING " + s.depthPacking : "",
          "\n",
        ]
          .filter(us)
          .join("\n"))),
      (p = ms(p)),
      (p = ds(p, s)),
      (p = ps(p, s)),
      (f = ms(f)),
      (f = ds(f, s)),
      (f = ps(f, s)),
      (p = ys(p)),
      (f = ys(f)),
      s.isWebGL2 &&
        !0 !== s.isRawShaderMaterial &&
        ((C = "#version 300 es\n"),
        (A =
          [
            b,
            "precision mediump sampler2DArray;",
            "#define attribute in",
            "#define varying out",
            "#define texture2D texture",
          ].join("\n") +
          "\n" +
          A),
        (R =
          [
            "precision mediump sampler2DArray;",
            "#define varying in",
            s.glslVersion === it
              ? ""
              : "layout(location = 0) out highp vec4 pc_fragColor;",
            s.glslVersion === it ? "" : "#define gl_FragColor pc_fragColor",
            "#define gl_FragDepthEXT gl_FragDepth",
            "#define texture2D texture",
            "#define textureCube texture",
            "#define texture2DProj textureProj",
            "#define texture2DLodEXT textureLod",
            "#define texture2DProjLodEXT textureProjLod",
            "#define textureCubeLodEXT textureLod",
            "#define texture2DGradEXT textureGrad",
            "#define texture2DProjGradEXT textureProjGrad",
            "#define textureCubeGradEXT textureGrad",
          ].join("\n") +
          "\n" +
          R));
    const P = C + A + p,
      L = C + R + f,
      D = ss(u, u.VERTEX_SHADER, P),
      I = ss(u, u.FRAGMENT_SHADER, L);
    function U(e) {
      if (t.debug.checkShaderErrors) {
        const n = u.getProgramInfoLog(w).trim(),
          i = u.getShaderInfoLog(D).trim(),
          r = u.getShaderInfoLog(I).trim();
        let s = !0,
          a = !0;
        if (!1 === u.getProgramParameter(w, u.LINK_STATUS))
          if (((s = !1), "function" == typeof t.debug.onShaderError))
            t.debug.onShaderError(u, w, D, I);
          else {
            const t = ls(u, D, "vertex"),
              e = ls(u, I, "fragment");
            console.error(
              "THREE.WebGLProgram: Shader Error " +
                u.getError() +
                " - VALIDATE_STATUS " +
                u.getProgramParameter(w, u.VALIDATE_STATUS) +
                "\n\nProgram Info Log: " +
                n +
                "\n" +
                t +
                "\n" +
                e
            );
          }
        else
          "" !== n
            ? console.warn("THREE.WebGLProgram: Program Info Log:", n)
            : ("" !== i && "" !== r) || (a = !1);
        a &&
          (e.diagnostics = {
            runnable: s,
            programLog: n,
            vertexShader: { log: i, prefix: A },
            fragmentShader: { log: r, prefix: R },
          });
      }
      u.deleteShader(D),
        u.deleteShader(I),
        (N = new rs(u, w)),
        (O = (function (t, e) {
          const n = {},
            i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
          for (let r = 0; r < i; r++) {
            const i = t.getActiveAttrib(e, r),
              s = i.name;
            let a = 1;
            i.type === t.FLOAT_MAT2 && (a = 2),
              i.type === t.FLOAT_MAT3 && (a = 3),
              i.type === t.FLOAT_MAT4 && (a = 4),
              (n[s] = {
                type: i.type,
                location: t.getAttribLocation(e, s),
                locationSize: a,
              });
          }
          return n;
        })(u, w));
    }
    let N, O;
    u.attachShader(w, D),
      u.attachShader(w, I),
      void 0 !== s.index0AttributeName
        ? u.bindAttribLocation(w, 0, s.index0AttributeName)
        : !0 === s.morphTargets && u.bindAttribLocation(w, 0, "position"),
      u.linkProgram(w),
      (this.getUniforms = function () {
        return void 0 === N && U(this), N;
      }),
      (this.getAttributes = function () {
        return void 0 === O && U(this), O;
      });
    let F = !1 === s.rendererExtensionParallelShaderCompile;
    return (
      (this.isReady = function () {
        return !1 === F && (F = u.getProgramParameter(w, as)), F;
      }),
      (this.destroy = function () {
        h.releaseStatesOfProgram(this),
          u.deleteProgram(w),
          (this.program = void 0);
      }),
      (this.type = s.shaderType),
      (this.name = s.shaderName),
      (this.id = os++),
      (this.cacheKey = e),
      (this.usedTimes = 1),
      (this.program = w),
      (this.vertexShader = D),
      (this.fragmentShader = I),
      this
    );
  }
  let Ss = 0;
  class bs {
    constructor() {
      (this.shaderCache = new Map()), (this.materialCache = new Map());
    }
    update(t) {
      const e = t.vertexShader,
        n = t.fragmentShader,
        i = this._getShaderStage(e),
        r = this._getShaderStage(n),
        s = this._getShaderCacheForMaterial(t);
      return (
        !1 === s.has(i) && (s.add(i), i.usedTimes++),
        !1 === s.has(r) && (s.add(r), r.usedTimes++),
        this
      );
    }
    remove(t) {
      const e = this.materialCache.get(t);
      for (const t of e)
        t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code);
      return this.materialCache.delete(t), this;
    }
    getVertexShaderID(t) {
      return this._getShaderStage(t.vertexShader).id;
    }
    getFragmentShaderID(t) {
      return this._getShaderStage(t.fragmentShader).id;
    }
    dispose() {
      this.shaderCache.clear(), this.materialCache.clear();
    }
    _getShaderCacheForMaterial(t) {
      const e = this.materialCache;
      let n = e.get(t);
      return void 0 === n && ((n = new Set()), e.set(t, n)), n;
    }
    _getShaderStage(t) {
      const e = this.shaderCache;
      let n = e.get(t);
      return void 0 === n && ((n = new Es(t)), e.set(t, n)), n;
    }
  }
  class Es {
    constructor(t) {
      (this.id = Ss++), (this.code = t), (this.usedTimes = 0);
    }
  }
  function ws(t, e, n, i, r, s, a) {
    const o = new Ne(),
      l = new bs(),
      h = [],
      u = r.isWebGL2,
      d = r.logarithmicDepthBuffer,
      p = r.vertexTextures;
    let f = r.precision;
    const m = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite",
    };
    function g(t) {
      return 0 === t ? "uv" : `uv${t}`;
    }
    return {
      getParameters: function (s, o, h, _, v) {
        const x = _.fog,
          T = v.geometry,
          M = s.isMeshStandardMaterial ? _.environment : null,
          S = (s.isMeshStandardMaterial ? n : e).get(s.envMap || M),
          b = S && S.mapping === y ? S.image.height : null,
          E = m[s.type];
        null !== s.precision &&
          ((f = r.getMaxPrecision(s.precision)),
          f !== s.precision &&
            console.warn(
              "THREE.WebGLProgram.getParameters:",
              s.precision,
              "not supported, using",
              f,
              "instead."
            ));
        const w =
            T.morphAttributes.position ||
            T.morphAttributes.normal ||
            T.morphAttributes.color,
          A = void 0 !== w ? w.length : 0;
        let R,
          C,
          P,
          L,
          D = 0;
        if (
          (void 0 !== T.morphAttributes.position && (D = 1),
          void 0 !== T.morphAttributes.normal && (D = 2),
          void 0 !== T.morphAttributes.color && (D = 3),
          E)
        ) {
          const t = Ti[E];
          (R = t.vertexShader), (C = t.fragmentShader);
        } else
          (R = s.vertexShader),
            (C = s.fragmentShader),
            l.update(s),
            (P = l.getVertexShaderID(s)),
            (L = l.getFragmentShaderID(s));
        const I = t.getRenderTarget(),
          U = !0 === v.isInstancedMesh,
          N = !0 === v.isBatchedMesh,
          O = !!s.map,
          F = !!s.matcap,
          k = !!S,
          z = !!s.aoMap,
          B = !!s.lightMap,
          H = !!s.bumpMap,
          G = !!s.normalMap,
          V = !!s.displacementMap,
          W = !!s.emissiveMap,
          X = !!s.metalnessMap,
          j = !!s.roughnessMap,
          q = s.anisotropy > 0,
          K = s.clearcoat > 0,
          Z = s.iridescence > 0,
          J = s.sheen > 0,
          $ = s.transmission > 0,
          tt = q && !!s.anisotropyMap,
          et = K && !!s.clearcoatMap,
          nt = K && !!s.clearcoatNormalMap,
          it = K && !!s.clearcoatRoughnessMap,
          rt = Z && !!s.iridescenceMap,
          st = Z && !!s.iridescenceThicknessMap,
          at = J && !!s.sheenColorMap,
          ot = J && !!s.sheenRoughnessMap,
          lt = !!s.specularMap,
          ct = !!s.specularColorMap,
          ht = !!s.specularIntensityMap,
          ut = $ && !!s.transmissionMap,
          dt = $ && !!s.thicknessMap,
          pt = !!s.gradientMap,
          ft = !!s.alphaMap,
          mt = s.alphaTest > 0,
          gt = !!s.alphaHash,
          _t = !!s.extensions,
          vt = !!T.attributes.uv1,
          yt = !!T.attributes.uv2,
          xt = !!T.attributes.uv3;
        let Tt = c;
        return (
          s.toneMapped &&
            ((null !== I && !0 !== I.isXRRenderTarget) || (Tt = t.toneMapping)),
          {
            isWebGL2: u,
            shaderID: E,
            shaderType: s.type,
            shaderName: s.name,
            vertexShader: R,
            fragmentShader: C,
            defines: s.defines,
            customVertexShaderID: P,
            customFragmentShaderID: L,
            isRawShaderMaterial: !0 === s.isRawShaderMaterial,
            glslVersion: s.glslVersion,
            precision: f,
            batching: N,
            instancing: U,
            instancingColor: U && null !== v.instanceColor,
            supportsVertexTextures: p,
            outputColorSpace:
              null === I
                ? t.outputColorSpace
                : !0 === I.isXRRenderTarget
                ? I.texture.colorSpace
                : Y,
            map: O,
            matcap: F,
            envMap: k,
            envMapMode: k && S.mapping,
            envMapCubeUVHeight: b,
            aoMap: z,
            lightMap: B,
            bumpMap: H,
            normalMap: G,
            displacementMap: p && V,
            emissiveMap: W,
            normalMapObjectSpace: G && 1 === s.normalMapType,
            normalMapTangentSpace: G && 0 === s.normalMapType,
            metalnessMap: X,
            roughnessMap: j,
            anisotropy: q,
            anisotropyMap: tt,
            clearcoat: K,
            clearcoatMap: et,
            clearcoatNormalMap: nt,
            clearcoatRoughnessMap: it,
            iridescence: Z,
            iridescenceMap: rt,
            iridescenceThicknessMap: st,
            sheen: J,
            sheenColorMap: at,
            sheenRoughnessMap: ot,
            specularMap: lt,
            specularColorMap: ct,
            specularIntensityMap: ht,
            transmission: $,
            transmissionMap: ut,
            thicknessMap: dt,
            gradientMap: pt,
            opaque: !1 === s.transparent && 1 === s.blending,
            alphaMap: ft,
            alphaTest: mt,
            alphaHash: gt,
            combine: s.combine,
            mapUv: O && g(s.map.channel),
            aoMapUv: z && g(s.aoMap.channel),
            lightMapUv: B && g(s.lightMap.channel),
            bumpMapUv: H && g(s.bumpMap.channel),
            normalMapUv: G && g(s.normalMap.channel),
            displacementMapUv: V && g(s.displacementMap.channel),
            emissiveMapUv: W && g(s.emissiveMap.channel),
            metalnessMapUv: X && g(s.metalnessMap.channel),
            roughnessMapUv: j && g(s.roughnessMap.channel),
            anisotropyMapUv: tt && g(s.anisotropyMap.channel),
            clearcoatMapUv: et && g(s.clearcoatMap.channel),
            clearcoatNormalMapUv: nt && g(s.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: it && g(s.clearcoatRoughnessMap.channel),
            iridescenceMapUv: rt && g(s.iridescenceMap.channel),
            iridescenceThicknessMapUv:
              st && g(s.iridescenceThicknessMap.channel),
            sheenColorMapUv: at && g(s.sheenColorMap.channel),
            sheenRoughnessMapUv: ot && g(s.sheenRoughnessMap.channel),
            specularMapUv: lt && g(s.specularMap.channel),
            specularColorMapUv: ct && g(s.specularColorMap.channel),
            specularIntensityMapUv: ht && g(s.specularIntensityMap.channel),
            transmissionMapUv: ut && g(s.transmissionMap.channel),
            thicknessMapUv: dt && g(s.thicknessMap.channel),
            alphaMapUv: ft && g(s.alphaMap.channel),
            vertexTangents: !!T.attributes.tangent && (G || q),
            vertexColors: s.vertexColors,
            vertexAlphas:
              !0 === s.vertexColors &&
              !!T.attributes.color &&
              4 === T.attributes.color.itemSize,
            vertexUv1s: vt,
            vertexUv2s: yt,
            vertexUv3s: xt,
            pointsUvs: !0 === v.isPoints && !!T.attributes.uv && (O || ft),
            fog: !!x,
            useFog: !0 === s.fog,
            fogExp2: x && x.isFogExp2,
            flatShading: !0 === s.flatShading,
            sizeAttenuation: !0 === s.sizeAttenuation,
            logarithmicDepthBuffer: d,
            skinning: !0 === v.isSkinnedMesh,
            morphTargets: void 0 !== T.morphAttributes.position,
            morphNormals: void 0 !== T.morphAttributes.normal,
            morphColors: void 0 !== T.morphAttributes.color,
            morphTargetsCount: A,
            morphTextureStride: D,
            numDirLights: o.directional.length,
            numPointLights: o.point.length,
            numSpotLights: o.spot.length,
            numSpotLightMaps: o.spotLightMap.length,
            numRectAreaLights: o.rectArea.length,
            numHemiLights: o.hemi.length,
            numDirLightShadows: o.directionalShadowMap.length,
            numPointLightShadows: o.pointShadowMap.length,
            numSpotLightShadows: o.spotShadowMap.length,
            numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
            numLightProbes: o.numLightProbes,
            numClippingPlanes: a.numPlanes,
            numClipIntersection: a.numIntersection,
            dithering: s.dithering,
            shadowMapEnabled: t.shadowMap.enabled && h.length > 0,
            shadowMapType: t.shadowMap.type,
            toneMapping: Tt,
            useLegacyLights: t._useLegacyLights,
            decodeVideoTexture:
              O &&
              !0 === s.map.isVideoTexture &&
              Dt.getTransfer(s.map.colorSpace) === Q,
            premultipliedAlpha: s.premultipliedAlpha,
            doubleSided: 2 === s.side,
            flipSided: 1 === s.side,
            useDepthPacking: s.depthPacking >= 0,
            depthPacking: s.depthPacking || 0,
            index0AttributeName: s.index0AttributeName,
            extensionDerivatives: _t && !0 === s.extensions.derivatives,
            extensionFragDepth: _t && !0 === s.extensions.fragDepth,
            extensionDrawBuffers: _t && !0 === s.extensions.drawBuffers,
            extensionShaderTextureLOD:
              _t && !0 === s.extensions.shaderTextureLOD,
            extensionClipCullDistance:
              _t &&
              s.extensions.clipCullDistance &&
              i.has("WEBGL_clip_cull_distance"),
            rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod:
              u || i.has("EXT_shader_texture_lod"),
            rendererExtensionParallelShaderCompile: i.has(
              "KHR_parallel_shader_compile"
            ),
            customProgramCacheKey: s.customProgramCacheKey(),
          }
        );
      },
      getProgramCacheKey: function (e) {
        const n = [];
        if (
          (e.shaderID
            ? n.push(e.shaderID)
            : (n.push(e.customVertexShaderID),
              n.push(e.customFragmentShaderID)),
          void 0 !== e.defines)
        )
          for (const t in e.defines) n.push(t), n.push(e.defines[t]);
        return (
          !1 === e.isRawShaderMaterial &&
            ((function (t, e) {
              t.push(e.precision),
                t.push(e.outputColorSpace),
                t.push(e.envMapMode),
                t.push(e.envMapCubeUVHeight),
                t.push(e.mapUv),
                t.push(e.alphaMapUv),
                t.push(e.lightMapUv),
                t.push(e.aoMapUv),
                t.push(e.bumpMapUv),
                t.push(e.normalMapUv),
                t.push(e.displacementMapUv),
                t.push(e.emissiveMapUv),
                t.push(e.metalnessMapUv),
                t.push(e.roughnessMapUv),
                t.push(e.anisotropyMapUv),
                t.push(e.clearcoatMapUv),
                t.push(e.clearcoatNormalMapUv),
                t.push(e.clearcoatRoughnessMapUv),
                t.push(e.iridescenceMapUv),
                t.push(e.iridescenceThicknessMapUv),
                t.push(e.sheenColorMapUv),
                t.push(e.sheenRoughnessMapUv),
                t.push(e.specularMapUv),
                t.push(e.specularColorMapUv),
                t.push(e.specularIntensityMapUv),
                t.push(e.transmissionMapUv),
                t.push(e.thicknessMapUv),
                t.push(e.combine),
                t.push(e.fogExp2),
                t.push(e.sizeAttenuation),
                t.push(e.morphTargetsCount),
                t.push(e.morphAttributeCount),
                t.push(e.numDirLights),
                t.push(e.numPointLights),
                t.push(e.numSpotLights),
                t.push(e.numSpotLightMaps),
                t.push(e.numHemiLights),
                t.push(e.numRectAreaLights),
                t.push(e.numDirLightShadows),
                t.push(e.numPointLightShadows),
                t.push(e.numSpotLightShadows),
                t.push(e.numSpotLightShadowsWithMaps),
                t.push(e.numLightProbes),
                t.push(e.shadowMapType),
                t.push(e.toneMapping),
                t.push(e.numClippingPlanes),
                t.push(e.numClipIntersection),
                t.push(e.depthPacking);
            })(n, e),
            (function (t, e) {
              o.disableAll(),
                e.isWebGL2 && o.enable(0),
                e.supportsVertexTextures && o.enable(1),
                e.instancing && o.enable(2),
                e.instancingColor && o.enable(3),
                e.matcap && o.enable(4),
                e.envMap && o.enable(5),
                e.normalMapObjectSpace && o.enable(6),
                e.normalMapTangentSpace && o.enable(7),
                e.clearcoat && o.enable(8),
                e.iridescence && o.enable(9),
                e.alphaTest && o.enable(10),
                e.vertexColors && o.enable(11),
                e.vertexAlphas && o.enable(12),
                e.vertexUv1s && o.enable(13),
                e.vertexUv2s && o.enable(14),
                e.vertexUv3s && o.enable(15),
                e.vertexTangents && o.enable(16),
                e.anisotropy && o.enable(17),
                e.alphaHash && o.enable(18),
                e.batching && o.enable(19),
                t.push(o.mask),
                o.disableAll(),
                e.fog && o.enable(0),
                e.useFog && o.enable(1),
                e.flatShading && o.enable(2),
                e.logarithmicDepthBuffer && o.enable(3),
                e.skinning && o.enable(4),
                e.morphTargets && o.enable(5),
                e.morphNormals && o.enable(6),
                e.morphColors && o.enable(7),
                e.premultipliedAlpha && o.enable(8),
                e.shadowMapEnabled && o.enable(9),
                e.useLegacyLights && o.enable(10),
                e.doubleSided && o.enable(11),
                e.flipSided && o.enable(12),
                e.useDepthPacking && o.enable(13),
                e.dithering && o.enable(14),
                e.transmission && o.enable(15),
                e.sheen && o.enable(16),
                e.opaque && o.enable(17),
                e.pointsUvs && o.enable(18),
                e.decodeVideoTexture && o.enable(19),
                t.push(o.mask);
            })(n, e),
            n.push(t.outputColorSpace)),
          n.push(e.customProgramCacheKey),
          n.join()
        );
      },
      getUniforms: function (t) {
        const e = m[t.type];
        let n;
        if (e) {
          const t = Ti[e];
          n = ei.clone(t.uniforms);
        } else n = t.uniforms;
        return n;
      },
      acquireProgram: function (e, n) {
        let i;
        for (let t = 0, e = h.length; t < e; t++) {
          const e = h[t];
          if (e.cacheKey === n) {
            (i = e), ++i.usedTimes;
            break;
          }
        }
        return void 0 === i && ((i = new Ms(t, n, e, s)), h.push(i)), i;
      },
      releaseProgram: function (t) {
        if (0 == --t.usedTimes) {
          const e = h.indexOf(t);
          (h[e] = h[h.length - 1]), h.pop(), t.destroy();
        }
      },
      releaseShaderCache: function (t) {
        l.remove(t);
      },
      programs: h,
      dispose: function () {
        l.dispose();
      },
    };
  }
  function As() {
    let t = new WeakMap();
    return {
      get: function (e) {
        let n = t.get(e);
        return void 0 === n && ((n = {}), t.set(e, n)), n;
      },
      remove: function (e) {
        t.delete(e);
      },
      update: function (e, n, i) {
        t.get(e)[n] = i;
      },
      dispose: function () {
        t = new WeakMap();
      },
    };
  }
  function Rs(t, e) {
    return t.groupOrder !== e.groupOrder
      ? t.groupOrder - e.groupOrder
      : t.renderOrder !== e.renderOrder
      ? t.renderOrder - e.renderOrder
      : t.material.id !== e.material.id
      ? t.material.id - e.material.id
      : t.z !== e.z
      ? t.z - e.z
      : t.id - e.id;
  }
  function Cs(t, e) {
    return t.groupOrder !== e.groupOrder
      ? t.groupOrder - e.groupOrder
      : t.renderOrder !== e.renderOrder
      ? t.renderOrder - e.renderOrder
      : t.z !== e.z
      ? e.z - t.z
      : t.id - e.id;
  }
  function Ps() {
    const t = [];
    let e = 0;
    const n = [],
      i = [],
      r = [];
    function s(n, i, r, s, a, o) {
      let l = t[e];
      return (
        void 0 === l
          ? ((l = {
              id: n.id,
              object: n,
              geometry: i,
              material: r,
              groupOrder: s,
              renderOrder: n.renderOrder,
              z: a,
              group: o,
            }),
            (t[e] = l))
          : ((l.id = n.id),
            (l.object = n),
            (l.geometry = i),
            (l.material = r),
            (l.groupOrder = s),
            (l.renderOrder = n.renderOrder),
            (l.z = a),
            (l.group = o)),
        e++,
        l
      );
    }
    return {
      opaque: n,
      transmissive: i,
      transparent: r,
      init: function () {
        (e = 0), (n.length = 0), (i.length = 0), (r.length = 0);
      },
      push: function (t, e, a, o, l, c) {
        const h = s(t, e, a, o, l, c);
        a.transmission > 0
          ? i.push(h)
          : !0 === a.transparent
          ? r.push(h)
          : n.push(h);
      },
      unshift: function (t, e, a, o, l, c) {
        const h = s(t, e, a, o, l, c);
        a.transmission > 0
          ? i.unshift(h)
          : !0 === a.transparent
          ? r.unshift(h)
          : n.unshift(h);
      },
      finish: function () {
        for (let n = e, i = t.length; n < i; n++) {
          const e = t[n];
          if (null === e.id) break;
          (e.id = null),
            (e.object = null),
            (e.geometry = null),
            (e.material = null),
            (e.group = null);
        }
      },
      sort: function (t, e) {
        n.length > 1 && n.sort(t || Rs),
          i.length > 1 && i.sort(e || Cs),
          r.length > 1 && r.sort(e || Cs);
      },
    };
  }
  function Ls() {
    let t = new WeakMap();
    return {
      get: function (e, n) {
        const i = t.get(e);
        let r;
        return (
          void 0 === i
            ? ((r = new Ps()), t.set(e, [r]))
            : n >= i.length
            ? ((r = new Ps()), i.push(r))
            : (r = i[n]),
          r
        );
      },
      dispose: function () {
        t = new WeakMap();
      },
    };
  }
  function Ds() {
    const t = {};
    return {
      get: function (e) {
        if (void 0 !== t[e.id]) return t[e.id];
        let n;
        switch (e.type) {
          case "DirectionalLight":
            n = { direction: new Yt(), color: new pn() };
            break;
          case "SpotLight":
            n = {
              position: new Yt(),
              direction: new Yt(),
              color: new pn(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,
            };
            break;
          case "PointLight":
            n = { position: new Yt(), color: new pn(), distance: 0, decay: 0 };
            break;
          case "HemisphereLight":
            n = {
              direction: new Yt(),
              skyColor: new pn(),
              groundColor: new pn(),
            };
            break;
          case "RectAreaLight":
            n = {
              color: new pn(),
              position: new Yt(),
              halfWidth: new Yt(),
              halfHeight: new Yt(),
            };
        }
        return (t[e.id] = n), n;
      },
    };
  }
  let Is = 0;
  function Us(t, e) {
    return (
      (e.castShadow ? 2 : 0) -
      (t.castShadow ? 2 : 0) +
      (e.map ? 1 : 0) -
      (t.map ? 1 : 0)
    );
  }
  function Ns(t, e) {
    const n = new Ds(),
      i = (function () {
        const t = {};
        return {
          get: function (e) {
            if (void 0 !== t[e.id]) return t[e.id];
            let n;
            switch (e.type) {
              case "DirectionalLight":
              case "SpotLight":
                n = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new xt(),
                };
                break;
              case "PointLight":
                n = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new xt(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3,
                };
            }
            return (t[e.id] = n), n;
          },
        };
      })(),
      r = {
        version: 0,
        hash: {
          directionalLength: -1,
          pointLength: -1,
          spotLength: -1,
          rectAreaLength: -1,
          hemiLength: -1,
          numDirectionalShadows: -1,
          numPointShadows: -1,
          numSpotShadows: -1,
          numSpotMaps: -1,
          numLightProbes: -1,
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0,
      };
    for (let t = 0; t < 9; t++) r.probe.push(new Yt());
    const s = new Yt(),
      a = new be(),
      o = new be();
    return {
      setup: function (s, a) {
        let o = 0,
          l = 0,
          c = 0;
        for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
        let h = 0,
          u = 0,
          d = 0,
          p = 0,
          f = 0,
          m = 0,
          g = 0,
          _ = 0,
          v = 0,
          y = 0,
          x = 0;
        s.sort(Us);
        const T = !0 === a ? Math.PI : 1;
        for (let t = 0, e = s.length; t < e; t++) {
          const e = s[t],
            a = e.color,
            M = e.intensity,
            S = e.distance,
            b = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
          if (e.isAmbientLight)
            (o += a.r * M * T), (l += a.g * M * T), (c += a.b * M * T);
          else if (e.isLightProbe) {
            for (let t = 0; t < 9; t++)
              r.probe[t].addScaledVector(e.sh.coefficients[t], M);
            x++;
          } else if (e.isDirectionalLight) {
            const t = n.get(e);
            if (
              (t.color.copy(e.color).multiplyScalar(e.intensity * T),
              e.castShadow)
            ) {
              const t = e.shadow,
                n = i.get(e);
              (n.shadowBias = t.bias),
                (n.shadowNormalBias = t.normalBias),
                (n.shadowRadius = t.radius),
                (n.shadowMapSize = t.mapSize),
                (r.directionalShadow[h] = n),
                (r.directionalShadowMap[h] = b),
                (r.directionalShadowMatrix[h] = e.shadow.matrix),
                m++;
            }
            (r.directional[h] = t), h++;
          } else if (e.isSpotLight) {
            const t = n.get(e);
            t.position.setFromMatrixPosition(e.matrixWorld),
              t.color.copy(a).multiplyScalar(M * T),
              (t.distance = S),
              (t.coneCos = Math.cos(e.angle)),
              (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
              (t.decay = e.decay),
              (r.spot[d] = t);
            const s = e.shadow;
            if (
              (e.map &&
                ((r.spotLightMap[v] = e.map),
                v++,
                s.updateMatrices(e),
                e.castShadow && y++),
              (r.spotLightMatrix[d] = s.matrix),
              e.castShadow)
            ) {
              const t = i.get(e);
              (t.shadowBias = s.bias),
                (t.shadowNormalBias = s.normalBias),
                (t.shadowRadius = s.radius),
                (t.shadowMapSize = s.mapSize),
                (r.spotShadow[d] = t),
                (r.spotShadowMap[d] = b),
                _++;
            }
            d++;
          } else if (e.isRectAreaLight) {
            const t = n.get(e);
            t.color.copy(a).multiplyScalar(M),
              t.halfWidth.set(0.5 * e.width, 0, 0),
              t.halfHeight.set(0, 0.5 * e.height, 0),
              (r.rectArea[p] = t),
              p++;
          } else if (e.isPointLight) {
            const t = n.get(e);
            if (
              (t.color.copy(e.color).multiplyScalar(e.intensity * T),
              (t.distance = e.distance),
              (t.decay = e.decay),
              e.castShadow)
            ) {
              const t = e.shadow,
                n = i.get(e);
              (n.shadowBias = t.bias),
                (n.shadowNormalBias = t.normalBias),
                (n.shadowRadius = t.radius),
                (n.shadowMapSize = t.mapSize),
                (n.shadowCameraNear = t.camera.near),
                (n.shadowCameraFar = t.camera.far),
                (r.pointShadow[u] = n),
                (r.pointShadowMap[u] = b),
                (r.pointShadowMatrix[u] = e.shadow.matrix),
                g++;
            }
            (r.point[u] = t), u++;
          } else if (e.isHemisphereLight) {
            const t = n.get(e);
            t.skyColor.copy(e.color).multiplyScalar(M * T),
              t.groundColor.copy(e.groundColor).multiplyScalar(M * T),
              (r.hemi[f] = t),
              f++;
          }
        }
        p > 0 &&
          (e.isWebGL2
            ? !0 === t.has("OES_texture_float_linear")
              ? ((r.rectAreaLTC1 = xi.LTC_FLOAT_1),
                (r.rectAreaLTC2 = xi.LTC_FLOAT_2))
              : ((r.rectAreaLTC1 = xi.LTC_HALF_1),
                (r.rectAreaLTC2 = xi.LTC_HALF_2))
            : !0 === t.has("OES_texture_float_linear")
            ? ((r.rectAreaLTC1 = xi.LTC_FLOAT_1),
              (r.rectAreaLTC2 = xi.LTC_FLOAT_2))
            : !0 === t.has("OES_texture_half_float_linear")
            ? ((r.rectAreaLTC1 = xi.LTC_HALF_1),
              (r.rectAreaLTC2 = xi.LTC_HALF_2))
            : console.error(
                "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
              )),
          (r.ambient[0] = o),
          (r.ambient[1] = l),
          (r.ambient[2] = c);
        const M = r.hash;
        (M.directionalLength === h &&
          M.pointLength === u &&
          M.spotLength === d &&
          M.rectAreaLength === p &&
          M.hemiLength === f &&
          M.numDirectionalShadows === m &&
          M.numPointShadows === g &&
          M.numSpotShadows === _ &&
          M.numSpotMaps === v &&
          M.numLightProbes === x) ||
          ((r.directional.length = h),
          (r.spot.length = d),
          (r.rectArea.length = p),
          (r.point.length = u),
          (r.hemi.length = f),
          (r.directionalShadow.length = m),
          (r.directionalShadowMap.length = m),
          (r.pointShadow.length = g),
          (r.pointShadowMap.length = g),
          (r.spotShadow.length = _),
          (r.spotShadowMap.length = _),
          (r.directionalShadowMatrix.length = m),
          (r.pointShadowMatrix.length = g),
          (r.spotLightMatrix.length = _ + v - y),
          (r.spotLightMap.length = v),
          (r.numSpotLightShadowsWithMaps = y),
          (r.numLightProbes = x),
          (M.directionalLength = h),
          (M.pointLength = u),
          (M.spotLength = d),
          (M.rectAreaLength = p),
          (M.hemiLength = f),
          (M.numDirectionalShadows = m),
          (M.numPointShadows = g),
          (M.numSpotShadows = _),
          (M.numSpotMaps = v),
          (M.numLightProbes = x),
          (r.version = Is++));
      },
      setupView: function (t, e) {
        let n = 0,
          i = 0,
          l = 0,
          c = 0,
          h = 0;
        const u = e.matrixWorldInverse;
        for (let e = 0, d = t.length; e < d; e++) {
          const d = t[e];
          if (d.isDirectionalLight) {
            const t = r.directional[n];
            t.direction.setFromMatrixPosition(d.matrixWorld),
              s.setFromMatrixPosition(d.target.matrixWorld),
              t.direction.sub(s),
              t.direction.transformDirection(u),
              n++;
          } else if (d.isSpotLight) {
            const t = r.spot[l];
            t.position.setFromMatrixPosition(d.matrixWorld),
              t.position.applyMatrix4(u),
              t.direction.setFromMatrixPosition(d.matrixWorld),
              s.setFromMatrixPosition(d.target.matrixWorld),
              t.direction.sub(s),
              t.direction.transformDirection(u),
              l++;
          } else if (d.isRectAreaLight) {
            const t = r.rectArea[c];
            t.position.setFromMatrixPosition(d.matrixWorld),
              t.position.applyMatrix4(u),
              o.identity(),
              a.copy(d.matrixWorld),
              a.premultiply(u),
              o.extractRotation(a),
              t.halfWidth.set(0.5 * d.width, 0, 0),
              t.halfHeight.set(0, 0.5 * d.height, 0),
              t.halfWidth.applyMatrix4(o),
              t.halfHeight.applyMatrix4(o),
              c++;
          } else if (d.isPointLight) {
            const t = r.point[i];
            t.position.setFromMatrixPosition(d.matrixWorld),
              t.position.applyMatrix4(u),
              i++;
          } else if (d.isHemisphereLight) {
            const t = r.hemi[h];
            t.direction.setFromMatrixPosition(d.matrixWorld),
              t.direction.transformDirection(u),
              h++;
          }
        }
      },
      state: r,
    };
  }
  function Os(t, e) {
    const n = new Ns(t, e),
      i = [],
      r = [];
    return {
      init: function () {
        (i.length = 0), (r.length = 0);
      },
      state: { lightsArray: i, shadowsArray: r, lights: n },
      setupLights: function (t) {
        n.setup(i, t);
      },
      setupLightsView: function (t) {
        n.setupView(i, t);
      },
      pushLight: function (t) {
        i.push(t);
      },
      pushShadow: function (t) {
        r.push(t);
      },
    };
  }
  function Fs(t, e) {
    let n = new WeakMap();
    return {
      get: function (i, r = 0) {
        const s = n.get(i);
        let a;
        return (
          void 0 === s
            ? ((a = new Os(t, e)), n.set(i, [a]))
            : r >= s.length
            ? ((a = new Os(t, e)), s.push(a))
            : (a = s[r]),
          a
        );
      },
      dispose: function () {
        n = new WeakMap();
      },
    };
  }
  class ks extends gn {
    constructor(t) {
      super(),
        (this.isMeshDepthMaterial = !0),
        (this.type = "MeshDepthMaterial"),
        (this.depthPacking = 3200),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.depthPacking = t.depthPacking),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        this
      );
    }
  }
  class zs extends gn {
    constructor(t) {
      super(),
        (this.isMeshDistanceMaterial = !0),
        (this.type = "MeshDistanceMaterial"),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        this
      );
    }
  }
  function Bs(t, e, i) {
    let s = new mi();
    const a = new xt(),
      o = new xt(),
      l = new Gt(),
      c = new ks({ depthPacking: 3201 }),
      h = new zs(),
      u = {},
      d = i.maxTextureSize,
      p = { 0: 1, 1: 0, 2: 2 },
      f = new ni({
        defines: { VSM_SAMPLES: 8 },
        uniforms: {
          shadow_pass: { value: null },
          resolution: { value: new xt() },
          radius: { value: 4 },
        },
        vertexShader:
          "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
        fragmentShader:
          "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
      }),
      m = f.clone();
    m.defines.HORIZONTAL_PASS = 1;
    const g = new Ln();
    g.setAttribute(
      "position",
      new xn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
    );
    const _ = new Kn(g, f),
      v = this;
    (this.enabled = !1),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this.type = n);
    let y = this.type;
    function x(n, i) {
      const r = e.update(_);
      f.defines.VSM_SAMPLES !== n.blurSamples &&
        ((f.defines.VSM_SAMPLES = n.blurSamples),
        (m.defines.VSM_SAMPLES = n.blurSamples),
        (f.needsUpdate = !0),
        (m.needsUpdate = !0)),
        null === n.mapPass && (n.mapPass = new Wt(a.x, a.y)),
        (f.uniforms.shadow_pass.value = n.map.texture),
        (f.uniforms.resolution.value = n.mapSize),
        (f.uniforms.radius.value = n.radius),
        t.setRenderTarget(n.mapPass),
        t.clear(),
        t.renderBufferDirect(i, null, r, f, _, null),
        (m.uniforms.shadow_pass.value = n.mapPass.texture),
        (m.uniforms.resolution.value = n.mapSize),
        (m.uniforms.radius.value = n.radius),
        t.setRenderTarget(n.map),
        t.clear(),
        t.renderBufferDirect(i, null, r, m, _, null);
    }
    function T(e, n, i, s) {
      let a = null;
      const o =
        !0 === i.isPointLight
          ? e.customDistanceMaterial
          : e.customDepthMaterial;
      if (void 0 !== o) a = o;
      else if (
        ((a = !0 === i.isPointLight ? h : c),
        (t.localClippingEnabled &&
          !0 === n.clipShadows &&
          Array.isArray(n.clippingPlanes) &&
          0 !== n.clippingPlanes.length) ||
          (n.displacementMap && 0 !== n.displacementScale) ||
          (n.alphaMap && n.alphaTest > 0) ||
          (n.map && n.alphaTest > 0))
      ) {
        const t = a.uuid,
          e = n.uuid;
        let i = u[t];
        void 0 === i && ((i = {}), (u[t] = i));
        let r = i[e];
        void 0 === r &&
          ((r = a.clone()), (i[e] = r), n.addEventListener("dispose", b)),
          (a = r);
      }
      return (
        (a.visible = n.visible),
        (a.wireframe = n.wireframe),
        (a.side =
          s === r
            ? null !== n.shadowSide
              ? n.shadowSide
              : n.side
            : null !== n.shadowSide
            ? n.shadowSide
            : p[n.side]),
        (a.alphaMap = n.alphaMap),
        (a.alphaTest = n.alphaTest),
        (a.map = n.map),
        (a.clipShadows = n.clipShadows),
        (a.clippingPlanes = n.clippingPlanes),
        (a.clipIntersection = n.clipIntersection),
        (a.displacementMap = n.displacementMap),
        (a.displacementScale = n.displacementScale),
        (a.displacementBias = n.displacementBias),
        (a.wireframeLinewidth = n.wireframeLinewidth),
        (a.linewidth = n.linewidth),
        !0 === i.isPointLight &&
          !0 === a.isMeshDistanceMaterial &&
          (t.properties.get(a).light = i),
        a
      );
    }
    function M(n, i, a, o, l) {
      if (!1 === n.visible) return;
      if (
        n.layers.test(i.layers) &&
        (n.isMesh || n.isLine || n.isPoints) &&
        (n.castShadow || (n.receiveShadow && l === r)) &&
        (!n.frustumCulled || s.intersectsObject(n))
      ) {
        n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
        const r = e.update(n),
          s = n.material;
        if (Array.isArray(s)) {
          const e = r.groups;
          for (let c = 0, h = e.length; c < h; c++) {
            const h = e[c],
              u = s[h.materialIndex];
            if (u && u.visible) {
              const e = T(n, u, o, l);
              n.onBeforeShadow(t, n, i, a, r, e, h),
                t.renderBufferDirect(a, null, r, e, n, h),
                n.onAfterShadow(t, n, i, a, r, e, h);
            }
          }
        } else if (s.visible) {
          const e = T(n, s, o, l);
          n.onBeforeShadow(t, n, i, a, r, e, null),
            t.renderBufferDirect(a, null, r, e, n, null),
            n.onAfterShadow(t, n, i, a, r, e, null);
        }
      }
      const c = n.children;
      for (let t = 0, e = c.length; t < e; t++) M(c[t], i, a, o, l);
    }
    function b(t) {
      t.target.removeEventListener("dispose", b);
      for (const e in u) {
        const n = u[e],
          i = t.target.uuid;
        i in n && (n[i].dispose(), delete n[i]);
      }
    }
    this.render = function (e, n, i) {
      if (!1 === v.enabled) return;
      if (!1 === v.autoUpdate && !1 === v.needsUpdate) return;
      if (0 === e.length) return;
      const c = t.getRenderTarget(),
        h = t.getActiveCubeFace(),
        u = t.getActiveMipmapLevel(),
        p = t.state;
      p.setBlending(0),
        p.buffers.color.setClear(1, 1, 1, 1),
        p.buffers.depth.setTest(!0),
        p.setScissorTest(!1);
      const f = y !== r && this.type === r,
        m = y === r && this.type !== r;
      for (let c = 0, h = e.length; c < h; c++) {
        const h = e[c],
          u = h.shadow;
        if (void 0 === u) {
          console.warn("THREE.WebGLShadowMap:", h, "has no shadow.");
          continue;
        }
        if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
        a.copy(u.mapSize);
        const g = u.getFrameExtents();
        if (
          (a.multiply(g),
          o.copy(u.mapSize),
          (a.x > d || a.y > d) &&
            (a.x > d &&
              ((o.x = Math.floor(d / g.x)),
              (a.x = o.x * g.x),
              (u.mapSize.x = o.x)),
            a.y > d &&
              ((o.y = Math.floor(d / g.y)),
              (a.y = o.y * g.y),
              (u.mapSize.y = o.y))),
          null === u.map || !0 === f || !0 === m)
        ) {
          const t = this.type !== r ? { minFilter: S, magFilter: S } : {};
          null !== u.map && u.map.dispose(),
            (u.map = new Wt(a.x, a.y, t)),
            (u.map.texture.name = h.name + ".shadowMap"),
            u.camera.updateProjectionMatrix();
        }
        t.setRenderTarget(u.map), t.clear();
        const _ = u.getViewportCount();
        for (let t = 0; t < _; t++) {
          const e = u.getViewport(t);
          l.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w),
            p.viewport(l),
            u.updateMatrices(h, t),
            (s = u.getFrustum()),
            M(n, i, u.camera, h, this.type);
        }
        !0 !== u.isPointLightShadow && this.type === r && x(u, i),
          (u.needsUpdate = !1);
      }
      (y = this.type), (v.needsUpdate = !1), t.setRenderTarget(c, h, u);
    };
  }
  function Hs(t, e, n) {
    const i = n.isWebGL2,
      r = new (function () {
        let e = !1;
        const n = new Gt();
        let i = null;
        const r = new Gt(0, 0, 0, 0);
        return {
          setMask: function (n) {
            i === n || e || (t.colorMask(n, n, n, n), (i = n));
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (e, i, s, a, o) {
            !0 === o && ((e *= a), (i *= a), (s *= a)),
              n.set(e, i, s, a),
              !1 === r.equals(n) && (t.clearColor(e, i, s, a), r.copy(n));
          },
          reset: function () {
            (e = !1), (i = null), r.set(-1, 0, 0, 0);
          },
        };
      })(),
      a = new (function () {
        let e = !1,
          n = null,
          i = null,
          r = null;
        return {
          setTest: function (e) {
            e ? V(t.DEPTH_TEST) : W(t.DEPTH_TEST);
          },
          setMask: function (i) {
            n === i || e || (t.depthMask(i), (n = i));
          },
          setFunc: function (e) {
            if (i !== e) {
              switch (e) {
                case 0:
                  t.depthFunc(t.NEVER);
                  break;
                case 1:
                  t.depthFunc(t.ALWAYS);
                  break;
                case 2:
                  t.depthFunc(t.LESS);
                  break;
                case 3:
                default:
                  t.depthFunc(t.LEQUAL);
                  break;
                case 4:
                  t.depthFunc(t.EQUAL);
                  break;
                case 5:
                  t.depthFunc(t.GEQUAL);
                  break;
                case 6:
                  t.depthFunc(t.GREATER);
                  break;
                case 7:
                  t.depthFunc(t.NOTEQUAL);
              }
              i = e;
            }
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (e) {
            r !== e && (t.clearDepth(e), (r = e));
          },
          reset: function () {
            (e = !1), (n = null), (i = null), (r = null);
          },
        };
      })(),
      o = new (function () {
        let e = !1,
          n = null,
          i = null,
          r = null,
          s = null,
          a = null,
          o = null,
          l = null,
          c = null;
        return {
          setTest: function (n) {
            e || (n ? V(t.STENCIL_TEST) : W(t.STENCIL_TEST));
          },
          setMask: function (i) {
            n === i || e || (t.stencilMask(i), (n = i));
          },
          setFunc: function (e, n, a) {
            (i === e && r === n && s === a) ||
              (t.stencilFunc(e, n, a), (i = e), (r = n), (s = a));
          },
          setOp: function (e, n, i) {
            (a === e && o === n && l === i) ||
              (t.stencilOp(e, n, i), (a = e), (o = n), (l = i));
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (e) {
            c !== e && (t.clearStencil(e), (c = e));
          },
          reset: function () {
            (e = !1),
              (n = null),
              (i = null),
              (r = null),
              (s = null),
              (a = null),
              (o = null),
              (l = null),
              (c = null);
          },
        };
      })(),
      l = new WeakMap(),
      c = new WeakMap();
    let h = {},
      u = {},
      d = new WeakMap(),
      p = [],
      f = null,
      m = !1,
      g = null,
      _ = null,
      v = null,
      y = null,
      x = null,
      T = null,
      M = null,
      S = new pn(0, 0, 0),
      b = 0,
      E = !1,
      w = null,
      A = null,
      R = null,
      C = null,
      P = null;
    const L = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let D = !1,
      I = 0;
    const U = t.getParameter(t.VERSION);
    -1 !== U.indexOf("WebGL")
      ? ((I = parseFloat(/^WebGL (\d)/.exec(U)[1])), (D = I >= 1))
      : -1 !== U.indexOf("OpenGL ES") &&
        ((I = parseFloat(/^OpenGL ES (\d)/.exec(U)[1])), (D = I >= 2));
    let N = null,
      O = {};
    const F = t.getParameter(t.SCISSOR_BOX),
      k = t.getParameter(t.VIEWPORT),
      z = new Gt().fromArray(F),
      B = new Gt().fromArray(k);
    function H(e, n, r, s) {
      const a = new Uint8Array(4),
        o = t.createTexture();
      t.bindTexture(e, o),
        t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
        t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
      for (let o = 0; o < r; o++)
        !i || (e !== t.TEXTURE_3D && e !== t.TEXTURE_2D_ARRAY)
          ? t.texImage2D(n + o, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, a)
          : t.texImage3D(n, 0, t.RGBA, 1, 1, s, 0, t.RGBA, t.UNSIGNED_BYTE, a);
      return o;
    }
    const G = {};
    function V(e) {
      !0 !== h[e] && (t.enable(e), (h[e] = !0));
    }
    function W(e) {
      !1 !== h[e] && (t.disable(e), (h[e] = !1));
    }
    (G[t.TEXTURE_2D] = H(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
      (G[t.TEXTURE_CUBE_MAP] = H(
        t.TEXTURE_CUBE_MAP,
        t.TEXTURE_CUBE_MAP_POSITIVE_X,
        6
      )),
      i &&
        ((G[t.TEXTURE_2D_ARRAY] = H(
          t.TEXTURE_2D_ARRAY,
          t.TEXTURE_2D_ARRAY,
          1,
          1
        )),
        (G[t.TEXTURE_3D] = H(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1))),
      r.setClear(0, 0, 0, 1),
      a.setClear(1),
      o.setClear(0),
      V(t.DEPTH_TEST),
      a.setFunc(3),
      Y(!1),
      K(1),
      V(t.CULL_FACE),
      q(0);
    const X = {
      [s]: t.FUNC_ADD,
      101: t.FUNC_SUBTRACT,
      102: t.FUNC_REVERSE_SUBTRACT,
    };
    if (i) (X[103] = t.MIN), (X[104] = t.MAX);
    else {
      const t = e.get("EXT_blend_minmax");
      null !== t && ((X[103] = t.MIN_EXT), (X[104] = t.MAX_EXT));
    }
    const j = {
      200: t.ZERO,
      201: t.ONE,
      202: t.SRC_COLOR,
      204: t.SRC_ALPHA,
      210: t.SRC_ALPHA_SATURATE,
      208: t.DST_COLOR,
      206: t.DST_ALPHA,
      203: t.ONE_MINUS_SRC_COLOR,
      205: t.ONE_MINUS_SRC_ALPHA,
      209: t.ONE_MINUS_DST_COLOR,
      207: t.ONE_MINUS_DST_ALPHA,
      211: t.CONSTANT_COLOR,
      212: t.ONE_MINUS_CONSTANT_COLOR,
      213: t.CONSTANT_ALPHA,
      214: t.ONE_MINUS_CONSTANT_ALPHA,
    };
    function q(e, n, i, r, a, o, l, c, h, u) {
      if (0 !== e) {
        if ((!1 === m && (V(t.BLEND), (m = !0)), 5 === e))
          (a = a || n),
            (o = o || i),
            (l = l || r),
            (n === _ && a === x) ||
              (t.blendEquationSeparate(X[n], X[a]), (_ = n), (x = a)),
            (i === v && r === y && o === T && l === M) ||
              (t.blendFuncSeparate(j[i], j[r], j[o], j[l]),
              (v = i),
              (y = r),
              (T = o),
              (M = l)),
            (!1 !== c.equals(S) && h === b) ||
              (t.blendColor(c.r, c.g, c.b, h), S.copy(c), (b = h)),
            (g = e),
            (E = !1);
        else if (e !== g || u !== E) {
          if (
            ((_ === s && x === s) ||
              (t.blendEquation(t.FUNC_ADD), (_ = s), (x = s)),
            u)
          )
            switch (e) {
              case 1:
                t.blendFuncSeparate(
                  t.ONE,
                  t.ONE_MINUS_SRC_ALPHA,
                  t.ONE,
                  t.ONE_MINUS_SRC_ALPHA
                );
                break;
              case 2:
                t.blendFunc(t.ONE, t.ONE);
                break;
              case 3:
                t.blendFuncSeparate(
                  t.ZERO,
                  t.ONE_MINUS_SRC_COLOR,
                  t.ZERO,
                  t.ONE
                );
                break;
              case 4:
                t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e);
            }
          else
            switch (e) {
              case 1:
                t.blendFuncSeparate(
                  t.SRC_ALPHA,
                  t.ONE_MINUS_SRC_ALPHA,
                  t.ONE,
                  t.ONE_MINUS_SRC_ALPHA
                );
                break;
              case 2:
                t.blendFunc(t.SRC_ALPHA, t.ONE);
                break;
              case 3:
                t.blendFuncSeparate(
                  t.ZERO,
                  t.ONE_MINUS_SRC_COLOR,
                  t.ZERO,
                  t.ONE
                );
                break;
              case 4:
                t.blendFunc(t.ZERO, t.SRC_COLOR);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e);
            }
          (v = null),
            (y = null),
            (T = null),
            (M = null),
            S.set(0, 0, 0),
            (b = 0),
            (g = e),
            (E = u);
        }
      } else !0 === m && (W(t.BLEND), (m = !1));
    }
    function Y(e) {
      w !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), (w = e));
    }
    function K(e) {
      0 !== e
        ? (V(t.CULL_FACE),
          e !== A &&
            (1 === e
              ? t.cullFace(t.BACK)
              : 2 === e
              ? t.cullFace(t.FRONT)
              : t.cullFace(t.FRONT_AND_BACK)))
        : W(t.CULL_FACE),
        (A = e);
    }
    function Z(e, n, i) {
      e
        ? (V(t.POLYGON_OFFSET_FILL),
          (C === n && P === i) || (t.polygonOffset(n, i), (C = n), (P = i)))
        : W(t.POLYGON_OFFSET_FILL);
    }
    return {
      buffers: { color: r, depth: a, stencil: o },
      enable: V,
      disable: W,
      bindFramebuffer: function (e, n) {
        return (
          u[e] !== n &&
          (t.bindFramebuffer(e, n),
          (u[e] = n),
          i &&
            (e === t.DRAW_FRAMEBUFFER && (u[t.FRAMEBUFFER] = n),
            e === t.FRAMEBUFFER && (u[t.DRAW_FRAMEBUFFER] = n)),
          !0)
        );
      },
      drawBuffers: function (i, r) {
        let s = p,
          a = !1;
        if (i)
          if (
            ((s = d.get(r)),
            void 0 === s && ((s = []), d.set(r, s)),
            i.isWebGLMultipleRenderTargets)
          ) {
            const e = i.texture;
            if (s.length !== e.length || s[0] !== t.COLOR_ATTACHMENT0) {
              for (let n = 0, i = e.length; n < i; n++)
                s[n] = t.COLOR_ATTACHMENT0 + n;
              (s.length = e.length), (a = !0);
            }
          } else
            s[0] !== t.COLOR_ATTACHMENT0 &&
              ((s[0] = t.COLOR_ATTACHMENT0), (a = !0));
        else s[0] !== t.BACK && ((s[0] = t.BACK), (a = !0));
        a &&
          (n.isWebGL2
            ? t.drawBuffers(s)
            : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s));
      },
      useProgram: function (e) {
        return f !== e && (t.useProgram(e), (f = e), !0);
      },
      setBlending: q,
      setMaterial: function (e, n) {
        2 === e.side ? W(t.CULL_FACE) : V(t.CULL_FACE);
        let i = 1 === e.side;
        n && (i = !i),
          Y(i),
          1 === e.blending && !1 === e.transparent
            ? q(0)
            : q(
                e.blending,
                e.blendEquation,
                e.blendSrc,
                e.blendDst,
                e.blendEquationAlpha,
                e.blendSrcAlpha,
                e.blendDstAlpha,
                e.blendColor,
                e.blendAlpha,
                e.premultipliedAlpha
              ),
          a.setFunc(e.depthFunc),
          a.setTest(e.depthTest),
          a.setMask(e.depthWrite),
          r.setMask(e.colorWrite);
        const s = e.stencilWrite;
        o.setTest(s),
          s &&
            (o.setMask(e.stencilWriteMask),
            o.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
            o.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
          Z(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
          !0 === e.alphaToCoverage
            ? V(t.SAMPLE_ALPHA_TO_COVERAGE)
            : W(t.SAMPLE_ALPHA_TO_COVERAGE);
      },
      setFlipSided: Y,
      setCullFace: K,
      setLineWidth: function (e) {
        e !== R && (D && t.lineWidth(e), (R = e));
      },
      setPolygonOffset: Z,
      setScissorTest: function (e) {
        e ? V(t.SCISSOR_TEST) : W(t.SCISSOR_TEST);
      },
      activeTexture: function (e) {
        void 0 === e && (e = t.TEXTURE0 + L - 1),
          N !== e && (t.activeTexture(e), (N = e));
      },
      bindTexture: function (e, n, i) {
        void 0 === i && (i = null === N ? t.TEXTURE0 + L - 1 : N);
        let r = O[i];
        void 0 === r && ((r = { type: void 0, texture: void 0 }), (O[i] = r)),
          (r.type === e && r.texture === n) ||
            (N !== i && (t.activeTexture(i), (N = i)),
            t.bindTexture(e, n || G[e]),
            (r.type = e),
            (r.texture = n));
      },
      unbindTexture: function () {
        const e = O[N];
        void 0 !== e &&
          void 0 !== e.type &&
          (t.bindTexture(e.type, null),
          (e.type = void 0),
          (e.texture = void 0));
      },
      compressedTexImage2D: function () {
        try {
          t.compressedTexImage2D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      compressedTexImage3D: function () {
        try {
          t.compressedTexImage3D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      texImage2D: function () {
        try {
          t.texImage2D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      texImage3D: function () {
        try {
          t.texImage3D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      updateUBOMapping: function (e, n) {
        let i = c.get(n);
        void 0 === i && ((i = new WeakMap()), c.set(n, i));
        let r = i.get(e);
        void 0 === r && ((r = t.getUniformBlockIndex(n, e.name)), i.set(e, r));
      },
      uniformBlockBinding: function (e, n) {
        const i = c.get(n).get(e);
        l.get(n) !== i &&
          (t.uniformBlockBinding(n, i, e.__bindingPointIndex), l.set(n, i));
      },
      texStorage2D: function () {
        try {
          t.texStorage2D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      texStorage3D: function () {
        try {
          t.texStorage3D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      texSubImage2D: function () {
        try {
          t.texSubImage2D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      texSubImage3D: function () {
        try {
          t.texSubImage3D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      compressedTexSubImage2D: function () {
        try {
          t.compressedTexSubImage2D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      compressedTexSubImage3D: function () {
        try {
          t.compressedTexSubImage3D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      scissor: function (e) {
        !1 === z.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), z.copy(e));
      },
      viewport: function (e) {
        !1 === B.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), B.copy(e));
      },
      reset: function () {
        t.disable(t.BLEND),
          t.disable(t.CULL_FACE),
          t.disable(t.DEPTH_TEST),
          t.disable(t.POLYGON_OFFSET_FILL),
          t.disable(t.SCISSOR_TEST),
          t.disable(t.STENCIL_TEST),
          t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
          t.blendEquation(t.FUNC_ADD),
          t.blendFunc(t.ONE, t.ZERO),
          t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
          t.blendColor(0, 0, 0, 0),
          t.colorMask(!0, !0, !0, !0),
          t.clearColor(0, 0, 0, 0),
          t.depthMask(!0),
          t.depthFunc(t.LESS),
          t.clearDepth(1),
          t.stencilMask(4294967295),
          t.stencilFunc(t.ALWAYS, 0, 4294967295),
          t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
          t.clearStencil(0),
          t.cullFace(t.BACK),
          t.frontFace(t.CCW),
          t.polygonOffset(0, 0),
          t.activeTexture(t.TEXTURE0),
          t.bindFramebuffer(t.FRAMEBUFFER, null),
          !0 === i &&
            (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
            t.bindFramebuffer(t.READ_FRAMEBUFFER, null)),
          t.useProgram(null),
          t.lineWidth(1),
          t.scissor(0, 0, t.canvas.width, t.canvas.height),
          t.viewport(0, 0, t.canvas.width, t.canvas.height),
          (h = {}),
          (N = null),
          (O = {}),
          (u = {}),
          (d = new WeakMap()),
          (p = []),
          (f = null),
          (m = !1),
          (g = null),
          (_ = null),
          (v = null),
          (y = null),
          (x = null),
          (T = null),
          (M = null),
          (S = new pn(0, 0, 0)),
          (b = 0),
          (E = !1),
          (w = null),
          (A = null),
          (R = null),
          (C = null),
          (P = null),
          z.set(0, 0, t.canvas.width, t.canvas.height),
          B.set(0, 0, t.canvas.width, t.canvas.height),
          r.reset(),
          a.reset(),
          o.reset();
      },
    };
  }
  function Gs(t, e, n, i, r, s, a) {
    const o = r.isWebGL2,
      l = e.has("WEBGL_multisampled_render_to_texture")
        ? e.get("WEBGL_multisampled_render_to_texture")
        : null,
      c =
        "undefined" != typeof navigator &&
        /OculusBrowser/g.test(navigator.userAgent),
      h = new WeakMap();
    let u;
    const d = new WeakMap();
    let p = !1;
    try {
      p =
        "undefined" != typeof OffscreenCanvas &&
        null !== new OffscreenCanvas(1, 1).getContext("2d");
    } catch (t) {}
    function f(t, e) {
      return p ? new OffscreenCanvas(t, e) : bt("canvas");
    }
    function m(t, e, n, i) {
      let r = 1;
      if (
        ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)),
        r < 1 || !0 === e)
      ) {
        if (
          ("undefined" != typeof HTMLImageElement &&
            t instanceof HTMLImageElement) ||
          ("undefined" != typeof HTMLCanvasElement &&
            t instanceof HTMLCanvasElement) ||
          ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
        ) {
          const i = e ? gt : Math.floor,
            s = i(r * t.width),
            a = i(r * t.height);
          void 0 === u && (u = f(s, a));
          const o = n ? f(s, a) : u;
          return (
            (o.width = s),
            (o.height = a),
            o.getContext("2d").drawImage(t, 0, 0, s, a),
            console.warn(
              "THREE.WebGLRenderer: Texture has been resized from (" +
                t.width +
                "x" +
                t.height +
                ") to (" +
                s +
                "x" +
                a +
                ")."
            ),
            o
          );
        }
        return (
          "data" in t &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                t.width +
                "x" +
                t.height +
                ")."
            ),
          t
        );
      }
      return t;
    }
    function g(t) {
      return mt(t.width) && mt(t.height);
    }
    function _(t, e) {
      return t.generateMipmaps && e && t.minFilter !== S && t.minFilter !== w;
    }
    function v(e) {
      t.generateMipmap(e);
    }
    function y(n, i, r, s, a = !1) {
      if (!1 === o) return i;
      if (null !== n) {
        if (void 0 !== t[n]) return t[n];
        console.warn(
          "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
            n +
            "'"
        );
      }
      let l = i;
      if (
        (i === t.RED &&
          (r === t.FLOAT && (l = t.R32F),
          r === t.HALF_FLOAT && (l = t.R16F),
          r === t.UNSIGNED_BYTE && (l = t.R8)),
        i === t.RED_INTEGER &&
          (r === t.UNSIGNED_BYTE && (l = t.R8UI),
          r === t.UNSIGNED_SHORT && (l = t.R16UI),
          r === t.UNSIGNED_INT && (l = t.R32UI),
          r === t.BYTE && (l = t.R8I),
          r === t.SHORT && (l = t.R16I),
          r === t.INT && (l = t.R32I)),
        i === t.RG &&
          (r === t.FLOAT && (l = t.RG32F),
          r === t.HALF_FLOAT && (l = t.RG16F),
          r === t.UNSIGNED_BYTE && (l = t.RG8)),
        i === t.RGBA)
      ) {
        const e = a ? J : Dt.getTransfer(s);
        r === t.FLOAT && (l = t.RGBA32F),
          r === t.HALF_FLOAT && (l = t.RGBA16F),
          r === t.UNSIGNED_BYTE && (l = e === Q ? t.SRGB8_ALPHA8 : t.RGBA8),
          r === t.UNSIGNED_SHORT_4_4_4_4 && (l = t.RGBA4),
          r === t.UNSIGNED_SHORT_5_5_5_1 && (l = t.RGB5_A1);
      }
      return (
        (l !== t.R16F &&
          l !== t.R32F &&
          l !== t.RG16F &&
          l !== t.RG32F &&
          l !== t.RGBA16F &&
          l !== t.RGBA32F) ||
          e.get("EXT_color_buffer_float"),
        l
      );
    }
    function F(t, e, n) {
      return !0 === _(t, n) ||
        (t.isFramebufferTexture && t.minFilter !== S && t.minFilter !== w)
        ? Math.log2(Math.max(e.width, e.height)) + 1
        : void 0 !== t.mipmaps && t.mipmaps.length > 0
        ? t.mipmaps.length
        : t.isCompressedTexture && Array.isArray(t.image)
        ? e.mipmaps.length
        : 1;
    }
    function k(e) {
      return e === S || e === b || e === E ? t.NEAREST : t.LINEAR;
    }
    function z(t) {
      const e = t.target;
      e.removeEventListener("dispose", z),
        (function (t) {
          const e = i.get(t);
          if (void 0 === e.__webglInit) return;
          const n = t.source,
            r = d.get(n);
          if (r) {
            const i = r[e.__cacheKey];
            i.usedTimes--,
              0 === i.usedTimes && H(t),
              0 === Object.keys(r).length && d.delete(n);
          }
          i.remove(t);
        })(e),
        e.isVideoTexture && h.delete(e);
    }
    function B(e) {
      const n = e.target;
      n.removeEventListener("dispose", B),
        (function (e) {
          const n = e.texture,
            r = i.get(e),
            s = i.get(n);
          if (
            (void 0 !== s.__webglTexture &&
              (t.deleteTexture(s.__webglTexture), a.memory.textures--),
            e.depthTexture && e.depthTexture.dispose(),
            e.isWebGLCubeRenderTarget)
          )
            for (let e = 0; e < 6; e++) {
              if (Array.isArray(r.__webglFramebuffer[e]))
                for (let n = 0; n < r.__webglFramebuffer[e].length; n++)
                  t.deleteFramebuffer(r.__webglFramebuffer[e][n]);
              else t.deleteFramebuffer(r.__webglFramebuffer[e]);
              r.__webglDepthbuffer &&
                t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
            }
          else {
            if (Array.isArray(r.__webglFramebuffer))
              for (let e = 0; e < r.__webglFramebuffer.length; e++)
                t.deleteFramebuffer(r.__webglFramebuffer[e]);
            else t.deleteFramebuffer(r.__webglFramebuffer);
            if (
              (r.__webglDepthbuffer &&
                t.deleteRenderbuffer(r.__webglDepthbuffer),
              r.__webglMultisampledFramebuffer &&
                t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
              r.__webglColorRenderbuffer)
            )
              for (let e = 0; e < r.__webglColorRenderbuffer.length; e++)
                r.__webglColorRenderbuffer[e] &&
                  t.deleteRenderbuffer(r.__webglColorRenderbuffer[e]);
            r.__webglDepthRenderbuffer &&
              t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
          }
          if (e.isWebGLMultipleRenderTargets)
            for (let e = 0, r = n.length; e < r; e++) {
              const r = i.get(n[e]);
              r.__webglTexture &&
                (t.deleteTexture(r.__webglTexture), a.memory.textures--),
                i.remove(n[e]);
            }
          i.remove(n), i.remove(e);
        })(n);
    }
    function H(e) {
      const n = i.get(e);
      t.deleteTexture(n.__webglTexture);
      const r = e.source;
      delete d.get(r)[n.__cacheKey], a.memory.textures--;
    }
    let G = 0;
    function V(e, r) {
      const s = i.get(e);
      if (
        (e.isVideoTexture &&
          (function (t) {
            const e = a.render.frame;
            h.get(t) !== e && (h.set(t, e), t.update());
          })(e),
        !1 === e.isRenderTargetTexture &&
          e.version > 0 &&
          s.__version !== e.version)
      ) {
        const t = e.image;
        if (null === t)
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but no image data found."
          );
        else {
          if (!1 !== t.complete) return void $(s, e, r);
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
          );
        }
      }
      n.bindTexture(t.TEXTURE_2D, s.__webglTexture, t.TEXTURE0 + r);
    }
    const W = { [x]: t.REPEAT, [T]: t.CLAMP_TO_EDGE, [M]: t.MIRRORED_REPEAT },
      X = {
        [S]: t.NEAREST,
        [b]: t.NEAREST_MIPMAP_NEAREST,
        [E]: t.NEAREST_MIPMAP_LINEAR,
        [w]: t.LINEAR,
        1007: t.LINEAR_MIPMAP_NEAREST,
        [A]: t.LINEAR_MIPMAP_LINEAR,
      },
      q = {
        512: t.NEVER,
        519: t.ALWAYS,
        513: t.LESS,
        515: t.LEQUAL,
        514: t.EQUAL,
        518: t.GEQUAL,
        516: t.GREATER,
        517: t.NOTEQUAL,
      };
    function K(n, s, a) {
      if (
        (a
          ? (t.texParameteri(n, t.TEXTURE_WRAP_S, W[s.wrapS]),
            t.texParameteri(n, t.TEXTURE_WRAP_T, W[s.wrapT]),
            (n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY) ||
              t.texParameteri(n, t.TEXTURE_WRAP_R, W[s.wrapR]),
            t.texParameteri(n, t.TEXTURE_MAG_FILTER, X[s.magFilter]),
            t.texParameteri(n, t.TEXTURE_MIN_FILTER, X[s.minFilter]))
          : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
            t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
            (n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY) ||
              t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE),
            (s.wrapS === T && s.wrapT === T) ||
              console.warn(
                "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
              ),
            t.texParameteri(n, t.TEXTURE_MAG_FILTER, k(s.magFilter)),
            t.texParameteri(n, t.TEXTURE_MIN_FILTER, k(s.minFilter)),
            s.minFilter !== S &&
              s.minFilter !== w &&
              console.warn(
                "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
              )),
        s.compareFunction &&
          (t.texParameteri(n, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE),
          t.texParameteri(n, t.TEXTURE_COMPARE_FUNC, q[s.compareFunction])),
        !0 === e.has("EXT_texture_filter_anisotropic"))
      ) {
        const a = e.get("EXT_texture_filter_anisotropic");
        if (s.magFilter === S) return;
        if (s.minFilter !== E && s.minFilter !== A) return;
        if (s.type === L && !1 === e.has("OES_texture_float_linear")) return;
        if (
          !1 === o &&
          s.type === D &&
          !1 === e.has("OES_texture_half_float_linear")
        )
          return;
        (s.anisotropy > 1 || i.get(s).__currentAnisotropy) &&
          (t.texParameterf(
            n,
            a.TEXTURE_MAX_ANISOTROPY_EXT,
            Math.min(s.anisotropy, r.getMaxAnisotropy())
          ),
          (i.get(s).__currentAnisotropy = s.anisotropy));
      }
    }
    function Z(e, n) {
      let i = !1;
      void 0 === e.__webglInit &&
        ((e.__webglInit = !0), n.addEventListener("dispose", z));
      const r = n.source;
      let s = d.get(r);
      void 0 === s && ((s = {}), d.set(r, s));
      const o = (function (t) {
        const e = [];
        return (
          e.push(t.wrapS),
          e.push(t.wrapT),
          e.push(t.wrapR || 0),
          e.push(t.magFilter),
          e.push(t.minFilter),
          e.push(t.anisotropy),
          e.push(t.internalFormat),
          e.push(t.format),
          e.push(t.type),
          e.push(t.generateMipmaps),
          e.push(t.premultiplyAlpha),
          e.push(t.flipY),
          e.push(t.unpackAlignment),
          e.push(t.colorSpace),
          e.join()
        );
      })(n);
      if (o !== e.__cacheKey) {
        void 0 === s[o] &&
          ((s[o] = { texture: t.createTexture(), usedTimes: 0 }),
          a.memory.textures++,
          (i = !0)),
          s[o].usedTimes++;
        const r = s[e.__cacheKey];
        void 0 !== r &&
          (s[e.__cacheKey].usedTimes--, 0 === r.usedTimes && H(n)),
          (e.__cacheKey = o),
          (e.__webglTexture = s[o].texture);
      }
      return i;
    }
    function $(e, a, l) {
      let c = t.TEXTURE_2D;
      (a.isDataArrayTexture || a.isCompressedArrayTexture) &&
        (c = t.TEXTURE_2D_ARRAY),
        a.isData3DTexture && (c = t.TEXTURE_3D);
      const h = Z(e, a),
        u = a.source;
      n.bindTexture(c, e.__webglTexture, t.TEXTURE0 + l);
      const d = i.get(u);
      if (u.version !== d.__version || !0 === h) {
        n.activeTexture(t.TEXTURE0 + l);
        const e = Dt.getPrimaries(Dt.workingColorSpace),
          i = a.colorSpace === j ? null : Dt.getPrimaries(a.colorSpace),
          p = a.colorSpace === j || e === i ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, a.flipY),
          t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha),
          t.pixelStorei(t.UNPACK_ALIGNMENT, a.unpackAlignment),
          t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, p);
        const f =
          (function (t) {
            return (
              !o &&
              (t.wrapS !== T ||
                t.wrapT !== T ||
                (t.minFilter !== S && t.minFilter !== w))
            );
          })(a) && !1 === g(a.image);
        let x = m(a.image, f, !1, r.maxTextureSize);
        x = at(a, x);
        const M = g(x) || o,
          b = s.convert(a.format, a.colorSpace);
        let E,
          A = s.convert(a.type),
          R = y(a.internalFormat, b, A, a.colorSpace, a.isVideoTexture);
        K(c, a, M);
        const D = a.mipmaps,
          k = o && !0 !== a.isVideoTexture && 36196 !== R,
          z = void 0 === d.__version || !0 === h,
          B = F(a, x, M);
        if (a.isDepthTexture)
          (R = t.DEPTH_COMPONENT),
            o
              ? (R =
                  a.type === L
                    ? t.DEPTH_COMPONENT32F
                    : a.type === P
                    ? t.DEPTH_COMPONENT24
                    : a.type === I
                    ? t.DEPTH24_STENCIL8
                    : t.DEPTH_COMPONENT16)
              : a.type === L &&
                console.error(
                  "WebGLRenderer: Floating point depth texture requires WebGL2."
                ),
            a.format === N &&
              R === t.DEPTH_COMPONENT &&
              a.type !== C &&
              a.type !== P &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
              ),
              (a.type = P),
              (A = s.convert(a.type))),
            a.format === O &&
              R === t.DEPTH_COMPONENT &&
              ((R = t.DEPTH_STENCIL),
              a.type !== I &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                ),
                (a.type = I),
                (A = s.convert(a.type)))),
            z &&
              (k
                ? n.texStorage2D(t.TEXTURE_2D, 1, R, x.width, x.height)
                : n.texImage2D(
                    t.TEXTURE_2D,
                    0,
                    R,
                    x.width,
                    x.height,
                    0,
                    b,
                    A,
                    null
                  ));
        else if (a.isDataTexture)
          if (D.length > 0 && M) {
            k &&
              z &&
              n.texStorage2D(t.TEXTURE_2D, B, R, D[0].width, D[0].height);
            for (let e = 0, i = D.length; e < i; e++)
              (E = D[e]),
                k
                  ? n.texSubImage2D(
                      t.TEXTURE_2D,
                      e,
                      0,
                      0,
                      E.width,
                      E.height,
                      b,
                      A,
                      E.data
                    )
                  : n.texImage2D(
                      t.TEXTURE_2D,
                      e,
                      R,
                      E.width,
                      E.height,
                      0,
                      b,
                      A,
                      E.data
                    );
            a.generateMipmaps = !1;
          } else
            k
              ? (z && n.texStorage2D(t.TEXTURE_2D, B, R, x.width, x.height),
                n.texSubImage2D(
                  t.TEXTURE_2D,
                  0,
                  0,
                  0,
                  x.width,
                  x.height,
                  b,
                  A,
                  x.data
                ))
              : n.texImage2D(
                  t.TEXTURE_2D,
                  0,
                  R,
                  x.width,
                  x.height,
                  0,
                  b,
                  A,
                  x.data
                );
        else if (a.isCompressedTexture)
          if (a.isCompressedArrayTexture) {
            k &&
              z &&
              n.texStorage3D(
                t.TEXTURE_2D_ARRAY,
                B,
                R,
                D[0].width,
                D[0].height,
                x.depth
              );
            for (let e = 0, i = D.length; e < i; e++)
              (E = D[e]),
                a.format !== U
                  ? null !== b
                    ? k
                      ? n.compressedTexSubImage3D(
                          t.TEXTURE_2D_ARRAY,
                          e,
                          0,
                          0,
                          0,
                          E.width,
                          E.height,
                          x.depth,
                          b,
                          E.data,
                          0,
                          0
                        )
                      : n.compressedTexImage3D(
                          t.TEXTURE_2D_ARRAY,
                          e,
                          R,
                          E.width,
                          E.height,
                          x.depth,
                          0,
                          E.data,
                          0,
                          0
                        )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      )
                  : k
                  ? n.texSubImage3D(
                      t.TEXTURE_2D_ARRAY,
                      e,
                      0,
                      0,
                      0,
                      E.width,
                      E.height,
                      x.depth,
                      b,
                      A,
                      E.data
                    )
                  : n.texImage3D(
                      t.TEXTURE_2D_ARRAY,
                      e,
                      R,
                      E.width,
                      E.height,
                      x.depth,
                      0,
                      b,
                      A,
                      E.data
                    );
          } else {
            k &&
              z &&
              n.texStorage2D(t.TEXTURE_2D, B, R, D[0].width, D[0].height);
            for (let e = 0, i = D.length; e < i; e++)
              (E = D[e]),
                a.format !== U
                  ? null !== b
                    ? k
                      ? n.compressedTexSubImage2D(
                          t.TEXTURE_2D,
                          e,
                          0,
                          0,
                          E.width,
                          E.height,
                          b,
                          E.data
                        )
                      : n.compressedTexImage2D(
                          t.TEXTURE_2D,
                          e,
                          R,
                          E.width,
                          E.height,
                          0,
                          E.data
                        )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      )
                  : k
                  ? n.texSubImage2D(
                      t.TEXTURE_2D,
                      e,
                      0,
                      0,
                      E.width,
                      E.height,
                      b,
                      A,
                      E.data
                    )
                  : n.texImage2D(
                      t.TEXTURE_2D,
                      e,
                      R,
                      E.width,
                      E.height,
                      0,
                      b,
                      A,
                      E.data
                    );
          }
        else if (a.isDataArrayTexture)
          k
            ? (z &&
                n.texStorage3D(
                  t.TEXTURE_2D_ARRAY,
                  B,
                  R,
                  x.width,
                  x.height,
                  x.depth
                ),
              n.texSubImage3D(
                t.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                x.width,
                x.height,
                x.depth,
                b,
                A,
                x.data
              ))
            : n.texImage3D(
                t.TEXTURE_2D_ARRAY,
                0,
                R,
                x.width,
                x.height,
                x.depth,
                0,
                b,
                A,
                x.data
              );
        else if (a.isData3DTexture)
          k
            ? (z &&
                n.texStorage3D(t.TEXTURE_3D, B, R, x.width, x.height, x.depth),
              n.texSubImage3D(
                t.TEXTURE_3D,
                0,
                0,
                0,
                0,
                x.width,
                x.height,
                x.depth,
                b,
                A,
                x.data
              ))
            : n.texImage3D(
                t.TEXTURE_3D,
                0,
                R,
                x.width,
                x.height,
                x.depth,
                0,
                b,
                A,
                x.data
              );
        else if (a.isFramebufferTexture) {
          if (z)
            if (k) n.texStorage2D(t.TEXTURE_2D, B, R, x.width, x.height);
            else {
              let e = x.width,
                i = x.height;
              for (let r = 0; r < B; r++)
                n.texImage2D(t.TEXTURE_2D, r, R, e, i, 0, b, A, null),
                  (e >>= 1),
                  (i >>= 1);
            }
        } else if (D.length > 0 && M) {
          k && z && n.texStorage2D(t.TEXTURE_2D, B, R, D[0].width, D[0].height);
          for (let e = 0, i = D.length; e < i; e++)
            (E = D[e]),
              k
                ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, b, A, E)
                : n.texImage2D(t.TEXTURE_2D, e, R, b, A, E);
          a.generateMipmaps = !1;
        } else
          k
            ? (z && n.texStorage2D(t.TEXTURE_2D, B, R, x.width, x.height),
              n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, b, A, x))
            : n.texImage2D(t.TEXTURE_2D, 0, R, b, A, x);
        _(a, M) && v(c), (d.__version = u.version), a.onUpdate && a.onUpdate(a);
      }
      e.__version = a.version;
    }
    function tt(e, r, a, o, c, h) {
      const u = s.convert(a.format, a.colorSpace),
        d = s.convert(a.type),
        p = y(a.internalFormat, u, d, a.colorSpace);
      if (!i.get(r).__hasExternalTextures) {
        const e = Math.max(1, r.width >> h),
          i = Math.max(1, r.height >> h);
        c === t.TEXTURE_3D || c === t.TEXTURE_2D_ARRAY
          ? n.texImage3D(c, h, p, e, i, r.depth, 0, u, d, null)
          : n.texImage2D(c, h, p, e, i, 0, u, d, null);
      }
      n.bindFramebuffer(t.FRAMEBUFFER, e),
        st(r)
          ? l.framebufferTexture2DMultisampleEXT(
              t.FRAMEBUFFER,
              o,
              c,
              i.get(a).__webglTexture,
              0,
              it(r)
            )
          : (c === t.TEXTURE_2D ||
              (c >= t.TEXTURE_CUBE_MAP_POSITIVE_X &&
                c <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
            t.framebufferTexture2D(
              t.FRAMEBUFFER,
              o,
              c,
              i.get(a).__webglTexture,
              h
            ),
        n.bindFramebuffer(t.FRAMEBUFFER, null);
    }
    function et(e, n, i) {
      if (
        (t.bindRenderbuffer(t.RENDERBUFFER, e),
        n.depthBuffer && !n.stencilBuffer)
      ) {
        let r = !0 === o ? t.DEPTH_COMPONENT24 : t.DEPTH_COMPONENT16;
        if (i || st(n)) {
          const e = n.depthTexture;
          e &&
            e.isDepthTexture &&
            (e.type === L
              ? (r = t.DEPTH_COMPONENT32F)
              : e.type === P && (r = t.DEPTH_COMPONENT24));
          const i = it(n);
          st(n)
            ? l.renderbufferStorageMultisampleEXT(
                t.RENDERBUFFER,
                i,
                r,
                n.width,
                n.height
              )
            : t.renderbufferStorageMultisample(
                t.RENDERBUFFER,
                i,
                r,
                n.width,
                n.height
              );
        } else t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height);
        t.framebufferRenderbuffer(
          t.FRAMEBUFFER,
          t.DEPTH_ATTACHMENT,
          t.RENDERBUFFER,
          e
        );
      } else if (n.depthBuffer && n.stencilBuffer) {
        const r = it(n);
        i && !1 === st(n)
          ? t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              r,
              t.DEPTH24_STENCIL8,
              n.width,
              n.height
            )
          : st(n)
          ? l.renderbufferStorageMultisampleEXT(
              t.RENDERBUFFER,
              r,
              t.DEPTH24_STENCIL8,
              n.width,
              n.height
            )
          : t.renderbufferStorage(
              t.RENDERBUFFER,
              t.DEPTH_STENCIL,
              n.width,
              n.height
            ),
          t.framebufferRenderbuffer(
            t.FRAMEBUFFER,
            t.DEPTH_STENCIL_ATTACHMENT,
            t.RENDERBUFFER,
            e
          );
      } else {
        const e =
          !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
        for (let r = 0; r < e.length; r++) {
          const a = e[r],
            o = s.convert(a.format, a.colorSpace),
            c = s.convert(a.type),
            h = y(a.internalFormat, o, c, a.colorSpace),
            u = it(n);
          i && !1 === st(n)
            ? t.renderbufferStorageMultisample(
                t.RENDERBUFFER,
                u,
                h,
                n.width,
                n.height
              )
            : st(n)
            ? l.renderbufferStorageMultisampleEXT(
                t.RENDERBUFFER,
                u,
                h,
                n.width,
                n.height
              )
            : t.renderbufferStorage(t.RENDERBUFFER, h, n.width, n.height);
        }
      }
      t.bindRenderbuffer(t.RENDERBUFFER, null);
    }
    function nt(e) {
      const r = i.get(e),
        s = !0 === e.isWebGLCubeRenderTarget;
      if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
        if (s)
          throw new Error(
            "target.depthTexture not supported in Cube render targets"
          );
        !(function (e, r) {
          if (r && r.isWebGLCubeRenderTarget)
            throw new Error(
              "Depth Texture with cube render targets is not supported"
            );
          if (
            (n.bindFramebuffer(t.FRAMEBUFFER, e),
            !r.depthTexture || !r.depthTexture.isDepthTexture)
          )
            throw new Error(
              "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
            );
          (i.get(r.depthTexture).__webglTexture &&
            r.depthTexture.image.width === r.width &&
            r.depthTexture.image.height === r.height) ||
            ((r.depthTexture.image.width = r.width),
            (r.depthTexture.image.height = r.height),
            (r.depthTexture.needsUpdate = !0)),
            V(r.depthTexture, 0);
          const s = i.get(r.depthTexture).__webglTexture,
            a = it(r);
          if (r.depthTexture.format === N)
            st(r)
              ? l.framebufferTexture2DMultisampleEXT(
                  t.FRAMEBUFFER,
                  t.DEPTH_ATTACHMENT,
                  t.TEXTURE_2D,
                  s,
                  0,
                  a
                )
              : t.framebufferTexture2D(
                  t.FRAMEBUFFER,
                  t.DEPTH_ATTACHMENT,
                  t.TEXTURE_2D,
                  s,
                  0
                );
          else {
            if (r.depthTexture.format !== O)
              throw new Error("Unknown depthTexture format");
            st(r)
              ? l.framebufferTexture2DMultisampleEXT(
                  t.FRAMEBUFFER,
                  t.DEPTH_STENCIL_ATTACHMENT,
                  t.TEXTURE_2D,
                  s,
                  0,
                  a
                )
              : t.framebufferTexture2D(
                  t.FRAMEBUFFER,
                  t.DEPTH_STENCIL_ATTACHMENT,
                  t.TEXTURE_2D,
                  s,
                  0
                );
          }
        })(r.__webglFramebuffer, e);
      } else if (s) {
        r.__webglDepthbuffer = [];
        for (let i = 0; i < 6; i++)
          n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[i]),
            (r.__webglDepthbuffer[i] = t.createRenderbuffer()),
            et(r.__webglDepthbuffer[i], e, !1);
      } else
        n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer),
          (r.__webglDepthbuffer = t.createRenderbuffer()),
          et(r.__webglDepthbuffer, e, !1);
      n.bindFramebuffer(t.FRAMEBUFFER, null);
    }
    function it(t) {
      return Math.min(r.maxSamples, t.samples);
    }
    function st(t) {
      const n = i.get(t);
      return (
        o &&
        t.samples > 0 &&
        !0 === e.has("WEBGL_multisampled_render_to_texture") &&
        !1 !== n.__useRenderToTexture
      );
    }
    function at(t, n) {
      const i = t.colorSpace,
        r = t.format,
        s = t.type;
      return (
        !0 === t.isCompressedTexture ||
          !0 === t.isVideoTexture ||
          t.format === rt ||
          (i !== Y &&
            i !== j &&
            (Dt.getTransfer(i) === Q
              ? !1 === o
                ? !0 === e.has("EXT_sRGB") && r === U
                  ? ((t.format = rt),
                    (t.minFilter = w),
                    (t.generateMipmaps = !1))
                  : (n = Ot.sRGBToLinear(n))
                : (r === U && s === R) ||
                  console.warn(
                    "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                  )
              : console.error(
                  "THREE.WebGLTextures: Unsupported texture color space:",
                  i
                ))),
        n
      );
    }
    (this.allocateTextureUnit = function () {
      const t = G;
      return (
        t >= r.maxTextures &&
          console.warn(
            "THREE.WebGLTextures: Trying to use " +
              t +
              " texture units while this GPU supports only " +
              r.maxTextures
          ),
        (G += 1),
        t
      );
    }),
      (this.resetTextureUnits = function () {
        G = 0;
      }),
      (this.setTexture2D = V),
      (this.setTexture2DArray = function (e, r) {
        const s = i.get(e);
        e.version > 0 && s.__version !== e.version
          ? $(s, e, r)
          : n.bindTexture(t.TEXTURE_2D_ARRAY, s.__webglTexture, t.TEXTURE0 + r);
      }),
      (this.setTexture3D = function (e, r) {
        const s = i.get(e);
        e.version > 0 && s.__version !== e.version
          ? $(s, e, r)
          : n.bindTexture(t.TEXTURE_3D, s.__webglTexture, t.TEXTURE0 + r);
      }),
      (this.setTextureCube = function (e, a) {
        const l = i.get(e);
        e.version > 0 && l.__version !== e.version
          ? (function (e, a, l) {
              if (6 !== a.image.length) return;
              const c = Z(e, a),
                h = a.source;
              n.bindTexture(
                t.TEXTURE_CUBE_MAP,
                e.__webglTexture,
                t.TEXTURE0 + l
              );
              const u = i.get(h);
              if (h.version !== u.__version || !0 === c) {
                n.activeTexture(t.TEXTURE0 + l);
                const e = Dt.getPrimaries(Dt.workingColorSpace),
                  i = a.colorSpace === j ? null : Dt.getPrimaries(a.colorSpace),
                  d =
                    a.colorSpace === j || e === i
                      ? t.NONE
                      : t.BROWSER_DEFAULT_WEBGL;
                t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, a.flipY),
                  t.pixelStorei(
                    t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                    a.premultiplyAlpha
                  ),
                  t.pixelStorei(t.UNPACK_ALIGNMENT, a.unpackAlignment),
                  t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
                const p =
                    a.isCompressedTexture || a.image[0].isCompressedTexture,
                  f = a.image[0] && a.image[0].isDataTexture,
                  x = [];
                for (let t = 0; t < 6; t++)
                  (x[t] =
                    p || f
                      ? f
                        ? a.image[t].image
                        : a.image[t]
                      : m(a.image[t], !1, !0, r.maxCubemapSize)),
                    (x[t] = at(a, x[t]));
                const T = x[0],
                  M = g(T) || o,
                  S = s.convert(a.format, a.colorSpace),
                  b = s.convert(a.type),
                  E = y(a.internalFormat, S, b, a.colorSpace),
                  w = o && !0 !== a.isVideoTexture,
                  A = void 0 === u.__version || !0 === c;
                let R,
                  C = F(a, T, M);
                if ((K(t.TEXTURE_CUBE_MAP, a, M), p)) {
                  w &&
                    A &&
                    n.texStorage2D(t.TEXTURE_CUBE_MAP, C, E, T.width, T.height);
                  for (let e = 0; e < 6; e++) {
                    R = x[e].mipmaps;
                    for (let i = 0; i < R.length; i++) {
                      const r = R[i];
                      a.format !== U
                        ? null !== S
                          ? w
                            ? n.compressedTexSubImage2D(
                                t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                i,
                                0,
                                0,
                                r.width,
                                r.height,
                                S,
                                r.data
                              )
                            : n.compressedTexImage2D(
                                t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                i,
                                E,
                                r.width,
                                r.height,
                                0,
                                r.data
                              )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                            )
                        : w
                        ? n.texSubImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                            i,
                            0,
                            0,
                            r.width,
                            r.height,
                            S,
                            b,
                            r.data
                          )
                        : n.texImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                            i,
                            E,
                            r.width,
                            r.height,
                            0,
                            S,
                            b,
                            r.data
                          );
                    }
                  }
                } else {
                  (R = a.mipmaps),
                    w &&
                      A &&
                      (R.length > 0 && C++,
                      n.texStorage2D(
                        t.TEXTURE_CUBE_MAP,
                        C,
                        E,
                        x[0].width,
                        x[0].height
                      ));
                  for (let e = 0; e < 6; e++)
                    if (f) {
                      w
                        ? n.texSubImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                            0,
                            0,
                            0,
                            x[e].width,
                            x[e].height,
                            S,
                            b,
                            x[e].data
                          )
                        : n.texImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                            0,
                            E,
                            x[e].width,
                            x[e].height,
                            0,
                            S,
                            b,
                            x[e].data
                          );
                      for (let i = 0; i < R.length; i++) {
                        const r = R[i].image[e].image;
                        w
                          ? n.texSubImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                              i + 1,
                              0,
                              0,
                              r.width,
                              r.height,
                              S,
                              b,
                              r.data
                            )
                          : n.texImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                              i + 1,
                              E,
                              r.width,
                              r.height,
                              0,
                              S,
                              b,
                              r.data
                            );
                      }
                    } else {
                      w
                        ? n.texSubImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                            0,
                            0,
                            0,
                            S,
                            b,
                            x[e]
                          )
                        : n.texImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                            0,
                            E,
                            S,
                            b,
                            x[e]
                          );
                      for (let i = 0; i < R.length; i++) {
                        const r = R[i];
                        w
                          ? n.texSubImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                              i + 1,
                              0,
                              0,
                              S,
                              b,
                              r.image[e]
                            )
                          : n.texImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                              i + 1,
                              E,
                              S,
                              b,
                              r.image[e]
                            );
                      }
                    }
                }
                _(a, M) && v(t.TEXTURE_CUBE_MAP),
                  (u.__version = h.version),
                  a.onUpdate && a.onUpdate(a);
              }
              e.__version = a.version;
            })(l, e, a)
          : n.bindTexture(t.TEXTURE_CUBE_MAP, l.__webglTexture, t.TEXTURE0 + a);
      }),
      (this.rebindTextures = function (e, n, r) {
        const s = i.get(e);
        void 0 !== n &&
          tt(
            s.__webglFramebuffer,
            e,
            e.texture,
            t.COLOR_ATTACHMENT0,
            t.TEXTURE_2D,
            0
          ),
          void 0 !== r && nt(e);
      }),
      (this.setupRenderTarget = function (e) {
        const l = e.texture,
          c = i.get(e),
          h = i.get(l);
        e.addEventListener("dispose", B),
          !0 !== e.isWebGLMultipleRenderTargets &&
            (void 0 === h.__webglTexture &&
              (h.__webglTexture = t.createTexture()),
            (h.__version = l.version),
            a.memory.textures++);
        const u = !0 === e.isWebGLCubeRenderTarget,
          d = !0 === e.isWebGLMultipleRenderTargets,
          p = g(e) || o;
        if (u) {
          c.__webglFramebuffer = [];
          for (let e = 0; e < 6; e++)
            if (o && l.mipmaps && l.mipmaps.length > 0) {
              c.__webglFramebuffer[e] = [];
              for (let n = 0; n < l.mipmaps.length; n++)
                c.__webglFramebuffer[e][n] = t.createFramebuffer();
            } else c.__webglFramebuffer[e] = t.createFramebuffer();
        } else {
          if (o && l.mipmaps && l.mipmaps.length > 0) {
            c.__webglFramebuffer = [];
            for (let e = 0; e < l.mipmaps.length; e++)
              c.__webglFramebuffer[e] = t.createFramebuffer();
          } else c.__webglFramebuffer = t.createFramebuffer();
          if (d)
            if (r.drawBuffers) {
              const n = e.texture;
              for (let e = 0, r = n.length; e < r; e++) {
                const r = i.get(n[e]);
                void 0 === r.__webglTexture &&
                  ((r.__webglTexture = t.createTexture()), a.memory.textures++);
              }
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
              );
          if (o && e.samples > 0 && !1 === st(e)) {
            const i = d ? l : [l];
            (c.__webglMultisampledFramebuffer = t.createFramebuffer()),
              (c.__webglColorRenderbuffer = []),
              n.bindFramebuffer(
                t.FRAMEBUFFER,
                c.__webglMultisampledFramebuffer
              );
            for (let n = 0; n < i.length; n++) {
              const r = i[n];
              (c.__webglColorRenderbuffer[n] = t.createRenderbuffer()),
                t.bindRenderbuffer(
                  t.RENDERBUFFER,
                  c.__webglColorRenderbuffer[n]
                );
              const a = s.convert(r.format, r.colorSpace),
                o = s.convert(r.type),
                l = y(
                  r.internalFormat,
                  a,
                  o,
                  r.colorSpace,
                  !0 === e.isXRRenderTarget
                ),
                h = it(e);
              t.renderbufferStorageMultisample(
                t.RENDERBUFFER,
                h,
                l,
                e.width,
                e.height
              ),
                t.framebufferRenderbuffer(
                  t.FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0 + n,
                  t.RENDERBUFFER,
                  c.__webglColorRenderbuffer[n]
                );
            }
            t.bindRenderbuffer(t.RENDERBUFFER, null),
              e.depthBuffer &&
                ((c.__webglDepthRenderbuffer = t.createRenderbuffer()),
                et(c.__webglDepthRenderbuffer, e, !0)),
              n.bindFramebuffer(t.FRAMEBUFFER, null);
          }
        }
        if (u) {
          n.bindTexture(t.TEXTURE_CUBE_MAP, h.__webglTexture),
            K(t.TEXTURE_CUBE_MAP, l, p);
          for (let n = 0; n < 6; n++)
            if (o && l.mipmaps && l.mipmaps.length > 0)
              for (let i = 0; i < l.mipmaps.length; i++)
                tt(
                  c.__webglFramebuffer[n][i],
                  e,
                  l,
                  t.COLOR_ATTACHMENT0,
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                  i
                );
            else
              tt(
                c.__webglFramebuffer[n],
                e,
                l,
                t.COLOR_ATTACHMENT0,
                t.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                0
              );
          _(l, p) && v(t.TEXTURE_CUBE_MAP), n.unbindTexture();
        } else if (d) {
          const r = e.texture;
          for (let s = 0, a = r.length; s < a; s++) {
            const a = r[s],
              o = i.get(a);
            n.bindTexture(t.TEXTURE_2D, o.__webglTexture),
              K(t.TEXTURE_2D, a, p),
              tt(
                c.__webglFramebuffer,
                e,
                a,
                t.COLOR_ATTACHMENT0 + s,
                t.TEXTURE_2D,
                0
              ),
              _(a, p) && v(t.TEXTURE_2D);
          }
          n.unbindTexture();
        } else {
          let i = t.TEXTURE_2D;
          if (
            ((e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) &&
              (o
                ? (i = e.isWebGL3DRenderTarget
                    ? t.TEXTURE_3D
                    : t.TEXTURE_2D_ARRAY)
                : console.error(
                    "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
                  )),
            n.bindTexture(i, h.__webglTexture),
            K(i, l, p),
            o && l.mipmaps && l.mipmaps.length > 0)
          )
            for (let n = 0; n < l.mipmaps.length; n++)
              tt(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, i, n);
          else tt(c.__webglFramebuffer, e, l, t.COLOR_ATTACHMENT0, i, 0);
          _(l, p) && v(i), n.unbindTexture();
        }
        e.depthBuffer && nt(e);
      }),
      (this.updateRenderTargetMipmap = function (e) {
        const r = g(e) || o,
          s = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
        for (let a = 0, o = s.length; a < o; a++) {
          const o = s[a];
          if (_(o, r)) {
            const r = e.isWebGLCubeRenderTarget
                ? t.TEXTURE_CUBE_MAP
                : t.TEXTURE_2D,
              s = i.get(o).__webglTexture;
            n.bindTexture(r, s), v(r), n.unbindTexture();
          }
        }
      }),
      (this.updateMultisampleRenderTarget = function (e) {
        if (o && e.samples > 0 && !1 === st(e)) {
          const r = e.isWebGLMultipleRenderTargets ? e.texture : [e.texture],
            s = e.width,
            a = e.height;
          let o = t.COLOR_BUFFER_BIT;
          const l = [],
            h = e.stencilBuffer
              ? t.DEPTH_STENCIL_ATTACHMENT
              : t.DEPTH_ATTACHMENT,
            u = i.get(e),
            d = !0 === e.isWebGLMultipleRenderTargets;
          if (d)
            for (let e = 0; e < r.length; e++)
              n.bindFramebuffer(
                t.FRAMEBUFFER,
                u.__webglMultisampledFramebuffer
              ),
                t.framebufferRenderbuffer(
                  t.FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0 + e,
                  t.RENDERBUFFER,
                  null
                ),
                n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer),
                t.framebufferTexture2D(
                  t.DRAW_FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0 + e,
                  t.TEXTURE_2D,
                  null,
                  0
                );
          n.bindFramebuffer(
            t.READ_FRAMEBUFFER,
            u.__webglMultisampledFramebuffer
          ),
            n.bindFramebuffer(t.DRAW_FRAMEBUFFER, u.__webglFramebuffer);
          for (let n = 0; n < r.length; n++) {
            l.push(t.COLOR_ATTACHMENT0 + n), e.depthBuffer && l.push(h);
            const p = void 0 !== u.__ignoreDepthValues && u.__ignoreDepthValues;
            if (
              (!1 === p &&
                (e.depthBuffer && (o |= t.DEPTH_BUFFER_BIT),
                e.stencilBuffer && (o |= t.STENCIL_BUFFER_BIT)),
              d &&
                t.framebufferRenderbuffer(
                  t.READ_FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0,
                  t.RENDERBUFFER,
                  u.__webglColorRenderbuffer[n]
                ),
              !0 === p &&
                (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [h]),
                t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [h])),
              d)
            ) {
              const e = i.get(r[n]).__webglTexture;
              t.framebufferTexture2D(
                t.DRAW_FRAMEBUFFER,
                t.COLOR_ATTACHMENT0,
                t.TEXTURE_2D,
                e,
                0
              );
            }
            t.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, t.NEAREST),
              c && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, l);
          }
          if (
            (n.bindFramebuffer(t.READ_FRAMEBUFFER, null),
            n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
            d)
          )
            for (let e = 0; e < r.length; e++) {
              n.bindFramebuffer(
                t.FRAMEBUFFER,
                u.__webglMultisampledFramebuffer
              ),
                t.framebufferRenderbuffer(
                  t.FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0 + e,
                  t.RENDERBUFFER,
                  u.__webglColorRenderbuffer[e]
                );
              const s = i.get(r[e]).__webglTexture;
              n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer),
                t.framebufferTexture2D(
                  t.DRAW_FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0 + e,
                  t.TEXTURE_2D,
                  s,
                  0
                );
            }
          n.bindFramebuffer(
            t.DRAW_FRAMEBUFFER,
            u.__webglMultisampledFramebuffer
          );
        }
      }),
      (this.setupDepthRenderbuffer = nt),
      (this.setupFrameBufferTexture = tt),
      (this.useMultisampledRTT = st);
  }
  function Vs(t, e, n) {
    const i = n.isWebGL2;
    return {
      convert: function (n, r = "") {
        let s;
        const a = Dt.getTransfer(r);
        if (n === R) return t.UNSIGNED_BYTE;
        if (1017 === n) return t.UNSIGNED_SHORT_4_4_4_4;
        if (1018 === n) return t.UNSIGNED_SHORT_5_5_5_1;
        if (1010 === n) return t.BYTE;
        if (1011 === n) return t.SHORT;
        if (n === C) return t.UNSIGNED_SHORT;
        if (1013 === n) return t.INT;
        if (n === P) return t.UNSIGNED_INT;
        if (n === L) return t.FLOAT;
        if (n === D)
          return i
            ? t.HALF_FLOAT
            : ((s = e.get("OES_texture_half_float")),
              null !== s ? s.HALF_FLOAT_OES : null);
        if (1021 === n) return t.ALPHA;
        if (n === U) return t.RGBA;
        if (1024 === n) return t.LUMINANCE;
        if (1025 === n) return t.LUMINANCE_ALPHA;
        if (n === N) return t.DEPTH_COMPONENT;
        if (n === O) return t.DEPTH_STENCIL;
        if (n === rt)
          return (s = e.get("EXT_sRGB")), null !== s ? s.SRGB_ALPHA_EXT : null;
        if (1028 === n) return t.RED;
        if (1029 === n) return t.RED_INTEGER;
        if (1030 === n) return t.RG;
        if (1031 === n) return t.RG_INTEGER;
        if (1033 === n) return t.RGBA_INTEGER;
        if (n === F || n === k || n === z || n === B)
          if (a === Q) {
            if (((s = e.get("WEBGL_compressed_texture_s3tc_srgb")), null === s))
              return null;
            if (n === F) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (n === k) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (n === z) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (n === B) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else {
            if (((s = e.get("WEBGL_compressed_texture_s3tc")), null === s))
              return null;
            if (n === F) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (n === k) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (n === z) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (n === B) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
        if (35840 === n || 35841 === n || 35842 === n || 35843 === n) {
          if (((s = e.get("WEBGL_compressed_texture_pvrtc")), null === s))
            return null;
          if (35840 === n) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (35841 === n) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (35842 === n) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (35843 === n) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        if (36196 === n)
          return (
            (s = e.get("WEBGL_compressed_texture_etc1")),
            null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null
          );
        if (37492 === n || 37496 === n) {
          if (((s = e.get("WEBGL_compressed_texture_etc")), null === s))
            return null;
          if (37492 === n)
            return a === Q ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
          if (37496 === n)
            return a === Q
              ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
              : s.COMPRESSED_RGBA8_ETC2_EAC;
        }
        if (
          37808 === n ||
          37809 === n ||
          37810 === n ||
          37811 === n ||
          37812 === n ||
          37813 === n ||
          37814 === n ||
          37815 === n ||
          37816 === n ||
          37817 === n ||
          37818 === n ||
          37819 === n ||
          37820 === n ||
          37821 === n
        ) {
          if (((s = e.get("WEBGL_compressed_texture_astc")), null === s))
            return null;
          if (37808 === n)
            return a === Q
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
              : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
          if (37809 === n)
            return a === Q
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
              : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
          if (37810 === n)
            return a === Q
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
              : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
          if (37811 === n)
            return a === Q
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
              : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
          if (37812 === n)
            return a === Q
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
              : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
          if (37813 === n)
            return a === Q
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
              : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
          if (37814 === n)
            return a === Q
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
              : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
          if (37815 === n)
            return a === Q
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
              : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
          if (37816 === n)
            return a === Q
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
              : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
          if (37817 === n)
            return a === Q
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
              : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
          if (37818 === n)
            return a === Q
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
              : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
          if (37819 === n)
            return a === Q
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
              : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
          if (37820 === n)
            return a === Q
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
              : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
          if (37821 === n)
            return a === Q
              ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
              : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
        }
        if (n === H || 36494 === n || 36495 === n) {
          if (((s = e.get("EXT_texture_compression_bptc")), null === s))
            return null;
          if (n === H)
            return a === Q
              ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
              : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
          if (36494 === n) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
          if (36495 === n) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
        }
        if (36283 === n || 36284 === n || 36285 === n || 36286 === n) {
          if (((s = e.get("EXT_texture_compression_rgtc")), null === s))
            return null;
          if (n === H) return s.COMPRESSED_RED_RGTC1_EXT;
          if (36284 === n) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
          if (36285 === n) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
          if (36286 === n) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
        }
        return n === I
          ? i
            ? t.UNSIGNED_INT_24_8
            : ((s = e.get("WEBGL_depth_texture")),
              null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null)
          : void 0 !== t[n]
          ? t[n]
          : null;
      },
    };
  }
  class Ws extends ri {
    constructor(t = []) {
      super(), (this.isArrayCamera = !0), (this.cameras = t);
    }
  }
  class Xs extends Ke {
    constructor() {
      super(), (this.isGroup = !0), (this.type = "Group");
    }
  }
  const js = { type: "move" };
  class qs {
    constructor() {
      (this._targetRay = null), (this._grip = null), (this._hand = null);
    }
    getHandSpace() {
      return (
        null === this._hand &&
          ((this._hand = new Xs()),
          (this._hand.matrixAutoUpdate = !1),
          (this._hand.visible = !1),
          (this._hand.joints = {}),
          (this._hand.inputState = { pinching: !1 })),
        this._hand
      );
    }
    getTargetRaySpace() {
      return (
        null === this._targetRay &&
          ((this._targetRay = new Xs()),
          (this._targetRay.matrixAutoUpdate = !1),
          (this._targetRay.visible = !1),
          (this._targetRay.hasLinearVelocity = !1),
          (this._targetRay.linearVelocity = new Yt()),
          (this._targetRay.hasAngularVelocity = !1),
          (this._targetRay.angularVelocity = new Yt())),
        this._targetRay
      );
    }
    getGripSpace() {
      return (
        null === this._grip &&
          ((this._grip = new Xs()),
          (this._grip.matrixAutoUpdate = !1),
          (this._grip.visible = !1),
          (this._grip.hasLinearVelocity = !1),
          (this._grip.linearVelocity = new Yt()),
          (this._grip.hasAngularVelocity = !1),
          (this._grip.angularVelocity = new Yt())),
        this._grip
      );
    }
    dispatchEvent(t) {
      return (
        null !== this._targetRay && this._targetRay.dispatchEvent(t),
        null !== this._grip && this._grip.dispatchEvent(t),
        null !== this._hand && this._hand.dispatchEvent(t),
        this
      );
    }
    connect(t) {
      if (t && t.hand) {
        const e = this._hand;
        if (e) for (const n of t.hand.values()) this._getHandJoint(e, n);
      }
      return this.dispatchEvent({ type: "connected", data: t }), this;
    }
    disconnect(t) {
      return (
        this.dispatchEvent({ type: "disconnected", data: t }),
        null !== this._targetRay && (this._targetRay.visible = !1),
        null !== this._grip && (this._grip.visible = !1),
        null !== this._hand && (this._hand.visible = !1),
        this
      );
    }
    update(t, e, n) {
      let i = null,
        r = null,
        s = null;
      const a = this._targetRay,
        o = this._grip,
        l = this._hand;
      if (t && "visible-blurred" !== e.session.visibilityState) {
        if (l && t.hand) {
          s = !0;
          for (const i of t.hand.values()) {
            const t = e.getJointPose(i, n),
              r = this._getHandJoint(l, i);
            null !== t &&
              (r.matrix.fromArray(t.transform.matrix),
              r.matrix.decompose(r.position, r.rotation, r.scale),
              (r.matrixWorldNeedsUpdate = !0),
              (r.jointRadius = t.radius)),
              (r.visible = null !== t);
          }
          const i = l.joints["index-finger-tip"],
            r = l.joints["thumb-tip"],
            a = i.position.distanceTo(r.position),
            o = 0.02,
            c = 0.005;
          l.inputState.pinching && a > o + c
            ? ((l.inputState.pinching = !1),
              this.dispatchEvent({
                type: "pinchend",
                handedness: t.handedness,
                target: this,
              }))
            : !l.inputState.pinching &&
              a <= o - c &&
              ((l.inputState.pinching = !0),
              this.dispatchEvent({
                type: "pinchstart",
                handedness: t.handedness,
                target: this,
              }));
        } else
          null !== o &&
            t.gripSpace &&
            ((r = e.getPose(t.gripSpace, n)),
            null !== r &&
              (o.matrix.fromArray(r.transform.matrix),
              o.matrix.decompose(o.position, o.rotation, o.scale),
              (o.matrixWorldNeedsUpdate = !0),
              r.linearVelocity
                ? ((o.hasLinearVelocity = !0),
                  o.linearVelocity.copy(r.linearVelocity))
                : (o.hasLinearVelocity = !1),
              r.angularVelocity
                ? ((o.hasAngularVelocity = !0),
                  o.angularVelocity.copy(r.angularVelocity))
                : (o.hasAngularVelocity = !1)));
        null !== a &&
          ((i = e.getPose(t.targetRaySpace, n)),
          null === i && null !== r && (i = r),
          null !== i &&
            (a.matrix.fromArray(i.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            (a.matrixWorldNeedsUpdate = !0),
            i.linearVelocity
              ? ((a.hasLinearVelocity = !0),
                a.linearVelocity.copy(i.linearVelocity))
              : (a.hasLinearVelocity = !1),
            i.angularVelocity
              ? ((a.hasAngularVelocity = !0),
                a.angularVelocity.copy(i.angularVelocity))
              : (a.hasAngularVelocity = !1),
            this.dispatchEvent(js)));
      }
      return (
        null !== a && (a.visible = null !== i),
        null !== o && (o.visible = null !== r),
        null !== l && (l.visible = null !== s),
        this
      );
    }
    _getHandJoint(t, e) {
      if (void 0 === t.joints[e.jointName]) {
        const n = new Xs();
        (n.matrixAutoUpdate = !1),
          (n.visible = !1),
          (t.joints[e.jointName] = n),
          t.add(n);
      }
      return t.joints[e.jointName];
    }
  }
  class Ys extends ot {
    constructor(t, e) {
      super();
      const n = this;
      let i = null,
        r = 1,
        s = null,
        a = "local-floor",
        o = 1,
        l = null,
        c = null,
        h = null,
        u = null,
        d = null,
        p = null;
      const f = e.getContextAttributes();
      let m = null,
        g = null;
      const _ = [],
        v = [],
        y = new xt();
      let x = null;
      const T = new ri();
      T.layers.enable(1), (T.viewport = new Gt());
      const M = new ri();
      M.layers.enable(2), (M.viewport = new Gt());
      const S = [T, M],
        b = new Ws();
      b.layers.enable(1), b.layers.enable(2);
      let E = null,
        w = null;
      function A(t) {
        const e = v.indexOf(t.inputSource);
        if (-1 === e) return;
        const n = _[e];
        void 0 !== n &&
          (n.update(t.inputSource, t.frame, l || s),
          n.dispatchEvent({ type: t.type, data: t.inputSource }));
      }
      function C() {
        i.removeEventListener("select", A),
          i.removeEventListener("selectstart", A),
          i.removeEventListener("selectend", A),
          i.removeEventListener("squeeze", A),
          i.removeEventListener("squeezestart", A),
          i.removeEventListener("squeezeend", A),
          i.removeEventListener("end", C),
          i.removeEventListener("inputsourceschange", L);
        for (let t = 0; t < _.length; t++) {
          const e = v[t];
          null !== e && ((v[t] = null), _[t].disconnect(e));
        }
        (E = null),
          (w = null),
          t.setRenderTarget(m),
          (d = null),
          (u = null),
          (h = null),
          (i = null),
          (g = null),
          B.stop(),
          (n.isPresenting = !1),
          t.setPixelRatio(x),
          t.setSize(y.width, y.height, !1),
          n.dispatchEvent({ type: "sessionend" });
      }
      function L(t) {
        for (let e = 0; e < t.removed.length; e++) {
          const n = t.removed[e],
            i = v.indexOf(n);
          i >= 0 && ((v[i] = null), _[i].disconnect(n));
        }
        for (let e = 0; e < t.added.length; e++) {
          const n = t.added[e];
          let i = v.indexOf(n);
          if (-1 === i) {
            for (let t = 0; t < _.length; t++) {
              if (t >= v.length) {
                v.push(n), (i = t);
                break;
              }
              if (null === v[t]) {
                (v[t] = n), (i = t);
                break;
              }
            }
            if (-1 === i) break;
          }
          const r = _[i];
          r && r.connect(n);
        }
      }
      (this.cameraAutoUpdate = !0),
        (this.enabled = !1),
        (this.isPresenting = !1),
        (this.getController = function (t) {
          let e = _[t];
          return (
            void 0 === e && ((e = new qs()), (_[t] = e)), e.getTargetRaySpace()
          );
        }),
        (this.getControllerGrip = function (t) {
          let e = _[t];
          return void 0 === e && ((e = new qs()), (_[t] = e)), e.getGripSpace();
        }),
        (this.getHand = function (t) {
          let e = _[t];
          return void 0 === e && ((e = new qs()), (_[t] = e)), e.getHandSpace();
        }),
        (this.setFramebufferScaleFactor = function (t) {
          (r = t),
            !0 === n.isPresenting &&
              console.warn(
                "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
              );
        }),
        (this.setReferenceSpaceType = function (t) {
          (a = t),
            !0 === n.isPresenting &&
              console.warn(
                "THREE.WebXRManager: Cannot change reference space type while presenting."
              );
        }),
        (this.getReferenceSpace = function () {
          return l || s;
        }),
        (this.setReferenceSpace = function (t) {
          l = t;
        }),
        (this.getBaseLayer = function () {
          return null !== u ? u : d;
        }),
        (this.getBinding = function () {
          return h;
        }),
        (this.getFrame = function () {
          return p;
        }),
        (this.getSession = function () {
          return i;
        }),
        (this.setSession = async function (c) {
          if (((i = c), null !== i)) {
            if (
              ((m = t.getRenderTarget()),
              i.addEventListener("select", A),
              i.addEventListener("selectstart", A),
              i.addEventListener("selectend", A),
              i.addEventListener("squeeze", A),
              i.addEventListener("squeezestart", A),
              i.addEventListener("squeezeend", A),
              i.addEventListener("end", C),
              i.addEventListener("inputsourceschange", L),
              !0 !== f.xrCompatible && (await e.makeXRCompatible()),
              (x = t.getPixelRatio()),
              t.getSize(y),
              void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2)
            ) {
              const n = {
                antialias: void 0 !== i.renderState.layers || f.antialias,
                alpha: !0,
                depth: f.depth,
                stencil: f.stencil,
                framebufferScaleFactor: r,
              };
              (d = new XRWebGLLayer(i, e, n)),
                i.updateRenderState({ baseLayer: d }),
                t.setPixelRatio(1),
                t.setSize(d.framebufferWidth, d.framebufferHeight, !1),
                (g = new Wt(d.framebufferWidth, d.framebufferHeight, {
                  format: U,
                  type: R,
                  colorSpace: t.outputColorSpace,
                  stencilBuffer: f.stencil,
                }));
            } else {
              let n = null,
                s = null,
                a = null;
              f.depth &&
                ((a = f.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24),
                (n = f.stencil ? O : N),
                (s = f.stencil ? I : P));
              const o = {
                colorFormat: e.RGBA8,
                depthFormat: a,
                scaleFactor: r,
              };
              (h = new XRWebGLBinding(i, e)),
                (u = h.createProjectionLayer(o)),
                i.updateRenderState({ layers: [u] }),
                t.setPixelRatio(1),
                t.setSize(u.textureWidth, u.textureHeight, !1),
                (g = new Wt(u.textureWidth, u.textureHeight, {
                  format: U,
                  type: R,
                  depthTexture: new $i(
                    u.textureWidth,
                    u.textureHeight,
                    s,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    n
                  ),
                  stencilBuffer: f.stencil,
                  colorSpace: t.outputColorSpace,
                  samples: f.antialias ? 4 : 0,
                })),
                (t.properties.get(g).__ignoreDepthValues = u.ignoreDepthValues);
            }
            (g.isXRRenderTarget = !0),
              this.setFoveation(o),
              (l = null),
              (s = await i.requestReferenceSpace(a)),
              B.setContext(i),
              B.start(),
              (n.isPresenting = !0),
              n.dispatchEvent({ type: "sessionstart" });
          }
        }),
        (this.getEnvironmentBlendMode = function () {
          if (null !== i) return i.environmentBlendMode;
        });
      const D = new Yt(),
        F = new Yt();
      function k(t, e) {
        null === e
          ? t.matrixWorld.copy(t.matrix)
          : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
          t.matrixWorldInverse.copy(t.matrixWorld).invert();
      }
      (this.updateCamera = function (t) {
        if (null === i) return;
        (b.near = M.near = T.near = t.near),
          (b.far = M.far = T.far = t.far),
          (E === b.near && w === b.far) ||
            (i.updateRenderState({ depthNear: b.near, depthFar: b.far }),
            (E = b.near),
            (w = b.far));
        const e = t.parent,
          n = b.cameras;
        k(b, e);
        for (let t = 0; t < n.length; t++) k(n[t], e);
        2 === n.length
          ? (function (t, e, n) {
              D.setFromMatrixPosition(e.matrixWorld),
                F.setFromMatrixPosition(n.matrixWorld);
              const i = D.distanceTo(F),
                r = e.projectionMatrix.elements,
                s = n.projectionMatrix.elements,
                a = r[14] / (r[10] - 1),
                o = r[14] / (r[10] + 1),
                l = (r[9] + 1) / r[5],
                c = (r[9] - 1) / r[5],
                h = (r[8] - 1) / r[0],
                u = (s[8] + 1) / s[0],
                d = a * h,
                p = a * u,
                f = i / (-h + u),
                m = f * -h;
              e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                t.translateX(m),
                t.translateZ(f),
                t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                t.matrixWorldInverse.copy(t.matrixWorld).invert();
              const g = a + f,
                _ = o + f,
                v = d - m,
                y = p + (i - m),
                x = ((l * o) / _) * g,
                T = ((c * o) / _) * g;
              t.projectionMatrix.makePerspective(v, y, x, T, g, _),
                t.projectionMatrixInverse.copy(t.projectionMatrix).invert();
            })(b, T, M)
          : b.projectionMatrix.copy(T.projectionMatrix),
          (function (t, e, n) {
            null === n
              ? t.matrix.copy(e.matrixWorld)
              : (t.matrix.copy(n.matrixWorld),
                t.matrix.invert(),
                t.matrix.multiply(e.matrixWorld)),
              t.matrix.decompose(t.position, t.quaternion, t.scale),
              t.updateMatrixWorld(!0),
              t.projectionMatrix.copy(e.projectionMatrix),
              t.projectionMatrixInverse.copy(e.projectionMatrixInverse),
              t.isPerspectiveCamera &&
                ((t.fov =
                  2 * ht * Math.atan(1 / t.projectionMatrix.elements[5])),
                (t.zoom = 1));
          })(t, b, e);
      }),
        (this.getCamera = function () {
          return b;
        }),
        (this.getFoveation = function () {
          if (null !== u || null !== d) return o;
        }),
        (this.setFoveation = function (t) {
          (o = t),
            null !== u && (u.fixedFoveation = t),
            null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t);
        });
      let z = null;
      const B = new gi();
      B.setAnimationLoop(function (e, i) {
        if (((c = i.getViewerPose(l || s)), (p = i), null !== c)) {
          const e = c.views;
          null !== d &&
            (t.setRenderTargetFramebuffer(g, d.framebuffer),
            t.setRenderTarget(g));
          let n = !1;
          e.length !== b.cameras.length && ((b.cameras.length = 0), (n = !0));
          for (let i = 0; i < e.length; i++) {
            const r = e[i];
            let s = null;
            if (null !== d) s = d.getViewport(r);
            else {
              const e = h.getViewSubImage(u, r);
              (s = e.viewport),
                0 === i &&
                  (t.setRenderTargetTextures(
                    g,
                    e.colorTexture,
                    u.ignoreDepthValues ? void 0 : e.depthStencilTexture
                  ),
                  t.setRenderTarget(g));
            }
            let a = S[i];
            void 0 === a &&
              ((a = new ri()),
              a.layers.enable(i),
              (a.viewport = new Gt()),
              (S[i] = a)),
              a.matrix.fromArray(r.transform.matrix),
              a.matrix.decompose(a.position, a.quaternion, a.scale),
              a.projectionMatrix.fromArray(r.projectionMatrix),
              a.projectionMatrixInverse.copy(a.projectionMatrix).invert(),
              a.viewport.set(s.x, s.y, s.width, s.height),
              0 === i &&
                (b.matrix.copy(a.matrix),
                b.matrix.decompose(b.position, b.quaternion, b.scale)),
              !0 === n && b.cameras.push(a);
          }
        }
        for (let t = 0; t < _.length; t++) {
          const e = v[t],
            n = _[t];
          null !== e && void 0 !== n && n.update(e, i, l || s);
        }
        z && z(e, i),
          i.detectedPlanes &&
            n.dispatchEvent({ type: "planesdetected", data: i }),
          (p = null);
      }),
        (this.setAnimationLoop = function (t) {
          z = t;
        }),
        (this.dispose = function () {});
    }
  }
  function Ks(t, e) {
    function n(t, e) {
      !0 === t.matrixAutoUpdate && t.updateMatrix(), e.value.copy(t.matrix);
    }
    function i(i, r) {
      (i.opacity.value = r.opacity),
        r.color && i.diffuse.value.copy(r.color),
        r.emissive &&
          i.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),
        r.map && ((i.map.value = r.map), n(r.map, i.mapTransform)),
        r.alphaMap &&
          ((i.alphaMap.value = r.alphaMap), n(r.alphaMap, i.alphaMapTransform)),
        r.bumpMap &&
          ((i.bumpMap.value = r.bumpMap),
          n(r.bumpMap, i.bumpMapTransform),
          (i.bumpScale.value = r.bumpScale),
          1 === r.side && (i.bumpScale.value *= -1)),
        r.normalMap &&
          ((i.normalMap.value = r.normalMap),
          n(r.normalMap, i.normalMapTransform),
          i.normalScale.value.copy(r.normalScale),
          1 === r.side && i.normalScale.value.negate()),
        r.displacementMap &&
          ((i.displacementMap.value = r.displacementMap),
          n(r.displacementMap, i.displacementMapTransform),
          (i.displacementScale.value = r.displacementScale),
          (i.displacementBias.value = r.displacementBias)),
        r.emissiveMap &&
          ((i.emissiveMap.value = r.emissiveMap),
          n(r.emissiveMap, i.emissiveMapTransform)),
        r.specularMap &&
          ((i.specularMap.value = r.specularMap),
          n(r.specularMap, i.specularMapTransform)),
        r.alphaTest > 0 && (i.alphaTest.value = r.alphaTest);
      const s = e.get(r).envMap;
      if (
        (s &&
          ((i.envMap.value = s),
          (i.flipEnvMap.value =
            s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1),
          (i.reflectivity.value = r.reflectivity),
          (i.ior.value = r.ior),
          (i.refractionRatio.value = r.refractionRatio)),
        r.lightMap)
      ) {
        i.lightMap.value = r.lightMap;
        const e = !0 === t._useLegacyLights ? Math.PI : 1;
        (i.lightMapIntensity.value = r.lightMapIntensity * e),
          n(r.lightMap, i.lightMapTransform);
      }
      r.aoMap &&
        ((i.aoMap.value = r.aoMap),
        (i.aoMapIntensity.value = r.aoMapIntensity),
        n(r.aoMap, i.aoMapTransform));
    }
    return {
      refreshFogUniforms: function (e, n) {
        n.color.getRGB(e.fogColor.value, ti(t)),
          n.isFog
            ? ((e.fogNear.value = n.near), (e.fogFar.value = n.far))
            : n.isFogExp2 && (e.fogDensity.value = n.density);
      },
      refreshMaterialUniforms: function (t, r, s, a, o) {
        r.isMeshBasicMaterial || r.isMeshLambertMaterial
          ? i(t, r)
          : r.isMeshToonMaterial
          ? (i(t, r),
            (function (t, e) {
              e.gradientMap && (t.gradientMap.value = e.gradientMap);
            })(t, r))
          : r.isMeshPhongMaterial
          ? (i(t, r),
            (function (t, e) {
              t.specular.value.copy(e.specular),
                (t.shininess.value = Math.max(e.shininess, 1e-4));
            })(t, r))
          : r.isMeshStandardMaterial
          ? (i(t, r),
            (function (t, i) {
              (t.metalness.value = i.metalness),
                i.metalnessMap &&
                  ((t.metalnessMap.value = i.metalnessMap),
                  n(i.metalnessMap, t.metalnessMapTransform)),
                (t.roughness.value = i.roughness),
                i.roughnessMap &&
                  ((t.roughnessMap.value = i.roughnessMap),
                  n(i.roughnessMap, t.roughnessMapTransform));
              e.get(i).envMap && (t.envMapIntensity.value = i.envMapIntensity);
            })(t, r),
            r.isMeshPhysicalMaterial &&
              (function (t, e, i) {
                (t.ior.value = e.ior),
                  e.sheen > 0 &&
                    (t.sheenColor.value
                      .copy(e.sheenColor)
                      .multiplyScalar(e.sheen),
                    (t.sheenRoughness.value = e.sheenRoughness),
                    e.sheenColorMap &&
                      ((t.sheenColorMap.value = e.sheenColorMap),
                      n(e.sheenColorMap, t.sheenColorMapTransform)),
                    e.sheenRoughnessMap &&
                      ((t.sheenRoughnessMap.value = e.sheenRoughnessMap),
                      n(e.sheenRoughnessMap, t.sheenRoughnessMapTransform))),
                  e.clearcoat > 0 &&
                    ((t.clearcoat.value = e.clearcoat),
                    (t.clearcoatRoughness.value = e.clearcoatRoughness),
                    e.clearcoatMap &&
                      ((t.clearcoatMap.value = e.clearcoatMap),
                      n(e.clearcoatMap, t.clearcoatMapTransform)),
                    e.clearcoatRoughnessMap &&
                      ((t.clearcoatRoughnessMap.value =
                        e.clearcoatRoughnessMap),
                      n(
                        e.clearcoatRoughnessMap,
                        t.clearcoatRoughnessMapTransform
                      )),
                    e.clearcoatNormalMap &&
                      ((t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                      n(e.clearcoatNormalMap, t.clearcoatNormalMapTransform),
                      t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                      1 === e.side && t.clearcoatNormalScale.value.negate())),
                  e.iridescence > 0 &&
                    ((t.iridescence.value = e.iridescence),
                    (t.iridescenceIOR.value = e.iridescenceIOR),
                    (t.iridescenceThicknessMinimum.value =
                      e.iridescenceThicknessRange[0]),
                    (t.iridescenceThicknessMaximum.value =
                      e.iridescenceThicknessRange[1]),
                    e.iridescenceMap &&
                      ((t.iridescenceMap.value = e.iridescenceMap),
                      n(e.iridescenceMap, t.iridescenceMapTransform)),
                    e.iridescenceThicknessMap &&
                      ((t.iridescenceThicknessMap.value =
                        e.iridescenceThicknessMap),
                      n(
                        e.iridescenceThicknessMap,
                        t.iridescenceThicknessMapTransform
                      ))),
                  e.transmission > 0 &&
                    ((t.transmission.value = e.transmission),
                    (t.transmissionSamplerMap.value = i.texture),
                    t.transmissionSamplerSize.value.set(i.width, i.height),
                    e.transmissionMap &&
                      ((t.transmissionMap.value = e.transmissionMap),
                      n(e.transmissionMap, t.transmissionMapTransform)),
                    (t.thickness.value = e.thickness),
                    e.thicknessMap &&
                      ((t.thicknessMap.value = e.thicknessMap),
                      n(e.thicknessMap, t.thicknessMapTransform)),
                    (t.attenuationDistance.value = e.attenuationDistance),
                    t.attenuationColor.value.copy(e.attenuationColor)),
                  e.anisotropy > 0 &&
                    (t.anisotropyVector.value.set(
                      e.anisotropy * Math.cos(e.anisotropyRotation),
                      e.anisotropy * Math.sin(e.anisotropyRotation)
                    ),
                    e.anisotropyMap &&
                      ((t.anisotropyMap.value = e.anisotropyMap),
                      n(e.anisotropyMap, t.anisotropyMapTransform))),
                  (t.specularIntensity.value = e.specularIntensity),
                  t.specularColor.value.copy(e.specularColor),
                  e.specularColorMap &&
                    ((t.specularColorMap.value = e.specularColorMap),
                    n(e.specularColorMap, t.specularColorMapTransform)),
                  e.specularIntensityMap &&
                    ((t.specularIntensityMap.value = e.specularIntensityMap),
                    n(e.specularIntensityMap, t.specularIntensityMapTransform));
              })(t, r, o))
          : r.isMeshMatcapMaterial
          ? (i(t, r),
            (function (t, e) {
              e.matcap && (t.matcap.value = e.matcap);
            })(t, r))
          : r.isMeshDepthMaterial
          ? i(t, r)
          : r.isMeshDistanceMaterial
          ? (i(t, r),
            (function (t, n) {
              const i = e.get(n).light;
              t.referencePosition.value.setFromMatrixPosition(i.matrixWorld),
                (t.nearDistance.value = i.shadow.camera.near),
                (t.farDistance.value = i.shadow.camera.far);
            })(t, r))
          : r.isMeshNormalMaterial
          ? i(t, r)
          : r.isLineBasicMaterial
          ? ((function (t, e) {
              t.diffuse.value.copy(e.color),
                (t.opacity.value = e.opacity),
                e.map && ((t.map.value = e.map), n(e.map, t.mapTransform));
            })(t, r),
            r.isLineDashedMaterial &&
              (function (t, e) {
                (t.dashSize.value = e.dashSize),
                  (t.totalSize.value = e.dashSize + e.gapSize),
                  (t.scale.value = e.scale);
              })(t, r))
          : r.isPointsMaterial
          ? (function (t, e, i, r) {
              t.diffuse.value.copy(e.color),
                (t.opacity.value = e.opacity),
                (t.size.value = e.size * i),
                (t.scale.value = 0.5 * r),
                e.map && ((t.map.value = e.map), n(e.map, t.uvTransform)),
                e.alphaMap &&
                  ((t.alphaMap.value = e.alphaMap),
                  n(e.alphaMap, t.alphaMapTransform)),
                e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
            })(t, r, s, a)
          : r.isSpriteMaterial
          ? (function (t, e) {
              t.diffuse.value.copy(e.color),
                (t.opacity.value = e.opacity),
                (t.rotation.value = e.rotation),
                e.map && ((t.map.value = e.map), n(e.map, t.mapTransform)),
                e.alphaMap &&
                  ((t.alphaMap.value = e.alphaMap),
                  n(e.alphaMap, t.alphaMapTransform)),
                e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
            })(t, r)
          : r.isShadowMaterial
          ? (t.color.value.copy(r.color), (t.opacity.value = r.opacity))
          : r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
      },
    };
  }
  function Zs(t, e, n, i) {
    let r = {},
      s = {},
      a = [];
    const o = n.isWebGL2 ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
    function l(t, e, n, i) {
      const r = t.value,
        s = e + "_" + n;
      if (void 0 === i[s])
        return (
          (i[s] =
            "number" == typeof r || "boolean" == typeof r ? r : r.clone()),
          !0
        );
      {
        const t = i[s];
        if ("number" == typeof r || "boolean" == typeof r) {
          if (t !== r) return (i[s] = r), !0;
        } else if (!1 === t.equals(r)) return t.copy(r), !0;
      }
      return !1;
    }
    function c(t) {
      const e = { boundary: 0, storage: 0 };
      return (
        "number" == typeof t || "boolean" == typeof t
          ? ((e.boundary = 4), (e.storage = 4))
          : t.isVector2
          ? ((e.boundary = 8), (e.storage = 8))
          : t.isVector3 || t.isColor
          ? ((e.boundary = 16), (e.storage = 12))
          : t.isVector4
          ? ((e.boundary = 16), (e.storage = 16))
          : t.isMatrix3
          ? ((e.boundary = 48), (e.storage = 48))
          : t.isMatrix4
          ? ((e.boundary = 64), (e.storage = 64))
          : t.isTexture
          ? console.warn(
              "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
            )
          : console.warn(
              "THREE.WebGLRenderer: Unsupported uniform value type.",
              t
            ),
        e
      );
    }
    function h(e) {
      const n = e.target;
      n.removeEventListener("dispose", h);
      const i = a.indexOf(n.__bindingPointIndex);
      a.splice(i, 1), t.deleteBuffer(r[n.id]), delete r[n.id], delete s[n.id];
    }
    return {
      bind: function (t, e) {
        const n = e.program;
        i.uniformBlockBinding(t, n);
      },
      update: function (n, u) {
        let d = r[n.id];
        void 0 === d &&
          ((function (t) {
            const e = t.uniforms;
            let n = 0;
            for (let t = 0, i = e.length; t < i; t++) {
              const i = Array.isArray(e[t]) ? e[t] : [e[t]];
              for (let t = 0, e = i.length; t < e; t++) {
                const e = i[t],
                  r = Array.isArray(e.value) ? e.value : [e.value];
                for (let t = 0, i = r.length; t < i; t++) {
                  const i = c(r[t]),
                    s = n % 16;
                  0 !== s && 16 - s < i.boundary && (n += 16 - s),
                    (e.__data = new Float32Array(
                      i.storage / Float32Array.BYTES_PER_ELEMENT
                    )),
                    (e.__offset = n),
                    (n += i.storage);
                }
              }
            }
            const i = n % 16;
            i > 0 && (n += 16 - i), (t.__size = n), (t.__cache = {});
          })(n),
          (d = (function (e) {
            const n = (function () {
              for (let t = 0; t < o; t++)
                if (-1 === a.indexOf(t)) return a.push(t), t;
              return (
                console.error(
                  "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
                ),
                0
              );
            })();
            e.__bindingPointIndex = n;
            const i = t.createBuffer(),
              r = e.__size,
              s = e.usage;
            return (
              t.bindBuffer(t.UNIFORM_BUFFER, i),
              t.bufferData(t.UNIFORM_BUFFER, r, s),
              t.bindBuffer(t.UNIFORM_BUFFER, null),
              t.bindBufferBase(t.UNIFORM_BUFFER, n, i),
              i
            );
          })(n)),
          (r[n.id] = d),
          n.addEventListener("dispose", h));
        const p = u.program;
        i.updateUBOMapping(n, p);
        const f = e.render.frame;
        s[n.id] !== f &&
          ((function (e) {
            const n = r[e.id],
              i = e.uniforms,
              s = e.__cache;
            t.bindBuffer(t.UNIFORM_BUFFER, n);
            for (let e = 0, n = i.length; e < n; e++) {
              const n = Array.isArray(i[e]) ? i[e] : [i[e]];
              for (let i = 0, r = n.length; i < r; i++) {
                const r = n[i];
                if (!0 === l(r, e, i, s)) {
                  const e = r.__offset,
                    n = Array.isArray(r.value) ? r.value : [r.value];
                  let i = 0;
                  for (let s = 0; s < n.length; s++) {
                    const a = n[s],
                      o = c(a);
                    "number" == typeof a || "boolean" == typeof a
                      ? ((r.__data[0] = a),
                        t.bufferSubData(t.UNIFORM_BUFFER, e + i, r.__data))
                      : a.isMatrix3
                      ? ((r.__data[0] = a.elements[0]),
                        (r.__data[1] = a.elements[1]),
                        (r.__data[2] = a.elements[2]),
                        (r.__data[3] = 0),
                        (r.__data[4] = a.elements[3]),
                        (r.__data[5] = a.elements[4]),
                        (r.__data[6] = a.elements[5]),
                        (r.__data[7] = 0),
                        (r.__data[8] = a.elements[6]),
                        (r.__data[9] = a.elements[7]),
                        (r.__data[10] = a.elements[8]),
                        (r.__data[11] = 0))
                      : (a.toArray(r.__data, i),
                        (i += o.storage / Float32Array.BYTES_PER_ELEMENT));
                  }
                  t.bufferSubData(t.UNIFORM_BUFFER, e, r.__data);
                }
              }
            }
            t.bindBuffer(t.UNIFORM_BUFFER, null);
          })(n),
          (s[n.id] = f));
      },
      dispose: function () {
        for (const e in r) t.deleteBuffer(r[e]);
        (a = []), (r = {}), (s = {});
      },
    };
  }
  class Js {
    constructor(t = {}) {
      const {
        canvas: n = Et(),
        context: i = null,
        depth: r = !0,
        stencil: s = !0,
        alpha: a = !1,
        antialias: o = !1,
        premultipliedAlpha: l = !0,
        preserveDrawingBuffer: h = !1,
        powerPreference: u = "default",
        failIfMajorPerformanceCaveat: d = !1,
      } = t;
      let p;
      (this.isWebGLRenderer = !0),
        (p = null !== i ? i.getContextAttributes().alpha : a);
      const f = new Uint32Array(4),
        m = new Int32Array(4);
      let g = null,
        _ = null;
      const v = [],
        y = [];
      (this.domElement = n),
        (this.debug = { checkShaderErrors: !0, onShaderError: null }),
        (this.autoClear = !0),
        (this.autoClearColor = !0),
        (this.autoClearDepth = !0),
        (this.autoClearStencil = !0),
        (this.sortObjects = !0),
        (this.clippingPlanes = []),
        (this.localClippingEnabled = !1),
        (this._outputColorSpace = q),
        (this._useLegacyLights = !1),
        (this.toneMapping = c),
        (this.toneMappingExposure = 1);
      const x = this;
      let T = !1,
        M = 0,
        S = 0,
        b = null,
        E = -1,
        w = null;
      const N = new Gt(),
        O = new Gt();
      let F = null;
      const k = new pn(0);
      let z = 0,
        B = n.width,
        H = n.height,
        G = 1,
        V = null,
        W = null;
      const X = new Gt(0, 0, B, H),
        j = new Gt(0, 0, B, H);
      let K = !1;
      const Z = new mi();
      let J = !1,
        Q = !1,
        $ = null;
      const tt = new be(),
        et = new xt(),
        nt = new Yt(),
        it = {
          background: null,
          fog: null,
          environment: null,
          overrideMaterial: null,
          isScene: !0,
        };
      function rt() {
        return null === b ? G : 1;
      }
      let st,
        at,
        ot,
        lt,
        ct,
        ht,
        ut,
        dt,
        pt,
        ft,
        mt,
        _t,
        vt,
        yt,
        Tt,
        Mt,
        St,
        bt,
        wt,
        At,
        Rt,
        Ct,
        Pt,
        Lt,
        Dt = i;
      function It(t, e) {
        for (let i = 0; i < t.length; i++) {
          const r = t[i],
            s = n.getContext(r, e);
          if (null !== s) return s;
        }
        return null;
      }
      try {
        const t = {
          alpha: !0,
          depth: r,
          stencil: s,
          antialias: o,
          premultipliedAlpha: l,
          preserveDrawingBuffer: h,
          powerPreference: u,
          failIfMajorPerformanceCaveat: d,
        };
        if (
          ("setAttribute" in n &&
            n.setAttribute("data-engine", `three.js r${e}`),
          n.addEventListener("webglcontextlost", Ot, !1),
          n.addEventListener("webglcontextrestored", Ft, !1),
          n.addEventListener("webglcontextcreationerror", kt, !1),
          null === Dt)
        ) {
          const e = ["webgl2", "webgl", "experimental-webgl"];
          if (
            (!0 === x.isWebGL1Renderer && e.shift(),
            (Dt = It(e, t)),
            null === Dt)
          )
            throw It(e)
              ? new Error(
                  "Error creating WebGL context with your selected attributes."
                )
              : new Error("Error creating WebGL context.");
        }
        "undefined" != typeof WebGLRenderingContext &&
          Dt instanceof WebGLRenderingContext &&
          console.warn(
            "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
          ),
          void 0 === Dt.getShaderPrecisionFormat &&
            (Dt.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
      } catch (t) {
        throw (console.error("THREE.WebGLRenderer: " + t.message), t);
      }
      function Ut() {
        (st = new Xi(Dt)),
          (at = new wi(Dt, st, t)),
          st.init(at),
          (Ct = new Vs(Dt, st, at)),
          (ot = new Hs(Dt, st, at)),
          (lt = new Yi(Dt)),
          (ct = new As()),
          (ht = new Gs(Dt, st, ot, ct, at, Ct, lt)),
          (ut = new Ri(x)),
          (dt = new Wi(x)),
          (pt = new _i(Dt, at)),
          (Pt = new bi(Dt, st, pt, at)),
          (ft = new ji(Dt, pt, lt, Pt)),
          (mt = new Qi(Dt, ft, pt, lt)),
          (wt = new Ji(Dt, at, ht)),
          (Mt = new Ai(ct)),
          (_t = new ws(x, ut, dt, st, at, Pt, Mt)),
          (vt = new Ks(x, ct)),
          (yt = new Ls()),
          (Tt = new Fs(st, at)),
          (bt = new Si(x, ut, dt, ot, mt, p, l)),
          (St = new Bs(x, mt, at)),
          (Lt = new Zs(Dt, lt, at, ot)),
          (At = new Ei(Dt, st, lt, at)),
          (Rt = new qi(Dt, st, lt, at)),
          (lt.programs = _t.programs),
          (x.capabilities = at),
          (x.extensions = st),
          (x.properties = ct),
          (x.renderLists = yt),
          (x.shadowMap = St),
          (x.state = ot),
          (x.info = lt);
      }
      Ut();
      const Nt = new Ys(x, Dt);
      function Ot(t) {
        t.preventDefault(),
          console.log("THREE.WebGLRenderer: Context Lost."),
          (T = !0);
      }
      function Ft() {
        console.log("THREE.WebGLRenderer: Context Restored."), (T = !1);
        const t = lt.autoReset,
          e = St.enabled,
          n = St.autoUpdate,
          i = St.needsUpdate,
          r = St.type;
        Ut(),
          (lt.autoReset = t),
          (St.enabled = e),
          (St.autoUpdate = n),
          (St.needsUpdate = i),
          (St.type = r);
      }
      function kt(t) {
        console.error(
          "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
          t.statusMessage
        );
      }
      function zt(t) {
        const e = t.target;
        e.removeEventListener("dispose", zt),
          (function (t) {
            (function (t) {
              const e = ct.get(t).programs;
              void 0 !== e &&
                (e.forEach(function (t) {
                  _t.releaseProgram(t);
                }),
                t.isShaderMaterial && _t.releaseShaderCache(t));
            })(t),
              ct.remove(t);
          })(e);
      }
      function Bt(t, e, n) {
        !0 === t.transparent && 2 === t.side && !1 === t.forceSinglePass
          ? ((t.side = 1),
            (t.needsUpdate = !0),
            Qt(t, e, n),
            (t.side = 0),
            (t.needsUpdate = !0),
            Qt(t, e, n),
            (t.side = 2))
          : Qt(t, e, n);
      }
      (this.xr = Nt),
        (this.getContext = function () {
          return Dt;
        }),
        (this.getContextAttributes = function () {
          return Dt.getContextAttributes();
        }),
        (this.forceContextLoss = function () {
          const t = st.get("WEBGL_lose_context");
          t && t.loseContext();
        }),
        (this.forceContextRestore = function () {
          const t = st.get("WEBGL_lose_context");
          t && t.restoreContext();
        }),
        (this.getPixelRatio = function () {
          return G;
        }),
        (this.setPixelRatio = function (t) {
          void 0 !== t && ((G = t), this.setSize(B, H, !1));
        }),
        (this.getSize = function (t) {
          return t.set(B, H);
        }),
        (this.setSize = function (t, e, i = !0) {
          Nt.isPresenting
            ? console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting."
              )
            : ((B = t),
              (H = e),
              (n.width = Math.floor(t * G)),
              (n.height = Math.floor(e * G)),
              !0 === i &&
                ((n.style.width = t + "px"), (n.style.height = e + "px")),
              this.setViewport(0, 0, t, e));
        }),
        (this.getDrawingBufferSize = function (t) {
          return t.set(B * G, H * G).floor();
        }),
        (this.setDrawingBufferSize = function (t, e, i) {
          (B = t),
            (H = e),
            (G = i),
            (n.width = Math.floor(t * i)),
            (n.height = Math.floor(e * i)),
            this.setViewport(0, 0, t, e);
        }),
        (this.getCurrentViewport = function (t) {
          return t.copy(N);
        }),
        (this.getViewport = function (t) {
          return t.copy(X);
        }),
        (this.setViewport = function (t, e, n, i) {
          t.isVector4 ? X.set(t.x, t.y, t.z, t.w) : X.set(t, e, n, i),
            ot.viewport(N.copy(X).multiplyScalar(G).floor());
        }),
        (this.getScissor = function (t) {
          return t.copy(j);
        }),
        (this.setScissor = function (t, e, n, i) {
          t.isVector4 ? j.set(t.x, t.y, t.z, t.w) : j.set(t, e, n, i),
            ot.scissor(O.copy(j).multiplyScalar(G).floor());
        }),
        (this.getScissorTest = function () {
          return K;
        }),
        (this.setScissorTest = function (t) {
          ot.setScissorTest((K = t));
        }),
        (this.setOpaqueSort = function (t) {
          V = t;
        }),
        (this.setTransparentSort = function (t) {
          W = t;
        }),
        (this.getClearColor = function (t) {
          return t.copy(bt.getClearColor());
        }),
        (this.setClearColor = function () {
          bt.setClearColor.apply(bt, arguments);
        }),
        (this.getClearAlpha = function () {
          return bt.getClearAlpha();
        }),
        (this.setClearAlpha = function () {
          bt.setClearAlpha.apply(bt, arguments);
        }),
        (this.clear = function (t = !0, e = !0, n = !0) {
          let i = 0;
          if (t) {
            let t = !1;
            if (null !== b) {
              const e = b.texture.format;
              t = 1033 === e || 1031 === e || 1029 === e;
            }
            if (t) {
              const t = b.texture.type,
                e =
                  t === R ||
                  t === P ||
                  t === C ||
                  t === I ||
                  1017 === t ||
                  1018 === t,
                n = bt.getClearColor(),
                i = bt.getClearAlpha(),
                r = n.r,
                s = n.g,
                a = n.b;
              e
                ? ((f[0] = r),
                  (f[1] = s),
                  (f[2] = a),
                  (f[3] = i),
                  Dt.clearBufferuiv(Dt.COLOR, 0, f))
                : ((m[0] = r),
                  (m[1] = s),
                  (m[2] = a),
                  (m[3] = i),
                  Dt.clearBufferiv(Dt.COLOR, 0, m));
            } else i |= Dt.COLOR_BUFFER_BIT;
          }
          e && (i |= Dt.DEPTH_BUFFER_BIT),
            n &&
              ((i |= Dt.STENCIL_BUFFER_BIT),
              this.state.buffers.stencil.setMask(4294967295)),
            Dt.clear(i);
        }),
        (this.clearColor = function () {
          this.clear(!0, !1, !1);
        }),
        (this.clearDepth = function () {
          this.clear(!1, !0, !1);
        }),
        (this.clearStencil = function () {
          this.clear(!1, !1, !0);
        }),
        (this.dispose = function () {
          n.removeEventListener("webglcontextlost", Ot, !1),
            n.removeEventListener("webglcontextrestored", Ft, !1),
            n.removeEventListener("webglcontextcreationerror", kt, !1),
            yt.dispose(),
            Tt.dispose(),
            ct.dispose(),
            ut.dispose(),
            dt.dispose(),
            mt.dispose(),
            Pt.dispose(),
            Lt.dispose(),
            _t.dispose(),
            Nt.dispose(),
            Nt.removeEventListener("sessionstart", Vt),
            Nt.removeEventListener("sessionend", Xt),
            $ && ($.dispose(), ($ = null)),
            jt.stop();
        }),
        (this.renderBufferDirect = function (t, e, n, i, r, s) {
          null === e && (e = it);
          const a = r.isMesh && r.matrixWorld.determinant() < 0,
            o = (function (t, e, n, i, r) {
              !0 !== e.isScene && (e = it), ht.resetTextureUnits();
              const s = e.fog,
                a = i.isMeshStandardMaterial ? e.environment : null,
                o =
                  null === b
                    ? x.outputColorSpace
                    : !0 === b.isXRRenderTarget
                    ? b.texture.colorSpace
                    : Y,
                l = (i.isMeshStandardMaterial ? dt : ut).get(i.envMap || a),
                h =
                  !0 === i.vertexColors &&
                  !!n.attributes.color &&
                  4 === n.attributes.color.itemSize,
                u =
                  !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0),
                d = !!n.morphAttributes.position,
                p = !!n.morphAttributes.normal,
                f = !!n.morphAttributes.color;
              let m = c;
              i.toneMapped &&
                ((null !== b && !0 !== b.isXRRenderTarget) ||
                  (m = x.toneMapping));
              const g =
                  n.morphAttributes.position ||
                  n.morphAttributes.normal ||
                  n.morphAttributes.color,
                v = void 0 !== g ? g.length : 0,
                y = ct.get(i),
                T = _.state.lights;
              if (!0 === J && (!0 === Q || t !== w)) {
                const e = t === w && i.id === E;
                Mt.setState(i, t, e);
              }
              let M = !1;
              i.version === y.__version
                ? (y.needsLights && y.lightsStateVersion !== T.state.version) ||
                  y.outputColorSpace !== o ||
                  (r.isBatchedMesh && !1 === y.batching)
                  ? (M = !0)
                  : r.isBatchedMesh || !0 !== y.batching
                  ? r.isInstancedMesh && !1 === y.instancing
                    ? (M = !0)
                    : r.isInstancedMesh || !0 !== y.instancing
                    ? r.isSkinnedMesh && !1 === y.skinning
                      ? (M = !0)
                      : r.isSkinnedMesh || !0 !== y.skinning
                      ? (r.isInstancedMesh &&
                          !0 === y.instancingColor &&
                          null === r.instanceColor) ||
                        (r.isInstancedMesh &&
                          !1 === y.instancingColor &&
                          null !== r.instanceColor) ||
                        y.envMap !== l ||
                        (!0 === i.fog && y.fog !== s)
                        ? (M = !0)
                        : void 0 === y.numClippingPlanes ||
                          (y.numClippingPlanes === Mt.numPlanes &&
                            y.numIntersection === Mt.numIntersection)
                        ? (y.vertexAlphas !== h ||
                            y.vertexTangents !== u ||
                            y.morphTargets !== d ||
                            y.morphNormals !== p ||
                            y.morphColors !== f ||
                            y.toneMapping !== m ||
                            (!0 === at.isWebGL2 &&
                              y.morphTargetsCount !== v)) &&
                          (M = !0)
                        : (M = !0)
                      : (M = !0)
                    : (M = !0)
                  : (M = !0)
                : ((M = !0), (y.__version = i.version));
              let S = y.currentProgram;
              !0 === M && (S = Qt(i, e, r));
              let A = !1,
                R = !1,
                C = !1;
              const P = S.getUniforms(),
                L = y.uniforms;
              if (
                (ot.useProgram(S.program) && ((A = !0), (R = !0), (C = !0)),
                i.id !== E && ((E = i.id), (R = !0)),
                A || w !== t)
              ) {
                P.setValue(Dt, "projectionMatrix", t.projectionMatrix),
                  P.setValue(Dt, "viewMatrix", t.matrixWorldInverse);
                const e = P.map.cameraPosition;
                void 0 !== e &&
                  e.setValue(Dt, nt.setFromMatrixPosition(t.matrixWorld)),
                  at.logarithmicDepthBuffer &&
                    P.setValue(
                      Dt,
                      "logDepthBufFC",
                      2 / (Math.log(t.far + 1) / Math.LN2)
                    ),
                  (i.isMeshPhongMaterial ||
                    i.isMeshToonMaterial ||
                    i.isMeshLambertMaterial ||
                    i.isMeshBasicMaterial ||
                    i.isMeshStandardMaterial ||
                    i.isShaderMaterial) &&
                    P.setValue(
                      Dt,
                      "isOrthographic",
                      !0 === t.isOrthographicCamera
                    ),
                  w !== t && ((w = t), (R = !0), (C = !0));
              }
              if (r.isSkinnedMesh) {
                P.setOptional(Dt, r, "bindMatrix"),
                  P.setOptional(Dt, r, "bindMatrixInverse");
                const t = r.skeleton;
                t &&
                  (at.floatVertexTextures
                    ? (null === t.boneTexture && t.computeBoneTexture(),
                      P.setValue(Dt, "boneTexture", t.boneTexture, ht))
                    : console.warn(
                        "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
                      ));
              }
              r.isBatchedMesh &&
                (P.setOptional(Dt, r, "batchingTexture"),
                P.setValue(Dt, "batchingTexture", r._matricesTexture, ht));
              const D = n.morphAttributes;
              var I, U;
              if (
                ((void 0 !== D.position ||
                  void 0 !== D.normal ||
                  (void 0 !== D.color && !0 === at.isWebGL2)) &&
                  wt.update(r, n, S),
                (R || y.receiveShadow !== r.receiveShadow) &&
                  ((y.receiveShadow = r.receiveShadow),
                  P.setValue(Dt, "receiveShadow", r.receiveShadow)),
                i.isMeshGouraudMaterial &&
                  null !== i.envMap &&
                  ((L.envMap.value = l),
                  (L.flipEnvMap.value =
                    l.isCubeTexture && !1 === l.isRenderTargetTexture
                      ? -1
                      : 1)),
                R &&
                  (P.setValue(Dt, "toneMappingExposure", x.toneMappingExposure),
                  y.needsLights &&
                    ((U = C),
                    ((I = L).ambientLightColor.needsUpdate = U),
                    (I.lightProbe.needsUpdate = U),
                    (I.directionalLights.needsUpdate = U),
                    (I.directionalLightShadows.needsUpdate = U),
                    (I.pointLights.needsUpdate = U),
                    (I.pointLightShadows.needsUpdate = U),
                    (I.spotLights.needsUpdate = U),
                    (I.spotLightShadows.needsUpdate = U),
                    (I.rectAreaLights.needsUpdate = U),
                    (I.hemisphereLights.needsUpdate = U)),
                  s && !0 === i.fog && vt.refreshFogUniforms(L, s),
                  vt.refreshMaterialUniforms(L, i, G, H, $),
                  rs.upload(Dt, $t(y), L, ht)),
                i.isShaderMaterial &&
                  !0 === i.uniformsNeedUpdate &&
                  (rs.upload(Dt, $t(y), L, ht), (i.uniformsNeedUpdate = !1)),
                i.isSpriteMaterial && P.setValue(Dt, "center", r.center),
                P.setValue(Dt, "modelViewMatrix", r.modelViewMatrix),
                P.setValue(Dt, "normalMatrix", r.normalMatrix),
                P.setValue(Dt, "modelMatrix", r.matrixWorld),
                i.isShaderMaterial || i.isRawShaderMaterial)
              ) {
                const t = i.uniformsGroups;
                for (let e = 0, n = t.length; e < n; e++)
                  if (at.isWebGL2) {
                    const n = t[e];
                    Lt.update(n, S), Lt.bind(n, S);
                  } else
                    console.warn(
                      "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
                    );
              }
              return S;
            })(t, e, n, i, r);
          ot.setMaterial(i, a);
          let l = n.index,
            h = 1;
          if (!0 === i.wireframe) {
            if (((l = ft.getWireframeAttribute(n)), void 0 === l)) return;
            h = 2;
          }
          const u = n.drawRange,
            d = n.attributes.position;
          let p = u.start * h,
            f = (u.start + u.count) * h;
          null !== s &&
            ((p = Math.max(p, s.start * h)),
            (f = Math.min(f, (s.start + s.count) * h))),
            null !== l
              ? ((p = Math.max(p, 0)), (f = Math.min(f, l.count)))
              : null != d && ((p = Math.max(p, 0)), (f = Math.min(f, d.count)));
          const m = f - p;
          if (m < 0 || m === 1 / 0) return;
          let g;
          Pt.setup(r, i, o, n, l);
          let v = At;
          if (
            (null !== l && ((g = pt.get(l)), (v = Rt), v.setIndex(g)), r.isMesh)
          )
            !0 === i.wireframe
              ? (ot.setLineWidth(i.wireframeLinewidth * rt()),
                v.setMode(Dt.LINES))
              : v.setMode(Dt.TRIANGLES);
          else if (r.isLine) {
            let t = i.linewidth;
            void 0 === t && (t = 1),
              ot.setLineWidth(t * rt()),
              r.isLineSegments
                ? v.setMode(Dt.LINES)
                : r.isLineLoop
                ? v.setMode(Dt.LINE_LOOP)
                : v.setMode(Dt.LINE_STRIP);
          } else
            r.isPoints
              ? v.setMode(Dt.POINTS)
              : r.isSprite && v.setMode(Dt.TRIANGLES);
          if (r.isBatchedMesh)
            v.renderMultiDraw(
              r._multiDrawStarts,
              r._multiDrawCounts,
              r._multiDrawCount
            );
          else if (r.isInstancedMesh) v.renderInstances(p, m, r.count);
          else if (n.isInstancedBufferGeometry) {
            const t =
                void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
              e = Math.min(n.instanceCount, t);
            v.renderInstances(p, m, e);
          } else v.render(p, m);
        }),
        (this.compile = function (t, e, n = null) {
          null === n && (n = t),
            (_ = Tt.get(n)),
            _.init(),
            y.push(_),
            n.traverseVisible(function (t) {
              t.isLight &&
                t.layers.test(e.layers) &&
                (_.pushLight(t), t.castShadow && _.pushShadow(t));
            }),
            t !== n &&
              t.traverseVisible(function (t) {
                t.isLight &&
                  t.layers.test(e.layers) &&
                  (_.pushLight(t), t.castShadow && _.pushShadow(t));
              }),
            _.setupLights(x._useLegacyLights);
          const i = new Set();
          return (
            t.traverse(function (t) {
              const e = t.material;
              if (e)
                if (Array.isArray(e))
                  for (let r = 0; r < e.length; r++) {
                    const s = e[r];
                    Bt(s, n, t), i.add(s);
                  }
                else Bt(e, n, t), i.add(e);
            }),
            y.pop(),
            (_ = null),
            i
          );
        }),
        (this.compileAsync = function (t, e, n = null) {
          const i = this.compile(t, e, n);
          return new Promise((e) => {
            function n() {
              i.forEach(function (t) {
                ct.get(t).currentProgram.isReady() && i.delete(t);
              }),
                0 !== i.size ? setTimeout(n, 10) : e(t);
            }
            null !== st.get("KHR_parallel_shader_compile")
              ? n()
              : setTimeout(n, 10);
          });
        });
      let Ht = null;
      function Vt() {
        jt.stop();
      }
      function Xt() {
        jt.start();
      }
      const jt = new gi();
      function qt(t, e, n, i) {
        if (!1 === t.visible) return;
        if (t.layers.test(e.layers))
          if (t.isGroup) n = t.renderOrder;
          else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
          else if (t.isLight) _.pushLight(t), t.castShadow && _.pushShadow(t);
          else if (t.isSprite) {
            if (!t.frustumCulled || Z.intersectsSprite(t)) {
              i && nt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(tt);
              const e = mt.update(t),
                r = t.material;
              r.visible && g.push(t, e, r, n, nt.z, null);
            }
          } else if (
            (t.isMesh || t.isLine || t.isPoints) &&
            (!t.frustumCulled || Z.intersectsObject(t))
          ) {
            const e = mt.update(t),
              r = t.material;
            if (
              (i &&
                (void 0 !== t.boundingSphere
                  ? (null === t.boundingSphere && t.computeBoundingSphere(),
                    nt.copy(t.boundingSphere.center))
                  : (null === e.boundingSphere && e.computeBoundingSphere(),
                    nt.copy(e.boundingSphere.center)),
                nt.applyMatrix4(t.matrixWorld).applyMatrix4(tt)),
              Array.isArray(r))
            ) {
              const i = e.groups;
              for (let s = 0, a = i.length; s < a; s++) {
                const a = i[s],
                  o = r[a.materialIndex];
                o && o.visible && g.push(t, e, o, n, nt.z, a);
              }
            } else r.visible && g.push(t, e, r, n, nt.z, null);
          }
        const r = t.children;
        for (let t = 0, s = r.length; t < s; t++) qt(r[t], e, n, i);
      }
      function Kt(t, e, n, i) {
        const r = t.opaque,
          s = t.transmissive,
          a = t.transparent;
        _.setupLightsView(n),
          !0 === J && Mt.setGlobalState(x.clippingPlanes, n),
          s.length > 0 &&
            (function (t, e, n, i) {
              if (null !== (!0 === n.isScene ? n.overrideMaterial : null))
                return;
              const r = at.isWebGL2;
              null === $ &&
                ($ = new Wt(1, 1, {
                  generateMipmaps: !0,
                  type: st.has("EXT_color_buffer_half_float") ? D : R,
                  minFilter: A,
                  samples: r ? 4 : 0,
                })),
                x.getDrawingBufferSize(et),
                r ? $.setSize(et.x, et.y) : $.setSize(gt(et.x), gt(et.y));
              const s = x.getRenderTarget();
              x.setRenderTarget($),
                x.getClearColor(k),
                (z = x.getClearAlpha()),
                z < 1 && x.setClearColor(16777215, 0.5),
                x.clear();
              const a = x.toneMapping;
              (x.toneMapping = c),
                Zt(t, n, i),
                ht.updateMultisampleRenderTarget($),
                ht.updateRenderTargetMipmap($);
              let o = !1;
              for (let t = 0, r = e.length; t < r; t++) {
                const r = e[t],
                  s = r.object,
                  a = r.geometry,
                  l = r.material,
                  c = r.group;
                if (2 === l.side && s.layers.test(i.layers)) {
                  const t = l.side;
                  (l.side = 1),
                    (l.needsUpdate = !0),
                    Jt(s, n, i, a, l, c),
                    (l.side = t),
                    (l.needsUpdate = !0),
                    (o = !0);
                }
              }
              !0 === o &&
                (ht.updateMultisampleRenderTarget($),
                ht.updateRenderTargetMipmap($)),
                x.setRenderTarget(s),
                x.setClearColor(k, z),
                (x.toneMapping = a);
            })(r, s, e, n),
          i && ot.viewport(N.copy(i)),
          r.length > 0 && Zt(r, e, n),
          s.length > 0 && Zt(s, e, n),
          a.length > 0 && Zt(a, e, n),
          ot.buffers.depth.setTest(!0),
          ot.buffers.depth.setMask(!0),
          ot.buffers.color.setMask(!0),
          ot.setPolygonOffset(!1);
      }
      function Zt(t, e, n) {
        const i = !0 === e.isScene ? e.overrideMaterial : null;
        for (let r = 0, s = t.length; r < s; r++) {
          const s = t[r],
            a = s.object,
            o = s.geometry,
            l = null === i ? s.material : i,
            c = s.group;
          a.layers.test(n.layers) && Jt(a, e, n, o, l, c);
        }
      }
      function Jt(t, e, n, i, r, s) {
        t.onBeforeRender(x, e, n, i, r, s),
          t.modelViewMatrix.multiplyMatrices(
            n.matrixWorldInverse,
            t.matrixWorld
          ),
          t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
          r.onBeforeRender(x, e, n, i, t, s),
          !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass
            ? ((r.side = 1),
              (r.needsUpdate = !0),
              x.renderBufferDirect(n, e, i, r, t, s),
              (r.side = 0),
              (r.needsUpdate = !0),
              x.renderBufferDirect(n, e, i, r, t, s),
              (r.side = 2))
            : x.renderBufferDirect(n, e, i, r, t, s),
          t.onAfterRender(x, e, n, i, r, s);
      }
      function Qt(t, e, n) {
        !0 !== e.isScene && (e = it);
        const i = ct.get(t),
          r = _.state.lights,
          s = _.state.shadowsArray,
          a = r.state.version,
          o = _t.getParameters(t, r.state, s, e, n),
          l = _t.getProgramCacheKey(o);
        let c = i.programs;
        (i.environment = t.isMeshStandardMaterial ? e.environment : null),
          (i.fog = e.fog),
          (i.envMap = (t.isMeshStandardMaterial ? dt : ut).get(
            t.envMap || i.environment
          )),
          void 0 === c &&
            (t.addEventListener("dispose", zt),
            (c = new Map()),
            (i.programs = c));
        let h = c.get(l);
        if (void 0 !== h) {
          if (i.currentProgram === h && i.lightsStateVersion === a)
            return te(t, o), h;
        } else
          (o.uniforms = _t.getUniforms(t)),
            t.onBuild(n, o, x),
            t.onBeforeCompile(o, x),
            (h = _t.acquireProgram(o, l)),
            c.set(l, h),
            (i.uniforms = o.uniforms);
        const u = i.uniforms;
        return (
          ((t.isShaderMaterial || t.isRawShaderMaterial) &&
            !0 !== t.clipping) ||
            (u.clippingPlanes = Mt.uniform),
          te(t, o),
          (i.needsLights = (function (t) {
            return (
              t.isMeshLambertMaterial ||
              t.isMeshToonMaterial ||
              t.isMeshPhongMaterial ||
              t.isMeshStandardMaterial ||
              t.isShadowMaterial ||
              (t.isShaderMaterial && !0 === t.lights)
            );
          })(t)),
          (i.lightsStateVersion = a),
          i.needsLights &&
            ((u.ambientLightColor.value = r.state.ambient),
            (u.lightProbe.value = r.state.probe),
            (u.directionalLights.value = r.state.directional),
            (u.directionalLightShadows.value = r.state.directionalShadow),
            (u.spotLights.value = r.state.spot),
            (u.spotLightShadows.value = r.state.spotShadow),
            (u.rectAreaLights.value = r.state.rectArea),
            (u.ltc_1.value = r.state.rectAreaLTC1),
            (u.ltc_2.value = r.state.rectAreaLTC2),
            (u.pointLights.value = r.state.point),
            (u.pointLightShadows.value = r.state.pointShadow),
            (u.hemisphereLights.value = r.state.hemi),
            (u.directionalShadowMap.value = r.state.directionalShadowMap),
            (u.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
            (u.spotShadowMap.value = r.state.spotShadowMap),
            (u.spotLightMatrix.value = r.state.spotLightMatrix),
            (u.spotLightMap.value = r.state.spotLightMap),
            (u.pointShadowMap.value = r.state.pointShadowMap),
            (u.pointShadowMatrix.value = r.state.pointShadowMatrix)),
          (i.currentProgram = h),
          (i.uniformsList = null),
          h
        );
      }
      function $t(t) {
        if (null === t.uniformsList) {
          const e = t.currentProgram.getUniforms();
          t.uniformsList = rs.seqWithValue(e.seq, t.uniforms);
        }
        return t.uniformsList;
      }
      function te(t, e) {
        const n = ct.get(t);
        (n.outputColorSpace = e.outputColorSpace),
          (n.batching = e.batching),
          (n.instancing = e.instancing),
          (n.instancingColor = e.instancingColor),
          (n.skinning = e.skinning),
          (n.morphTargets = e.morphTargets),
          (n.morphNormals = e.morphNormals),
          (n.morphColors = e.morphColors),
          (n.morphTargetsCount = e.morphTargetsCount),
          (n.numClippingPlanes = e.numClippingPlanes),
          (n.numIntersection = e.numClipIntersection),
          (n.vertexAlphas = e.vertexAlphas),
          (n.vertexTangents = e.vertexTangents),
          (n.toneMapping = e.toneMapping);
      }
      jt.setAnimationLoop(function (t) {
        Ht && Ht(t);
      }),
        "undefined" != typeof self && jt.setContext(self),
        (this.setAnimationLoop = function (t) {
          (Ht = t), Nt.setAnimationLoop(t), null === t ? jt.stop() : jt.start();
        }),
        Nt.addEventListener("sessionstart", Vt),
        Nt.addEventListener("sessionend", Xt),
        (this.render = function (t, e) {
          if (void 0 !== e && !0 !== e.isCamera)
            return void console.error(
              "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
            );
          if (!0 === T) return;
          !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
            null === e.parent &&
              !0 === e.matrixWorldAutoUpdate &&
              e.updateMatrixWorld(),
            !0 === Nt.enabled &&
              !0 === Nt.isPresenting &&
              (!0 === Nt.cameraAutoUpdate && Nt.updateCamera(e),
              (e = Nt.getCamera())),
            !0 === t.isScene && t.onBeforeRender(x, t, e, b),
            (_ = Tt.get(t, y.length)),
            _.init(),
            y.push(_),
            tt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            Z.setFromProjectionMatrix(tt),
            (Q = this.localClippingEnabled),
            (J = Mt.init(this.clippingPlanes, Q)),
            (g = yt.get(t, v.length)),
            g.init(),
            v.push(g),
            qt(t, e, 0, x.sortObjects),
            g.finish(),
            !0 === x.sortObjects && g.sort(V, W),
            this.info.render.frame++,
            !0 === J && Mt.beginShadows();
          const n = _.state.shadowsArray;
          if (
            (St.render(n, t, e),
            !0 === J && Mt.endShadows(),
            !0 === this.info.autoReset && this.info.reset(),
            bt.render(g, t),
            _.setupLights(x._useLegacyLights),
            e.isArrayCamera)
          ) {
            const n = e.cameras;
            for (let e = 0, i = n.length; e < i; e++) {
              const i = n[e];
              Kt(g, t, i, i.viewport);
            }
          } else Kt(g, t, e);
          null !== b &&
            (ht.updateMultisampleRenderTarget(b),
            ht.updateRenderTargetMipmap(b)),
            !0 === t.isScene && t.onAfterRender(x, t, e),
            Pt.resetDefaultState(),
            (E = -1),
            (w = null),
            y.pop(),
            (_ = y.length > 0 ? y[y.length - 1] : null),
            v.pop(),
            (g = v.length > 0 ? v[v.length - 1] : null);
        }),
        (this.getActiveCubeFace = function () {
          return M;
        }),
        (this.getActiveMipmapLevel = function () {
          return S;
        }),
        (this.getRenderTarget = function () {
          return b;
        }),
        (this.setRenderTargetTextures = function (t, e, n) {
          (ct.get(t.texture).__webglTexture = e),
            (ct.get(t.depthTexture).__webglTexture = n);
          const i = ct.get(t);
          (i.__hasExternalTextures = !0),
            i.__hasExternalTextures &&
              ((i.__autoAllocateDepthBuffer = void 0 === n),
              i.__autoAllocateDepthBuffer ||
                (!0 === st.has("WEBGL_multisampled_render_to_texture") &&
                  (console.warn(
                    "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                  ),
                  (i.__useRenderToTexture = !1))));
        }),
        (this.setRenderTargetFramebuffer = function (t, e) {
          const n = ct.get(t);
          (n.__webglFramebuffer = e),
            (n.__useDefaultFramebuffer = void 0 === e);
        }),
        (this.setRenderTarget = function (t, e = 0, n = 0) {
          (b = t), (M = e), (S = n);
          let i = !0,
            r = null,
            s = !1,
            a = !1;
          if (t) {
            const o = ct.get(t);
            void 0 !== o.__useDefaultFramebuffer
              ? (ot.bindFramebuffer(Dt.FRAMEBUFFER, null), (i = !1))
              : void 0 === o.__webglFramebuffer
              ? ht.setupRenderTarget(t)
              : o.__hasExternalTextures &&
                ht.rebindTextures(
                  t,
                  ct.get(t.texture).__webglTexture,
                  ct.get(t.depthTexture).__webglTexture
                );
            const l = t.texture;
            (l.isData3DTexture ||
              l.isDataArrayTexture ||
              l.isCompressedArrayTexture) &&
              (a = !0);
            const c = ct.get(t).__webglFramebuffer;
            t.isWebGLCubeRenderTarget
              ? ((r = Array.isArray(c[e]) ? c[e][n] : c[e]), (s = !0))
              : (r =
                  at.isWebGL2 &&
                  t.samples > 0 &&
                  !1 === ht.useMultisampledRTT(t)
                    ? ct.get(t).__webglMultisampledFramebuffer
                    : Array.isArray(c)
                    ? c[n]
                    : c),
              N.copy(t.viewport),
              O.copy(t.scissor),
              (F = t.scissorTest);
          } else
            N.copy(X).multiplyScalar(G).floor(),
              O.copy(j).multiplyScalar(G).floor(),
              (F = K);
          if (
            (ot.bindFramebuffer(Dt.FRAMEBUFFER, r) &&
              at.drawBuffers &&
              i &&
              ot.drawBuffers(t, r),
            ot.viewport(N),
            ot.scissor(O),
            ot.setScissorTest(F),
            s)
          ) {
            const i = ct.get(t.texture);
            Dt.framebufferTexture2D(
              Dt.FRAMEBUFFER,
              Dt.COLOR_ATTACHMENT0,
              Dt.TEXTURE_CUBE_MAP_POSITIVE_X + e,
              i.__webglTexture,
              n
            );
          } else if (a) {
            const i = ct.get(t.texture),
              r = e || 0;
            Dt.framebufferTextureLayer(
              Dt.FRAMEBUFFER,
              Dt.COLOR_ATTACHMENT0,
              i.__webglTexture,
              n || 0,
              r
            );
          }
          E = -1;
        }),
        (this.readRenderTargetPixels = function (t, e, n, i, r, s, a) {
          if (!t || !t.isWebGLRenderTarget)
            return void console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
            );
          let o = ct.get(t).__webglFramebuffer;
          if ((t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)) {
            ot.bindFramebuffer(Dt.FRAMEBUFFER, o);
            try {
              const a = t.texture,
                o = a.format,
                l = a.type;
              if (
                o !== U &&
                Ct.convert(o) !==
                  Dt.getParameter(Dt.IMPLEMENTATION_COLOR_READ_FORMAT)
              )
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                );
              const c =
                l === D &&
                (st.has("EXT_color_buffer_half_float") ||
                  (at.isWebGL2 && st.has("EXT_color_buffer_float")));
              if (
                !(
                  l === R ||
                  Ct.convert(l) ===
                    Dt.getParameter(Dt.IMPLEMENTATION_COLOR_READ_TYPE) ||
                  (l === L &&
                    (at.isWebGL2 ||
                      st.has("OES_texture_float") ||
                      st.has("WEBGL_color_buffer_float"))) ||
                  c
                )
              )
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                );
              e >= 0 &&
                e <= t.width - i &&
                n >= 0 &&
                n <= t.height - r &&
                Dt.readPixels(e, n, i, r, Ct.convert(o), Ct.convert(l), s);
            } finally {
              const t = null !== b ? ct.get(b).__webglFramebuffer : null;
              ot.bindFramebuffer(Dt.FRAMEBUFFER, t);
            }
          }
        }),
        (this.copyFramebufferToTexture = function (t, e, n = 0) {
          const i = Math.pow(2, -n),
            r = Math.floor(e.image.width * i),
            s = Math.floor(e.image.height * i);
          ht.setTexture2D(e, 0),
            Dt.copyTexSubImage2D(Dt.TEXTURE_2D, n, 0, 0, t.x, t.y, r, s),
            ot.unbindTexture();
        }),
        (this.copyTextureToTexture = function (t, e, n, i = 0) {
          const r = e.image.width,
            s = e.image.height,
            a = Ct.convert(n.format),
            o = Ct.convert(n.type);
          ht.setTexture2D(n, 0),
            Dt.pixelStorei(Dt.UNPACK_FLIP_Y_WEBGL, n.flipY),
            Dt.pixelStorei(
              Dt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
              n.premultiplyAlpha
            ),
            Dt.pixelStorei(Dt.UNPACK_ALIGNMENT, n.unpackAlignment),
            e.isDataTexture
              ? Dt.texSubImage2D(
                  Dt.TEXTURE_2D,
                  i,
                  t.x,
                  t.y,
                  r,
                  s,
                  a,
                  o,
                  e.image.data
                )
              : e.isCompressedTexture
              ? Dt.compressedTexSubImage2D(
                  Dt.TEXTURE_2D,
                  i,
                  t.x,
                  t.y,
                  e.mipmaps[0].width,
                  e.mipmaps[0].height,
                  a,
                  e.mipmaps[0].data
                )
              : Dt.texSubImage2D(Dt.TEXTURE_2D, i, t.x, t.y, a, o, e.image),
            0 === i && n.generateMipmaps && Dt.generateMipmap(Dt.TEXTURE_2D),
            ot.unbindTexture();
        }),
        (this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
          if (x.isWebGL1Renderer)
            return void console.warn(
              "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
            );
          const s = t.max.x - t.min.x + 1,
            a = t.max.y - t.min.y + 1,
            o = t.max.z - t.min.z + 1,
            l = Ct.convert(i.format),
            c = Ct.convert(i.type);
          let h;
          if (i.isData3DTexture) ht.setTexture3D(i, 0), (h = Dt.TEXTURE_3D);
          else {
            if (!i.isDataArrayTexture && !i.isCompressedArrayTexture)
              return void console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
              );
            ht.setTexture2DArray(i, 0), (h = Dt.TEXTURE_2D_ARRAY);
          }
          Dt.pixelStorei(Dt.UNPACK_FLIP_Y_WEBGL, i.flipY),
            Dt.pixelStorei(
              Dt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
              i.premultiplyAlpha
            ),
            Dt.pixelStorei(Dt.UNPACK_ALIGNMENT, i.unpackAlignment);
          const u = Dt.getParameter(Dt.UNPACK_ROW_LENGTH),
            d = Dt.getParameter(Dt.UNPACK_IMAGE_HEIGHT),
            p = Dt.getParameter(Dt.UNPACK_SKIP_PIXELS),
            f = Dt.getParameter(Dt.UNPACK_SKIP_ROWS),
            m = Dt.getParameter(Dt.UNPACK_SKIP_IMAGES),
            g = n.isCompressedTexture ? n.mipmaps[r] : n.image;
          Dt.pixelStorei(Dt.UNPACK_ROW_LENGTH, g.width),
            Dt.pixelStorei(Dt.UNPACK_IMAGE_HEIGHT, g.height),
            Dt.pixelStorei(Dt.UNPACK_SKIP_PIXELS, t.min.x),
            Dt.pixelStorei(Dt.UNPACK_SKIP_ROWS, t.min.y),
            Dt.pixelStorei(Dt.UNPACK_SKIP_IMAGES, t.min.z),
            n.isDataTexture || n.isData3DTexture
              ? Dt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g.data)
              : n.isCompressedArrayTexture
              ? (console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                ),
                Dt.compressedTexSubImage3D(
                  h,
                  r,
                  e.x,
                  e.y,
                  e.z,
                  s,
                  a,
                  o,
                  l,
                  g.data
                ))
              : Dt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g),
            Dt.pixelStorei(Dt.UNPACK_ROW_LENGTH, u),
            Dt.pixelStorei(Dt.UNPACK_IMAGE_HEIGHT, d),
            Dt.pixelStorei(Dt.UNPACK_SKIP_PIXELS, p),
            Dt.pixelStorei(Dt.UNPACK_SKIP_ROWS, f),
            Dt.pixelStorei(Dt.UNPACK_SKIP_IMAGES, m),
            0 === r && i.generateMipmaps && Dt.generateMipmap(h),
            ot.unbindTexture();
        }),
        (this.initTexture = function (t) {
          t.isCubeTexture
            ? ht.setTextureCube(t, 0)
            : t.isData3DTexture
            ? ht.setTexture3D(t, 0)
            : t.isDataArrayTexture || t.isCompressedArrayTexture
            ? ht.setTexture2DArray(t, 0)
            : ht.setTexture2D(t, 0),
            ot.unbindTexture();
        }),
        (this.resetState = function () {
          (M = 0), (S = 0), (b = null), ot.reset(), Pt.reset();
        }),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    get coordinateSystem() {
      return st;
    }
    get outputColorSpace() {
      return this._outputColorSpace;
    }
    set outputColorSpace(t) {
      this._outputColorSpace = t;
      const e = this.getContext();
      (e.drawingBufferColorSpace = t === K ? "display-p3" : "srgb"),
        (e.unpackColorSpace =
          Dt.workingColorSpace === Z ? "display-p3" : "srgb");
    }
    get outputEncoding() {
      return (
        console.warn(
          "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
        ),
        this.outputColorSpace === q ? X : 3e3
      );
    }
    set outputEncoding(t) {
      console.warn(
        "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
      ),
        (this.outputColorSpace = t === X ? q : Y);
    }
    get useLegacyLights() {
      return (
        console.warn(
          "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
        ),
        this._useLegacyLights
      );
    }
    set useLegacyLights(t) {
      console.warn(
        "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
      ),
        (this._useLegacyLights = t);
    }
  }
  (class extends Js {}).prototype.isWebGL1Renderer = !0;
  class Qs extends Ke {
    constructor() {
      super(),
        (this.isScene = !0),
        (this.type = "Scene"),
        (this.background = null),
        (this.environment = null),
        (this.fog = null),
        (this.backgroundBlurriness = 0),
        (this.backgroundIntensity = 1),
        (this.overrideMaterial = null),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        null !== t.background && (this.background = t.background.clone()),
        null !== t.environment && (this.environment = t.environment.clone()),
        null !== t.fog && (this.fog = t.fog.clone()),
        (this.backgroundBlurriness = t.backgroundBlurriness),
        (this.backgroundIntensity = t.backgroundIntensity),
        null !== t.overrideMaterial &&
          (this.overrideMaterial = t.overrideMaterial.clone()),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        this
      );
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        null !== this.fog && (e.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 &&
          (e.object.backgroundBlurriness = this.backgroundBlurriness),
        1 !== this.backgroundIntensity &&
          (e.object.backgroundIntensity = this.backgroundIntensity),
        e
      );
    }
  }
  class $s {
    constructor(t, e) {
      (this.isInterleavedBuffer = !0),
        (this.array = t),
        (this.stride = e),
        (this.count = void 0 !== t ? t.length / e : 0),
        (this.usage = nt),
        (this._updateRange = { offset: 0, count: -1 }),
        (this.updateRanges = []),
        (this.version = 0),
        (this.uuid = ut());
    }
    onUploadCallback() {}
    set needsUpdate(t) {
      !0 === t && this.version++;
    }
    get updateRange() {
      return (
        console.warn(
          "THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
        ),
        this._updateRange
      );
    }
    setUsage(t) {
      return (this.usage = t), this;
    }
    addUpdateRange(t, e) {
      this.updateRanges.push({ start: t, count: e });
    }
    clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
    copy(t) {
      return (
        (this.array = new t.array.constructor(t.array)),
        (this.count = t.count),
        (this.stride = t.stride),
        (this.usage = t.usage),
        this
      );
    }
    copyAt(t, e, n) {
      (t *= this.stride), (n *= e.stride);
      for (let i = 0, r = this.stride; i < r; i++)
        this.array[t + i] = e.array[n + i];
      return this;
    }
    set(t, e = 0) {
      return this.array.set(t, e), this;
    }
    clone(t) {
      void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
        void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ut()),
        void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
          (t.arrayBuffers[this.array.buffer._uuid] =
            this.array.slice(0).buffer);
      const e = new this.array.constructor(
          t.arrayBuffers[this.array.buffer._uuid]
        ),
        n = new this.constructor(e, this.stride);
      return n.setUsage(this.usage), n;
    }
    onUpload(t) {
      return (this.onUploadCallback = t), this;
    }
    toJSON(t) {
      return (
        void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
        void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ut()),
        void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
          (t.arrayBuffers[this.array.buffer._uuid] = Array.from(
            new Uint32Array(this.array.buffer)
          )),
        {
          uuid: this.uuid,
          buffer: this.array.buffer._uuid,
          type: this.array.constructor.name,
          stride: this.stride,
        }
      );
    }
  }
  const ta = new Yt();
  class ea {
    constructor(t, e, n, i = !1) {
      (this.isInterleavedBufferAttribute = !0),
        (this.name = ""),
        (this.data = t),
        (this.itemSize = e),
        (this.offset = n),
        (this.normalized = i);
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(t) {
      this.data.needsUpdate = t;
    }
    applyMatrix4(t) {
      for (let e = 0, n = this.data.count; e < n; e++)
        ta.fromBufferAttribute(this, e),
          ta.applyMatrix4(t),
          this.setXYZ(e, ta.x, ta.y, ta.z);
      return this;
    }
    applyNormalMatrix(t) {
      for (let e = 0, n = this.count; e < n; e++)
        ta.fromBufferAttribute(this, e),
          ta.applyNormalMatrix(t),
          this.setXYZ(e, ta.x, ta.y, ta.z);
      return this;
    }
    transformDirection(t) {
      for (let e = 0, n = this.count; e < n; e++)
        ta.fromBufferAttribute(this, e),
          ta.transformDirection(t),
          this.setXYZ(e, ta.x, ta.y, ta.z);
      return this;
    }
    setX(t, e) {
      return (
        this.normalized && (e = vt(e, this.array)),
        (this.data.array[t * this.data.stride + this.offset] = e),
        this
      );
    }
    setY(t, e) {
      return (
        this.normalized && (e = vt(e, this.array)),
        (this.data.array[t * this.data.stride + this.offset + 1] = e),
        this
      );
    }
    setZ(t, e) {
      return (
        this.normalized && (e = vt(e, this.array)),
        (this.data.array[t * this.data.stride + this.offset + 2] = e),
        this
      );
    }
    setW(t, e) {
      return (
        this.normalized && (e = vt(e, this.array)),
        (this.data.array[t * this.data.stride + this.offset + 3] = e),
        this
      );
    }
    getX(t) {
      let e = this.data.array[t * this.data.stride + this.offset];
      return this.normalized && (e = _t(e, this.array)), e;
    }
    getY(t) {
      let e = this.data.array[t * this.data.stride + this.offset + 1];
      return this.normalized && (e = _t(e, this.array)), e;
    }
    getZ(t) {
      let e = this.data.array[t * this.data.stride + this.offset + 2];
      return this.normalized && (e = _t(e, this.array)), e;
    }
    getW(t) {
      let e = this.data.array[t * this.data.stride + this.offset + 3];
      return this.normalized && (e = _t(e, this.array)), e;
    }
    setXY(t, e, n) {
      return (
        (t = t * this.data.stride + this.offset),
        this.normalized && ((e = vt(e, this.array)), (n = vt(n, this.array))),
        (this.data.array[t + 0] = e),
        (this.data.array[t + 1] = n),
        this
      );
    }
    setXYZ(t, e, n, i) {
      return (
        (t = t * this.data.stride + this.offset),
        this.normalized &&
          ((e = vt(e, this.array)),
          (n = vt(n, this.array)),
          (i = vt(i, this.array))),
        (this.data.array[t + 0] = e),
        (this.data.array[t + 1] = n),
        (this.data.array[t + 2] = i),
        this
      );
    }
    setXYZW(t, e, n, i, r) {
      return (
        (t = t * this.data.stride + this.offset),
        this.normalized &&
          ((e = vt(e, this.array)),
          (n = vt(n, this.array)),
          (i = vt(i, this.array)),
          (r = vt(r, this.array))),
        (this.data.array[t + 0] = e),
        (this.data.array[t + 1] = n),
        (this.data.array[t + 2] = i),
        (this.data.array[t + 3] = r),
        this
      );
    }
    clone(t) {
      if (void 0 === t) {
        console.log(
          "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
        );
        const t = [];
        for (let e = 0; e < this.count; e++) {
          const n = e * this.data.stride + this.offset;
          for (let e = 0; e < this.itemSize; e++)
            t.push(this.data.array[n + e]);
        }
        return new xn(
          new this.array.constructor(t),
          this.itemSize,
          this.normalized
        );
      }
      return (
        void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
        void 0 === t.interleavedBuffers[this.data.uuid] &&
          (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
        new ea(
          t.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
    }
    toJSON(t) {
      if (void 0 === t) {
        console.log(
          "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
        );
        const t = [];
        for (let e = 0; e < this.count; e++) {
          const n = e * this.data.stride + this.offset;
          for (let e = 0; e < this.itemSize; e++)
            t.push(this.data.array[n + e]);
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: t,
          normalized: this.normalized,
        };
      }
      return (
        void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
        void 0 === t.interleavedBuffers[this.data.uuid] &&
          (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
    }
  }
  const na = new Yt(),
    ia = new Gt(),
    ra = new Gt(),
    sa = new Yt(),
    aa = new be(),
    oa = new Yt(),
    la = new me(),
    ca = new be(),
    ha = new Se();
  class ua extends Kn {
    constructor(t, e) {
      super(t, e),
        (this.isSkinnedMesh = !0),
        (this.type = "SkinnedMesh"),
        (this.bindMode = g),
        (this.bindMatrix = new be()),
        (this.bindMatrixInverse = new be()),
        (this.boundingBox = null),
        (this.boundingSphere = null);
    }
    computeBoundingBox() {
      const t = this.geometry;
      null === this.boundingBox && (this.boundingBox = new Jt()),
        this.boundingBox.makeEmpty();
      const e = t.getAttribute("position");
      for (let t = 0; t < e.count; t++)
        this.getVertexPosition(t, oa), this.boundingBox.expandByPoint(oa);
    }
    computeBoundingSphere() {
      const t = this.geometry;
      null === this.boundingSphere && (this.boundingSphere = new me()),
        this.boundingSphere.makeEmpty();
      const e = t.getAttribute("position");
      for (let t = 0; t < e.count; t++)
        this.getVertexPosition(t, oa), this.boundingSphere.expandByPoint(oa);
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.bindMode = t.bindMode),
        this.bindMatrix.copy(t.bindMatrix),
        this.bindMatrixInverse.copy(t.bindMatrixInverse),
        (this.skeleton = t.skeleton),
        null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
        null !== t.boundingSphere &&
          (this.boundingSphere = t.boundingSphere.clone()),
        this
      );
    }
    raycast(t, e) {
      const n = this.material,
        i = this.matrixWorld;
      void 0 !== n &&
        (null === this.boundingSphere && this.computeBoundingSphere(),
        la.copy(this.boundingSphere),
        la.applyMatrix4(i),
        !1 !== t.ray.intersectsSphere(la) &&
          (ca.copy(i).invert(),
          ha.copy(t.ray).applyMatrix4(ca),
          (null !== this.boundingBox &&
            !1 === ha.intersectsBox(this.boundingBox)) ||
            this._computeIntersections(t, e, ha)));
    }
    getVertexPosition(t, e) {
      return super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e;
    }
    bind(t, e) {
      (this.skeleton = t),
        void 0 === e &&
          (this.updateMatrixWorld(!0),
          this.skeleton.calculateInverses(),
          (e = this.matrixWorld)),
        this.bindMatrix.copy(e),
        this.bindMatrixInverse.copy(e).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      const t = new Gt(),
        e = this.geometry.attributes.skinWeight;
      for (let n = 0, i = e.count; n < i; n++) {
        t.fromBufferAttribute(e, n);
        const i = 1 / t.manhattanLength();
        i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
          e.setXYZW(n, t.x, t.y, t.z, t.w);
      }
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t),
        this.bindMode === g
          ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
          : "detached" === this.bindMode
          ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
          : console.warn(
              "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
            );
    }
    applyBoneTransform(t, e) {
      const n = this.skeleton,
        i = this.geometry;
      ia.fromBufferAttribute(i.attributes.skinIndex, t),
        ra.fromBufferAttribute(i.attributes.skinWeight, t),
        na.copy(e).applyMatrix4(this.bindMatrix),
        e.set(0, 0, 0);
      for (let t = 0; t < 4; t++) {
        const i = ra.getComponent(t);
        if (0 !== i) {
          const r = ia.getComponent(t);
          aa.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
            e.addScaledVector(sa.copy(na).applyMatrix4(aa), i);
        }
      }
      return e.applyMatrix4(this.bindMatrixInverse);
    }
    boneTransform(t, e) {
      return (
        console.warn(
          "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
        ),
        this.applyBoneTransform(t, e)
      );
    }
  }
  class da extends Ke {
    constructor() {
      super(), (this.isBone = !0), (this.type = "Bone");
    }
  }
  class pa extends Ht {
    constructor(
      t = null,
      e = 1,
      n = 1,
      i,
      r,
      s,
      a,
      o,
      l = 1003,
      c = 1003,
      h,
      u
    ) {
      super(null, s, a, o, l, c, i, r, h, u),
        (this.isDataTexture = !0),
        (this.image = { data: t, width: e, height: n }),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  }
  const fa = new be(),
    ma = new be();
  class ga {
    constructor(t = [], e = []) {
      (this.uuid = ut()),
        (this.bones = t.slice(0)),
        (this.boneInverses = e),
        (this.boneMatrices = null),
        (this.boneTexture = null),
        this.init();
    }
    init() {
      const t = this.bones,
        e = this.boneInverses;
      if (
        ((this.boneMatrices = new Float32Array(16 * t.length)), 0 === e.length)
      )
        this.calculateInverses();
      else if (t.length !== e.length) {
        console.warn(
          "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
        ),
          (this.boneInverses = []);
        for (let t = 0, e = this.bones.length; t < e; t++)
          this.boneInverses.push(new be());
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let t = 0, e = this.bones.length; t < e; t++) {
        const e = new be();
        this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
          this.boneInverses.push(e);
      }
    }
    pose() {
      for (let t = 0, e = this.bones.length; t < e; t++) {
        const e = this.bones[t];
        e && e.matrixWorld.copy(this.boneInverses[t]).invert();
      }
      for (let t = 0, e = this.bones.length; t < e; t++) {
        const e = this.bones[t];
        e &&
          (e.parent && e.parent.isBone
            ? (e.matrix.copy(e.parent.matrixWorld).invert(),
              e.matrix.multiply(e.matrixWorld))
            : e.matrix.copy(e.matrixWorld),
          e.matrix.decompose(e.position, e.quaternion, e.scale));
      }
    }
    update() {
      const t = this.bones,
        e = this.boneInverses,
        n = this.boneMatrices,
        i = this.boneTexture;
      for (let i = 0, r = t.length; i < r; i++) {
        const r = t[i] ? t[i].matrixWorld : ma;
        fa.multiplyMatrices(r, e[i]), fa.toArray(n, 16 * i);
      }
      null !== i && (i.needsUpdate = !0);
    }
    clone() {
      return new ga(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
      let t = Math.sqrt(4 * this.bones.length);
      (t = 4 * Math.ceil(t / 4)), (t = Math.max(t, 4));
      const e = new Float32Array(t * t * 4);
      e.set(this.boneMatrices);
      const n = new pa(e, t, t, U, L);
      return (
        (n.needsUpdate = !0),
        (this.boneMatrices = e),
        (this.boneTexture = n),
        this
      );
    }
    getBoneByName(t) {
      for (let e = 0, n = this.bones.length; e < n; e++) {
        const n = this.bones[e];
        if (n.name === t) return n;
      }
    }
    dispose() {
      null !== this.boneTexture &&
        (this.boneTexture.dispose(), (this.boneTexture = null));
    }
    fromJSON(t, e) {
      this.uuid = t.uuid;
      for (let n = 0, i = t.bones.length; n < i; n++) {
        const i = t.bones[n];
        let r = e[i];
        void 0 === r &&
          (console.warn("THREE.Skeleton: No bone found with UUID:", i),
          (r = new da())),
          this.bones.push(r),
          this.boneInverses.push(new be().fromArray(t.boneInverses[n]));
      }
      return this.init(), this;
    }
    toJSON() {
      const t = {
        metadata: {
          version: 4.6,
          type: "Skeleton",
          generator: "Skeleton.toJSON",
        },
        bones: [],
        boneInverses: [],
      };
      t.uuid = this.uuid;
      const e = this.bones,
        n = this.boneInverses;
      for (let i = 0, r = e.length; i < r; i++) {
        const r = e[i];
        t.bones.push(r.uuid);
        const s = n[i];
        t.boneInverses.push(s.toArray());
      }
      return t;
    }
  }
  class _a extends xn {
    constructor(t, e, n, i = 1) {
      super(t, e, n),
        (this.isInstancedBufferAttribute = !0),
        (this.meshPerAttribute = i);
    }
    copy(t) {
      return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this;
    }
    toJSON() {
      const t = super.toJSON();
      return (
        (t.meshPerAttribute = this.meshPerAttribute),
        (t.isInstancedBufferAttribute = !0),
        t
      );
    }
  }
  const va = new be(),
    ya = new be(),
    xa = [],
    Ta = new Jt(),
    Ma = new be(),
    Sa = new Kn(),
    ba = new me();
  class Ea extends Kn {
    constructor(t, e, n) {
      super(t, e),
        (this.isInstancedMesh = !0),
        (this.instanceMatrix = new _a(new Float32Array(16 * n), 16)),
        (this.instanceColor = null),
        (this.count = n),
        (this.boundingBox = null),
        (this.boundingSphere = null);
      for (let t = 0; t < n; t++) this.setMatrixAt(t, Ma);
    }
    computeBoundingBox() {
      const t = this.geometry,
        e = this.count;
      null === this.boundingBox && (this.boundingBox = new Jt()),
        null === t.boundingBox && t.computeBoundingBox(),
        this.boundingBox.makeEmpty();
      for (let n = 0; n < e; n++)
        this.getMatrixAt(n, va),
          Ta.copy(t.boundingBox).applyMatrix4(va),
          this.boundingBox.union(Ta);
    }
    computeBoundingSphere() {
      const t = this.geometry,
        e = this.count;
      null === this.boundingSphere && (this.boundingSphere = new me()),
        null === t.boundingSphere && t.computeBoundingSphere(),
        this.boundingSphere.makeEmpty();
      for (let n = 0; n < e; n++)
        this.getMatrixAt(n, va),
          ba.copy(t.boundingSphere).applyMatrix4(va),
          this.boundingSphere.union(ba);
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        this.instanceMatrix.copy(t.instanceMatrix),
        null !== t.instanceColor &&
          (this.instanceColor = t.instanceColor.clone()),
        (this.count = t.count),
        null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
        null !== t.boundingSphere &&
          (this.boundingSphere = t.boundingSphere.clone()),
        this
      );
    }
    getColorAt(t, e) {
      e.fromArray(this.instanceColor.array, 3 * t);
    }
    getMatrixAt(t, e) {
      e.fromArray(this.instanceMatrix.array, 16 * t);
    }
    raycast(t, e) {
      const n = this.matrixWorld,
        i = this.count;
      if (
        ((Sa.geometry = this.geometry),
        (Sa.material = this.material),
        void 0 !== Sa.material &&
          (null === this.boundingSphere && this.computeBoundingSphere(),
          ba.copy(this.boundingSphere),
          ba.applyMatrix4(n),
          !1 !== t.ray.intersectsSphere(ba)))
      )
        for (let r = 0; r < i; r++) {
          this.getMatrixAt(r, va),
            ya.multiplyMatrices(n, va),
            (Sa.matrixWorld = ya),
            Sa.raycast(t, xa);
          for (let t = 0, n = xa.length; t < n; t++) {
            const n = xa[t];
            (n.instanceId = r), (n.object = this), e.push(n);
          }
          xa.length = 0;
        }
    }
    setColorAt(t, e) {
      null === this.instanceColor &&
        (this.instanceColor = new _a(
          new Float32Array(3 * this.instanceMatrix.count),
          3
        )),
        e.toArray(this.instanceColor.array, 3 * t);
    }
    setMatrixAt(t, e) {
      e.toArray(this.instanceMatrix.array, 16 * t);
    }
    updateMorphTargets() {}
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  class wa extends gn {
    constructor(t) {
      super(),
        (this.isLineBasicMaterial = !0),
        (this.type = "LineBasicMaterial"),
        (this.color = new pn(16777215)),
        (this.map = null),
        (this.linewidth = 1),
        (this.linecap = "round"),
        (this.linejoin = "round"),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.linewidth = t.linewidth),
        (this.linecap = t.linecap),
        (this.linejoin = t.linejoin),
        (this.fog = t.fog),
        this
      );
    }
  }
  const Aa = new Yt(),
    Ra = new Yt(),
    Ca = new be(),
    Pa = new Se(),
    La = new me();
  class Da extends Ke {
    constructor(t = new Ln(), e = new wa()) {
      super(),
        (this.isLine = !0),
        (this.type = "Line"),
        (this.geometry = t),
        (this.material = e),
        this.updateMorphTargets();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.material = Array.isArray(t.material)
          ? t.material.slice()
          : t.material),
        (this.geometry = t.geometry),
        this
      );
    }
    computeLineDistances() {
      const t = this.geometry;
      if (null === t.index) {
        const e = t.attributes.position,
          n = [0];
        for (let t = 1, i = e.count; t < i; t++)
          Aa.fromBufferAttribute(e, t - 1),
            Ra.fromBufferAttribute(e, t),
            (n[t] = n[t - 1]),
            (n[t] += Aa.distanceTo(Ra));
        t.setAttribute("lineDistance", new Sn(n, 1));
      } else
        console.warn(
          "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
        );
      return this;
    }
    raycast(t, e) {
      const n = this.geometry,
        i = this.matrixWorld,
        r = t.params.Line.threshold,
        s = n.drawRange;
      if (
        (null === n.boundingSphere && n.computeBoundingSphere(),
        La.copy(n.boundingSphere),
        La.applyMatrix4(i),
        (La.radius += r),
        !1 === t.ray.intersectsSphere(La))
      )
        return;
      Ca.copy(i).invert(), Pa.copy(t.ray).applyMatrix4(Ca);
      const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
        o = a * a,
        l = new Yt(),
        c = new Yt(),
        h = new Yt(),
        u = new Yt(),
        d = this.isLineSegments ? 2 : 1,
        p = n.index,
        f = n.attributes.position;
      if (null !== p)
        for (
          let n = Math.max(0, s.start),
            i = Math.min(p.count, s.start + s.count) - 1;
          n < i;
          n += d
        ) {
          const i = p.getX(n),
            r = p.getX(n + 1);
          if (
            (l.fromBufferAttribute(f, i),
            c.fromBufferAttribute(f, r),
            Pa.distanceSqToSegment(l, c, u, h) > o)
          )
            continue;
          u.applyMatrix4(this.matrixWorld);
          const s = t.ray.origin.distanceTo(u);
          s < t.near ||
            s > t.far ||
            e.push({
              distance: s,
              point: h.clone().applyMatrix4(this.matrixWorld),
              index: n,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      else
        for (
          let n = Math.max(0, s.start),
            i = Math.min(f.count, s.start + s.count) - 1;
          n < i;
          n += d
        ) {
          if (
            (l.fromBufferAttribute(f, n),
            c.fromBufferAttribute(f, n + 1),
            Pa.distanceSqToSegment(l, c, u, h) > o)
          )
            continue;
          u.applyMatrix4(this.matrixWorld);
          const i = t.ray.origin.distanceTo(u);
          i < t.near ||
            i > t.far ||
            e.push({
              distance: i,
              point: h.clone().applyMatrix4(this.matrixWorld),
              index: n,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes,
        e = Object.keys(t);
      if (e.length > 0) {
        const n = t[e[0]];
        if (void 0 !== n) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let t = 0, e = n.length; t < e; t++) {
            const e = n[t].name || String(t);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[e] = t);
          }
        }
      }
    }
  }
  const Ia = new Yt(),
    Ua = new Yt();
  class Na extends Da {
    constructor(t, e) {
      super(t, e), (this.isLineSegments = !0), (this.type = "LineSegments");
    }
    computeLineDistances() {
      const t = this.geometry;
      if (null === t.index) {
        const e = t.attributes.position,
          n = [];
        for (let t = 0, i = e.count; t < i; t += 2)
          Ia.fromBufferAttribute(e, t),
            Ua.fromBufferAttribute(e, t + 1),
            (n[t] = 0 === t ? 0 : n[t - 1]),
            (n[t + 1] = n[t] + Ia.distanceTo(Ua));
        t.setAttribute("lineDistance", new Sn(n, 1));
      } else
        console.warn(
          "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
        );
      return this;
    }
  }
  class Oa extends Da {
    constructor(t, e) {
      super(t, e), (this.isLineLoop = !0), (this.type = "LineLoop");
    }
  }
  class Fa extends gn {
    constructor(t) {
      super(),
        (this.isPointsMaterial = !0),
        (this.type = "PointsMaterial"),
        (this.color = new pn(16777215)),
        (this.map = null),
        (this.alphaMap = null),
        (this.size = 1),
        (this.sizeAttenuation = !0),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.size = t.size),
        (this.sizeAttenuation = t.sizeAttenuation),
        (this.fog = t.fog),
        this
      );
    }
  }
  const ka = new be(),
    za = new Se(),
    Ba = new me(),
    Ha = new Yt();
  class Ga extends Ke {
    constructor(t = new Ln(), e = new Fa()) {
      super(),
        (this.isPoints = !0),
        (this.type = "Points"),
        (this.geometry = t),
        (this.material = e),
        this.updateMorphTargets();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.material = Array.isArray(t.material)
          ? t.material.slice()
          : t.material),
        (this.geometry = t.geometry),
        this
      );
    }
    raycast(t, e) {
      const n = this.geometry,
        i = this.matrixWorld,
        r = t.params.Points.threshold,
        s = n.drawRange;
      if (
        (null === n.boundingSphere && n.computeBoundingSphere(),
        Ba.copy(n.boundingSphere),
        Ba.applyMatrix4(i),
        (Ba.radius += r),
        !1 === t.ray.intersectsSphere(Ba))
      )
        return;
      ka.copy(i).invert(), za.copy(t.ray).applyMatrix4(ka);
      const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
        o = a * a,
        l = n.index,
        c = n.attributes.position;
      if (null !== l)
        for (
          let n = Math.max(0, s.start),
            r = Math.min(l.count, s.start + s.count);
          n < r;
          n++
        ) {
          const r = l.getX(n);
          Ha.fromBufferAttribute(c, r), Va(Ha, r, o, i, t, e, this);
        }
      else
        for (
          let n = Math.max(0, s.start),
            r = Math.min(c.count, s.start + s.count);
          n < r;
          n++
        )
          Ha.fromBufferAttribute(c, n), Va(Ha, n, o, i, t, e, this);
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes,
        e = Object.keys(t);
      if (e.length > 0) {
        const n = t[e[0]];
        if (void 0 !== n) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let t = 0, e = n.length; t < e; t++) {
            const e = n[t].name || String(t);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[e] = t);
          }
        }
      }
    }
  }
  function Va(t, e, n, i, r, s, a) {
    const o = za.distanceSqToPoint(t);
    if (o < n) {
      const n = new Yt();
      za.closestPointToPoint(t, n), n.applyMatrix4(i);
      const l = r.ray.origin.distanceTo(n);
      if (l < r.near || l > r.far) return;
      s.push({
        distance: l,
        distanceToRay: Math.sqrt(o),
        point: n,
        index: e,
        face: null,
        object: a,
      });
    }
  }
  class Wa extends Ln {
    constructor(
      t = 1,
      e = 1,
      n = 1,
      i = 32,
      r = 1,
      s = !1,
      a = 0,
      o = 2 * Math.PI
    ) {
      super(),
        (this.type = "CylinderGeometry"),
        (this.parameters = {
          radiusTop: t,
          radiusBottom: e,
          height: n,
          radialSegments: i,
          heightSegments: r,
          openEnded: s,
          thetaStart: a,
          thetaLength: o,
        });
      const l = this;
      (i = Math.floor(i)), (r = Math.floor(r));
      const c = [],
        h = [],
        u = [],
        d = [];
      let p = 0;
      const f = [],
        m = n / 2;
      let g = 0;
      function _(n) {
        const r = p,
          s = new xt(),
          f = new Yt();
        let _ = 0;
        const v = !0 === n ? t : e,
          y = !0 === n ? 1 : -1;
        for (let t = 1; t <= i; t++)
          h.push(0, m * y, 0), u.push(0, y, 0), d.push(0.5, 0.5), p++;
        const x = p;
        for (let t = 0; t <= i; t++) {
          const e = (t / i) * o + a,
            n = Math.cos(e),
            r = Math.sin(e);
          (f.x = v * r),
            (f.y = m * y),
            (f.z = v * n),
            h.push(f.x, f.y, f.z),
            u.push(0, y, 0),
            (s.x = 0.5 * n + 0.5),
            (s.y = 0.5 * r * y + 0.5),
            d.push(s.x, s.y),
            p++;
        }
        for (let t = 0; t < i; t++) {
          const e = r + t,
            i = x + t;
          !0 === n ? c.push(i, i + 1, e) : c.push(i + 1, i, e), (_ += 3);
        }
        l.addGroup(g, _, !0 === n ? 1 : 2), (g += _);
      }
      !(function () {
        const s = new Yt(),
          _ = new Yt();
        let v = 0;
        const y = (e - t) / n;
        for (let l = 0; l <= r; l++) {
          const c = [],
            g = l / r,
            v = g * (e - t) + t;
          for (let t = 0; t <= i; t++) {
            const e = t / i,
              r = e * o + a,
              l = Math.sin(r),
              f = Math.cos(r);
            (_.x = v * l),
              (_.y = -g * n + m),
              (_.z = v * f),
              h.push(_.x, _.y, _.z),
              s.set(l, y, f).normalize(),
              u.push(s.x, s.y, s.z),
              d.push(e, 1 - g),
              c.push(p++);
          }
          f.push(c);
        }
        for (let t = 0; t < i; t++)
          for (let e = 0; e < r; e++) {
            const n = f[e][t],
              i = f[e + 1][t],
              r = f[e + 1][t + 1],
              s = f[e][t + 1];
            c.push(n, i, s), c.push(i, r, s), (v += 6);
          }
        l.addGroup(g, v, 0), (g += v);
      })(),
        !1 === s && (t > 0 && _(!0), e > 0 && _(!1)),
        this.setIndex(c),
        this.setAttribute("position", new Sn(h, 3)),
        this.setAttribute("normal", new Sn(u, 3)),
        this.setAttribute("uv", new Sn(d, 2));
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
    static fromJSON(t) {
      return new Wa(
        t.radiusTop,
        t.radiusBottom,
        t.height,
        t.radialSegments,
        t.heightSegments,
        t.openEnded,
        t.thetaStart,
        t.thetaLength
      );
    }
  }
  class Xa extends gn {
    constructor(t) {
      super(),
        (this.isMeshStandardMaterial = !0),
        (this.defines = { STANDARD: "" }),
        (this.type = "MeshStandardMaterial"),
        (this.color = new pn(16777215)),
        (this.roughness = 1),
        (this.metalness = 0),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new pn(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new xt(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.roughnessMap = null),
        (this.metalnessMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.envMapIntensity = 1),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.flatShading = !1),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.defines = { STANDARD: "" }),
        this.color.copy(t.color),
        (this.roughness = t.roughness),
        (this.metalness = t.metalness),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.roughnessMap = t.roughnessMap),
        (this.metalnessMap = t.metalnessMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.envMapIntensity = t.envMapIntensity),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.flatShading = t.flatShading),
        (this.fog = t.fog),
        this
      );
    }
  }
  class ja extends Xa {
    constructor(t) {
      super(),
        (this.isMeshPhysicalMaterial = !0),
        (this.defines = { STANDARD: "", PHYSICAL: "" }),
        (this.type = "MeshPhysicalMaterial"),
        (this.anisotropyRotation = 0),
        (this.anisotropyMap = null),
        (this.clearcoatMap = null),
        (this.clearcoatRoughness = 0),
        (this.clearcoatRoughnessMap = null),
        (this.clearcoatNormalScale = new xt(1, 1)),
        (this.clearcoatNormalMap = null),
        (this.ior = 1.5),
        Object.defineProperty(this, "reflectivity", {
          get: function () {
            return dt((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
          },
          set: function (t) {
            this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
          },
        }),
        (this.iridescenceMap = null),
        (this.iridescenceIOR = 1.3),
        (this.iridescenceThicknessRange = [100, 400]),
        (this.iridescenceThicknessMap = null),
        (this.sheenColor = new pn(0)),
        (this.sheenColorMap = null),
        (this.sheenRoughness = 1),
        (this.sheenRoughnessMap = null),
        (this.transmissionMap = null),
        (this.thickness = 0),
        (this.thicknessMap = null),
        (this.attenuationDistance = 1 / 0),
        (this.attenuationColor = new pn(1, 1, 1)),
        (this.specularIntensity = 1),
        (this.specularIntensityMap = null),
        (this.specularColor = new pn(1, 1, 1)),
        (this.specularColorMap = null),
        (this._anisotropy = 0),
        (this._clearcoat = 0),
        (this._iridescence = 0),
        (this._sheen = 0),
        (this._transmission = 0),
        this.setValues(t);
    }
    get anisotropy() {
      return this._anisotropy;
    }
    set anisotropy(t) {
      this._anisotropy > 0 != t > 0 && this.version++, (this._anisotropy = t);
    }
    get clearcoat() {
      return this._clearcoat;
    }
    set clearcoat(t) {
      this._clearcoat > 0 != t > 0 && this.version++, (this._clearcoat = t);
    }
    get iridescence() {
      return this._iridescence;
    }
    set iridescence(t) {
      this._iridescence > 0 != t > 0 && this.version++, (this._iridescence = t);
    }
    get sheen() {
      return this._sheen;
    }
    set sheen(t) {
      this._sheen > 0 != t > 0 && this.version++, (this._sheen = t);
    }
    get transmission() {
      return this._transmission;
    }
    set transmission(t) {
      this._transmission > 0 != t > 0 && this.version++,
        (this._transmission = t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.defines = { STANDARD: "", PHYSICAL: "" }),
        (this.anisotropy = t.anisotropy),
        (this.anisotropyRotation = t.anisotropyRotation),
        (this.anisotropyMap = t.anisotropyMap),
        (this.clearcoat = t.clearcoat),
        (this.clearcoatMap = t.clearcoatMap),
        (this.clearcoatRoughness = t.clearcoatRoughness),
        (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
        (this.clearcoatNormalMap = t.clearcoatNormalMap),
        this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
        (this.ior = t.ior),
        (this.iridescence = t.iridescence),
        (this.iridescenceMap = t.iridescenceMap),
        (this.iridescenceIOR = t.iridescenceIOR),
        (this.iridescenceThicknessRange = [...t.iridescenceThicknessRange]),
        (this.iridescenceThicknessMap = t.iridescenceThicknessMap),
        (this.sheen = t.sheen),
        this.sheenColor.copy(t.sheenColor),
        (this.sheenColorMap = t.sheenColorMap),
        (this.sheenRoughness = t.sheenRoughness),
        (this.sheenRoughnessMap = t.sheenRoughnessMap),
        (this.transmission = t.transmission),
        (this.transmissionMap = t.transmissionMap),
        (this.thickness = t.thickness),
        (this.thicknessMap = t.thicknessMap),
        (this.attenuationDistance = t.attenuationDistance),
        this.attenuationColor.copy(t.attenuationColor),
        (this.specularIntensity = t.specularIntensity),
        (this.specularIntensityMap = t.specularIntensityMap),
        this.specularColor.copy(t.specularColor),
        (this.specularColorMap = t.specularColorMap),
        this
      );
    }
  }
  function qa(t, e, n) {
    return !t || (!n && t.constructor === e)
      ? t
      : "number" == typeof e.BYTES_PER_ELEMENT
      ? new e(t)
      : Array.prototype.slice.call(t);
  }
  function Ya(t) {
    const e = t.length,
      n = new Array(e);
    for (let t = 0; t !== e; ++t) n[t] = t;
    return (
      n.sort(function (e, n) {
        return t[e] - t[n];
      }),
      n
    );
  }
  function Ka(t, e, n) {
    const i = t.length,
      r = new t.constructor(i);
    for (let s = 0, a = 0; a !== i; ++s) {
      const i = n[s] * e;
      for (let n = 0; n !== e; ++n) r[a++] = t[i + n];
    }
    return r;
  }
  function Za(t, e, n, i) {
    let r = 1,
      s = t[0];
    for (; void 0 !== s && void 0 === s[i]; ) s = t[r++];
    if (void 0 === s) return;
    let a = s[i];
    if (void 0 !== a)
      if (Array.isArray(a))
        do {
          (a = s[i]),
            void 0 !== a && (e.push(s.time), n.push.apply(n, a)),
            (s = t[r++]);
        } while (void 0 !== s);
      else if (void 0 !== a.toArray)
        do {
          (a = s[i]),
            void 0 !== a && (e.push(s.time), a.toArray(n, n.length)),
            (s = t[r++]);
        } while (void 0 !== s);
      else
        do {
          (a = s[i]), void 0 !== a && (e.push(s.time), n.push(a)), (s = t[r++]);
        } while (void 0 !== s);
  }
  class Ja {
    constructor(t, e, n, i) {
      (this.parameterPositions = t),
        (this._cachedIndex = 0),
        (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
        (this.sampleValues = e),
        (this.valueSize = n),
        (this.settings = null),
        (this.DefaultSettings_ = {});
    }
    evaluate(t) {
      const e = this.parameterPositions;
      let n = this._cachedIndex,
        i = e[n],
        r = e[n - 1];
      t: {
        e: {
          let s;
          n: {
            i: if (!(t < i)) {
              for (let s = n + 2; ; ) {
                if (void 0 === i) {
                  if (t < r) break i;
                  return (
                    (n = e.length),
                    (this._cachedIndex = n),
                    this.copySampleValue_(n - 1)
                  );
                }
                if (n === s) break;
                if (((r = i), (i = e[++n]), t < i)) break e;
              }
              s = e.length;
              break n;
            }
            if (t >= r) break t;
            {
              const a = e[1];
              t < a && ((n = 2), (r = a));
              for (let s = n - 2; ; ) {
                if (void 0 === r)
                  return (this._cachedIndex = 0), this.copySampleValue_(0);
                if (n === s) break;
                if (((i = r), (r = e[--n - 1]), t >= r)) break e;
              }
              (s = n), (n = 0);
            }
          }
          for (; n < s; ) {
            const i = (n + s) >>> 1;
            t < e[i] ? (s = i) : (n = i + 1);
          }
          if (((i = e[n]), (r = e[n - 1]), void 0 === r))
            return (this._cachedIndex = 0), this.copySampleValue_(0);
          if (void 0 === i)
            return (
              (n = e.length),
              (this._cachedIndex = n),
              this.copySampleValue_(n - 1)
            );
        }
        (this._cachedIndex = n), this.intervalChanged_(n, r, i);
      }
      return this.interpolate_(n, r, t, i);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(t) {
      const e = this.resultBuffer,
        n = this.sampleValues,
        i = this.valueSize,
        r = t * i;
      for (let t = 0; t !== i; ++t) e[t] = n[r + t];
      return e;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {}
  }
  class Qa extends Ja {
    constructor(t, e, n, i) {
      super(t, e, n, i),
        (this._weightPrev = -0),
        (this._offsetPrev = -0),
        (this._weightNext = -0),
        (this._offsetNext = -0),
        (this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 });
    }
    intervalChanged_(t, e, n) {
      const i = this.parameterPositions;
      let r = t - 2,
        s = t + 1,
        a = i[r],
        o = i[s];
      if (void 0 === a)
        switch (this.getSettings_().endingStart) {
          case 2401:
            (r = t), (a = 2 * e - n);
            break;
          case 2402:
            (r = i.length - 2), (a = e + i[r] - i[r + 1]);
            break;
          default:
            (r = t), (a = n);
        }
      if (void 0 === o)
        switch (this.getSettings_().endingEnd) {
          case 2401:
            (s = t), (o = 2 * n - e);
            break;
          case 2402:
            (s = 1), (o = n + i[1] - i[0]);
            break;
          default:
            (s = t - 1), (o = e);
        }
      const l = 0.5 * (n - e),
        c = this.valueSize;
      (this._weightPrev = l / (e - a)),
        (this._weightNext = l / (o - n)),
        (this._offsetPrev = r * c),
        (this._offsetNext = s * c);
    }
    interpolate_(t, e, n, i) {
      const r = this.resultBuffer,
        s = this.sampleValues,
        a = this.valueSize,
        o = t * a,
        l = o - a,
        c = this._offsetPrev,
        h = this._offsetNext,
        u = this._weightPrev,
        d = this._weightNext,
        p = (n - e) / (i - e),
        f = p * p,
        m = f * p,
        g = -u * m + 2 * u * f - u * p,
        _ = (1 + u) * m + (-1.5 - 2 * u) * f + (-0.5 + u) * p + 1,
        v = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
        y = d * m - d * f;
      for (let t = 0; t !== a; ++t)
        r[t] = g * s[c + t] + _ * s[l + t] + v * s[o + t] + y * s[h + t];
      return r;
    }
  }
  class $a extends Ja {
    constructor(t, e, n, i) {
      super(t, e, n, i);
    }
    interpolate_(t, e, n, i) {
      const r = this.resultBuffer,
        s = this.sampleValues,
        a = this.valueSize,
        o = t * a,
        l = o - a,
        c = (n - e) / (i - e),
        h = 1 - c;
      for (let t = 0; t !== a; ++t) r[t] = s[l + t] * h + s[o + t] * c;
      return r;
    }
  }
  class to extends Ja {
    constructor(t, e, n, i) {
      super(t, e, n, i);
    }
    interpolate_(t) {
      return this.copySampleValue_(t - 1);
    }
  }
  class eo {
    constructor(t, e, n, i) {
      if (void 0 === t)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (void 0 === e || 0 === e.length)
        throw new Error(
          "THREE.KeyframeTrack: no keyframes in track named " + t
        );
      (this.name = t),
        (this.times = qa(e, this.TimeBufferType)),
        (this.values = qa(n, this.ValueBufferType)),
        this.setInterpolation(i || this.DefaultInterpolation);
    }
    static toJSON(t) {
      const e = t.constructor;
      let n;
      if (e.toJSON !== this.toJSON) n = e.toJSON(t);
      else {
        n = {
          name: t.name,
          times: qa(t.times, Array),
          values: qa(t.values, Array),
        };
        const e = t.getInterpolation();
        e !== t.DefaultInterpolation && (n.interpolation = e);
      }
      return (n.type = t.ValueTypeName), n;
    }
    InterpolantFactoryMethodDiscrete(t) {
      return new to(this.times, this.values, this.getValueSize(), t);
    }
    InterpolantFactoryMethodLinear(t) {
      return new $a(this.times, this.values, this.getValueSize(), t);
    }
    InterpolantFactoryMethodSmooth(t) {
      return new Qa(this.times, this.values, this.getValueSize(), t);
    }
    setInterpolation(t) {
      let e;
      switch (t) {
        case G:
          e = this.InterpolantFactoryMethodDiscrete;
          break;
        case V:
          e = this.InterpolantFactoryMethodLinear;
          break;
        case W:
          e = this.InterpolantFactoryMethodSmooth;
      }
      if (void 0 === e) {
        const e =
          "unsupported interpolation for " +
          this.ValueTypeName +
          " keyframe track named " +
          this.name;
        if (void 0 === this.createInterpolant) {
          if (t === this.DefaultInterpolation) throw new Error(e);
          this.setInterpolation(this.DefaultInterpolation);
        }
        return console.warn("THREE.KeyframeTrack:", e), this;
      }
      return (this.createInterpolant = e), this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return G;
        case this.InterpolantFactoryMethodLinear:
          return V;
        case this.InterpolantFactoryMethodSmooth:
          return W;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(t) {
      if (0 !== t) {
        const e = this.times;
        for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
      }
      return this;
    }
    scale(t) {
      if (1 !== t) {
        const e = this.times;
        for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
      }
      return this;
    }
    trim(t, e) {
      const n = this.times,
        i = n.length;
      let r = 0,
        s = i - 1;
      for (; r !== i && n[r] < t; ) ++r;
      for (; -1 !== s && n[s] > e; ) --s;
      if ((++s, 0 !== r || s !== i)) {
        r >= s && ((s = Math.max(s, 1)), (r = s - 1));
        const t = this.getValueSize();
        (this.times = n.slice(r, s)),
          (this.values = this.values.slice(r * t, s * t));
      }
      return this;
    }
    validate() {
      let t = !0;
      const e = this.getValueSize();
      e - Math.floor(e) != 0 &&
        (console.error(
          "THREE.KeyframeTrack: Invalid value size in track.",
          this
        ),
        (t = !1));
      const n = this.times,
        i = this.values,
        r = n.length;
      0 === r &&
        (console.error("THREE.KeyframeTrack: Track is empty.", this), (t = !1));
      let s = null;
      for (let e = 0; e !== r; e++) {
        const i = n[e];
        if ("number" == typeof i && isNaN(i)) {
          console.error(
            "THREE.KeyframeTrack: Time is not a valid number.",
            this,
            e,
            i
          ),
            (t = !1);
          break;
        }
        if (null !== s && s > i) {
          console.error(
            "THREE.KeyframeTrack: Out of order keys.",
            this,
            e,
            i,
            s
          ),
            (t = !1);
          break;
        }
        s = i;
      }
      if (
        void 0 !== i &&
        ((a = i), ArrayBuffer.isView(a) && !(a instanceof DataView))
      )
        for (let e = 0, n = i.length; e !== n; ++e) {
          const n = i[e];
          if (isNaN(n)) {
            console.error(
              "THREE.KeyframeTrack: Value is not a valid number.",
              this,
              e,
              n
            ),
              (t = !1);
            break;
          }
        }
      var a;
      return t;
    }
    optimize() {
      const t = this.times.slice(),
        e = this.values.slice(),
        n = this.getValueSize(),
        i = this.getInterpolation() === W,
        r = t.length - 1;
      let s = 1;
      for (let a = 1; a < r; ++a) {
        let r = !1;
        const o = t[a];
        if (o !== t[a + 1] && (1 !== a || o !== t[0]))
          if (i) r = !0;
          else {
            const t = a * n,
              i = t - n,
              s = t + n;
            for (let a = 0; a !== n; ++a) {
              const n = e[t + a];
              if (n !== e[i + a] || n !== e[s + a]) {
                r = !0;
                break;
              }
            }
          }
        if (r) {
          if (a !== s) {
            t[s] = t[a];
            const i = a * n,
              r = s * n;
            for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
          }
          ++s;
        }
      }
      if (r > 0) {
        t[s] = t[r];
        for (let t = r * n, i = s * n, a = 0; a !== n; ++a) e[i + a] = e[t + a];
        ++s;
      }
      return (
        s !== t.length
          ? ((this.times = t.slice(0, s)), (this.values = e.slice(0, s * n)))
          : ((this.times = t), (this.values = e)),
        this
      );
    }
    clone() {
      const t = this.times.slice(),
        e = this.values.slice(),
        n = new (0, this.constructor)(this.name, t, e);
      return (n.createInterpolant = this.createInterpolant), n;
    }
  }
  (eo.prototype.TimeBufferType = Float32Array),
    (eo.prototype.ValueBufferType = Float32Array),
    (eo.prototype.DefaultInterpolation = V);
  class no extends eo {}
  (no.prototype.ValueTypeName = "bool"),
    (no.prototype.ValueBufferType = Array),
    (no.prototype.DefaultInterpolation = G),
    (no.prototype.InterpolantFactoryMethodLinear = void 0),
    (no.prototype.InterpolantFactoryMethodSmooth = void 0);
  class io extends eo {}
  io.prototype.ValueTypeName = "color";
  class ro extends eo {}
  ro.prototype.ValueTypeName = "number";
  class so extends Ja {
    constructor(t, e, n, i) {
      super(t, e, n, i);
    }
    interpolate_(t, e, n, i) {
      const r = this.resultBuffer,
        s = this.sampleValues,
        a = this.valueSize,
        o = (n - e) / (i - e);
      let l = t * a;
      for (let t = l + a; l !== t; l += 4)
        qt.slerpFlat(r, 0, s, l - a, s, l, o);
      return r;
    }
  }
  class ao extends eo {
    InterpolantFactoryMethodLinear(t) {
      return new so(this.times, this.values, this.getValueSize(), t);
    }
  }
  (ao.prototype.ValueTypeName = "quaternion"),
    (ao.prototype.DefaultInterpolation = V),
    (ao.prototype.InterpolantFactoryMethodSmooth = void 0);
  class oo extends eo {}
  (oo.prototype.ValueTypeName = "string"),
    (oo.prototype.ValueBufferType = Array),
    (oo.prototype.DefaultInterpolation = G),
    (oo.prototype.InterpolantFactoryMethodLinear = void 0),
    (oo.prototype.InterpolantFactoryMethodSmooth = void 0);
  class lo extends eo {}
  lo.prototype.ValueTypeName = "vector";
  class co {
    constructor(t, e = -1, n, i = 2500) {
      (this.name = t),
        (this.tracks = n),
        (this.duration = e),
        (this.blendMode = i),
        (this.uuid = ut()),
        this.duration < 0 && this.resetDuration();
    }
    static parse(t) {
      const e = [],
        n = t.tracks,
        i = 1 / (t.fps || 1);
      for (let t = 0, r = n.length; t !== r; ++t) e.push(ho(n[t]).scale(i));
      const r = new this(t.name, t.duration, e, t.blendMode);
      return (r.uuid = t.uuid), r;
    }
    static toJSON(t) {
      const e = [],
        n = t.tracks,
        i = {
          name: t.name,
          duration: t.duration,
          tracks: e,
          uuid: t.uuid,
          blendMode: t.blendMode,
        };
      for (let t = 0, i = n.length; t !== i; ++t) e.push(eo.toJSON(n[t]));
      return i;
    }
    static CreateFromMorphTargetSequence(t, e, n, i) {
      const r = e.length,
        s = [];
      for (let t = 0; t < r; t++) {
        let a = [],
          o = [];
        a.push((t + r - 1) % r, t, (t + 1) % r), o.push(0, 1, 0);
        const l = Ya(a);
        (a = Ka(a, 1, l)),
          (o = Ka(o, 1, l)),
          i || 0 !== a[0] || (a.push(r), o.push(o[0])),
          s.push(
            new ro(".morphTargetInfluences[" + e[t].name + "]", a, o).scale(
              1 / n
            )
          );
      }
      return new this(t, -1, s);
    }
    static findByName(t, e) {
      let n = t;
      if (!Array.isArray(t)) {
        const e = t;
        n = (e.geometry && e.geometry.animations) || e.animations;
      }
      for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t];
      return null;
    }
    static CreateClipsFromMorphTargetSequences(t, e, n) {
      const i = {},
        r = /^([\w-]*?)([\d]+)$/;
      for (let e = 0, n = t.length; e < n; e++) {
        const n = t[e],
          s = n.name.match(r);
        if (s && s.length > 1) {
          const t = s[1];
          let e = i[t];
          e || (i[t] = e = []), e.push(n);
        }
      }
      const s = [];
      for (const t in i)
        s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
      return s;
    }
    static parseAnimation(t, e) {
      if (!t)
        return (
          console.error(
            "THREE.AnimationClip: No animation in JSONLoader data."
          ),
          null
        );
      const n = function (t, e, n, i, r) {
          if (0 !== n.length) {
            const s = [],
              a = [];
            Za(n, s, a, i), 0 !== s.length && r.push(new t(e, s, a));
          }
        },
        i = [],
        r = t.name || "default",
        s = t.fps || 30,
        a = t.blendMode;
      let o = t.length || -1;
      const l = t.hierarchy || [];
      for (let t = 0; t < l.length; t++) {
        const r = l[t].keys;
        if (r && 0 !== r.length)
          if (r[0].morphTargets) {
            const t = {};
            let e;
            for (e = 0; e < r.length; e++)
              if (r[e].morphTargets)
                for (let n = 0; n < r[e].morphTargets.length; n++)
                  t[r[e].morphTargets[n]] = -1;
            for (const n in t) {
              const t = [],
                s = [];
              for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                const i = r[e];
                t.push(i.time), s.push(i.morphTarget === n ? 1 : 0);
              }
              i.push(new ro(".morphTargetInfluence[" + n + "]", t, s));
            }
            o = t.length * s;
          } else {
            const s = ".bones[" + e[t].name + "]";
            n(lo, s + ".position", r, "pos", i),
              n(ao, s + ".quaternion", r, "rot", i),
              n(lo, s + ".scale", r, "scl", i);
          }
      }
      return 0 === i.length ? null : new this(r, o, i, a);
    }
    resetDuration() {
      let t = 0;
      for (let e = 0, n = this.tracks.length; e !== n; ++e) {
        const n = this.tracks[e];
        t = Math.max(t, n.times[n.times.length - 1]);
      }
      return (this.duration = t), this;
    }
    trim() {
      for (let t = 0; t < this.tracks.length; t++)
        this.tracks[t].trim(0, this.duration);
      return this;
    }
    validate() {
      let t = !0;
      for (let e = 0; e < this.tracks.length; e++)
        t = t && this.tracks[e].validate();
      return t;
    }
    optimize() {
      for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
      return this;
    }
    clone() {
      const t = [];
      for (let e = 0; e < this.tracks.length; e++)
        t.push(this.tracks[e].clone());
      return new this.constructor(this.name, this.duration, t, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  }
  function ho(t) {
    if (void 0 === t.type)
      throw new Error(
        "THREE.KeyframeTrack: track type undefined, can not parse"
      );
    const e = (function (t) {
      switch (t.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
          return ro;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return lo;
        case "color":
          return io;
        case "quaternion":
          return ao;
        case "bool":
        case "boolean":
          return no;
        case "string":
          return oo;
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
    })(t.type);
    if (void 0 === t.times) {
      const e = [],
        n = [];
      Za(t.keys, e, n, "value"), (t.times = e), (t.values = n);
    }
    return void 0 !== e.parse
      ? e.parse(t)
      : new e(t.name, t.times, t.values, t.interpolation);
  }
  const uo = {
    enabled: !1,
    files: {},
    add: function (t, e) {
      !1 !== this.enabled && (this.files[t] = e);
    },
    get: function (t) {
      if (!1 !== this.enabled) return this.files[t];
    },
    remove: function (t) {
      delete this.files[t];
    },
    clear: function () {
      this.files = {};
    },
  };
  class po {
    constructor(t, e, n) {
      const i = this;
      let r,
        s = !1,
        a = 0,
        o = 0;
      const l = [];
      (this.onStart = void 0),
        (this.onLoad = t),
        (this.onProgress = e),
        (this.onError = n),
        (this.itemStart = function (t) {
          o++, !1 === s && void 0 !== i.onStart && i.onStart(t, a, o), (s = !0);
        }),
        (this.itemEnd = function (t) {
          a++,
            void 0 !== i.onProgress && i.onProgress(t, a, o),
            a === o && ((s = !1), void 0 !== i.onLoad && i.onLoad());
        }),
        (this.itemError = function (t) {
          void 0 !== i.onError && i.onError(t);
        }),
        (this.resolveURL = function (t) {
          return r ? r(t) : t;
        }),
        (this.setURLModifier = function (t) {
          return (r = t), this;
        }),
        (this.addHandler = function (t, e) {
          return l.push(t, e), this;
        }),
        (this.removeHandler = function (t) {
          const e = l.indexOf(t);
          return -1 !== e && l.splice(e, 2), this;
        }),
        (this.getHandler = function (t) {
          for (let e = 0, n = l.length; e < n; e += 2) {
            const n = l[e],
              i = l[e + 1];
            if ((n.global && (n.lastIndex = 0), n.test(t))) return i;
          }
          return null;
        });
    }
  }
  const fo = new po();
  class mo {
    constructor(t) {
      (this.manager = void 0 !== t ? t : fo),
        (this.crossOrigin = "anonymous"),
        (this.withCredentials = !1),
        (this.path = ""),
        (this.resourcePath = ""),
        (this.requestHeader = {});
    }
    load() {}
    loadAsync(t, e) {
      const n = this;
      return new Promise(function (i, r) {
        n.load(t, i, e, r);
      });
    }
    parse() {}
    setCrossOrigin(t) {
      return (this.crossOrigin = t), this;
    }
    setWithCredentials(t) {
      return (this.withCredentials = t), this;
    }
    setPath(t) {
      return (this.path = t), this;
    }
    setResourcePath(t) {
      return (this.resourcePath = t), this;
    }
    setRequestHeader(t) {
      return (this.requestHeader = t), this;
    }
  }
  mo.DEFAULT_MATERIAL_NAME = "__DEFAULT";
  const go = {};
  class _o extends Error {
    constructor(t, e) {
      super(t), (this.response = e);
    }
  }
  class vo extends mo {
    constructor(t) {
      super(t);
    }
    load(t, e, n, i) {
      void 0 === t && (t = ""),
        void 0 !== this.path && (t = this.path + t),
        (t = this.manager.resolveURL(t));
      const r = uo.get(t);
      if (void 0 !== r)
        return (
          this.manager.itemStart(t),
          setTimeout(() => {
            e && e(r), this.manager.itemEnd(t);
          }, 0),
          r
        );
      if (void 0 !== go[t])
        return void go[t].push({ onLoad: e, onProgress: n, onError: i });
      (go[t] = []), go[t].push({ onLoad: e, onProgress: n, onError: i });
      const s = new Request(t, {
          headers: new Headers(this.requestHeader),
          credentials: this.withCredentials ? "include" : "same-origin",
        }),
        a = this.mimeType,
        o = this.responseType;
      fetch(s)
        .then((e) => {
          if (200 === e.status || 0 === e.status) {
            if (
              (0 === e.status &&
                console.warn("THREE.FileLoader: HTTP Status 0 received."),
              "undefined" == typeof ReadableStream ||
                void 0 === e.body ||
                void 0 === e.body.getReader)
            )
              return e;
            const n = go[t],
              i = e.body.getReader(),
              r =
                e.headers.get("Content-Length") || e.headers.get("X-File-Size"),
              s = r ? parseInt(r) : 0,
              a = 0 !== s;
            let o = 0;
            const l = new ReadableStream({
              start(t) {
                !(function e() {
                  i.read().then(({ done: i, value: r }) => {
                    if (i) t.close();
                    else {
                      o += r.byteLength;
                      const i = new ProgressEvent("progress", {
                        lengthComputable: a,
                        loaded: o,
                        total: s,
                      });
                      for (let t = 0, e = n.length; t < e; t++) {
                        const e = n[t];
                        e.onProgress && e.onProgress(i);
                      }
                      t.enqueue(r), e();
                    }
                  });
                })();
              },
            });
            return new Response(l);
          }
          throw new _o(
            `fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`,
            e
          );
        })
        .then((t) => {
          switch (o) {
            case "arraybuffer":
              return t.arrayBuffer();
            case "blob":
              return t.blob();
            case "document":
              return t
                .text()
                .then((t) => new DOMParser().parseFromString(t, a));
            case "json":
              return t.json();
            default:
              if (void 0 === a) return t.text();
              {
                const e = /charset="?([^;"\s]*)"?/i.exec(a),
                  n = e && e[1] ? e[1].toLowerCase() : void 0,
                  i = new TextDecoder(n);
                return t.arrayBuffer().then((t) => i.decode(t));
              }
          }
        })
        .then((e) => {
          uo.add(t, e);
          const n = go[t];
          delete go[t];
          for (let t = 0, i = n.length; t < i; t++) {
            const i = n[t];
            i.onLoad && i.onLoad(e);
          }
        })
        .catch((e) => {
          const n = go[t];
          if (void 0 === n) throw (this.manager.itemError(t), e);
          delete go[t];
          for (let t = 0, i = n.length; t < i; t++) {
            const i = n[t];
            i.onError && i.onError(e);
          }
          this.manager.itemError(t);
        })
        .finally(() => {
          this.manager.itemEnd(t);
        }),
        this.manager.itemStart(t);
    }
    setResponseType(t) {
      return (this.responseType = t), this;
    }
    setMimeType(t) {
      return (this.mimeType = t), this;
    }
  }
  class yo extends mo {
    constructor(t) {
      super(t);
    }
    load(t, e, n, i) {
      void 0 !== this.path && (t = this.path + t),
        (t = this.manager.resolveURL(t));
      const r = this,
        s = uo.get(t);
      if (void 0 !== s)
        return (
          r.manager.itemStart(t),
          setTimeout(function () {
            e && e(s), r.manager.itemEnd(t);
          }, 0),
          s
        );
      const a = bt("img");
      function o() {
        c(), uo.add(t, this), e && e(this), r.manager.itemEnd(t);
      }
      function l(e) {
        c(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
      }
      function c() {
        a.removeEventListener("load", o, !1),
          a.removeEventListener("error", l, !1);
      }
      return (
        a.addEventListener("load", o, !1),
        a.addEventListener("error", l, !1),
        "data:" !== t.slice(0, 5) &&
          void 0 !== this.crossOrigin &&
          (a.crossOrigin = this.crossOrigin),
        r.manager.itemStart(t),
        (a.src = t),
        a
      );
    }
  }
  class xo extends mo {
    constructor(t) {
      super(t);
    }
    load(t, e, n, i) {
      const r = new Ht(),
        s = new yo(this.manager);
      return (
        s.setCrossOrigin(this.crossOrigin),
        s.setPath(this.path),
        s.load(
          t,
          function (t) {
            (r.image = t), (r.needsUpdate = !0), void 0 !== e && e(r);
          },
          n,
          i
        ),
        r
      );
    }
  }
  class To extends Ke {
    constructor(t, e = 1) {
      super(),
        (this.isLight = !0),
        (this.type = "Light"),
        (this.color = new pn(t)),
        (this.intensity = e);
    }
    dispose() {}
    copy(t, e) {
      return (
        super.copy(t, e),
        this.color.copy(t.color),
        (this.intensity = t.intensity),
        this
      );
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        (e.object.color = this.color.getHex()),
        (e.object.intensity = this.intensity),
        void 0 !== this.groundColor &&
          (e.object.groundColor = this.groundColor.getHex()),
        void 0 !== this.distance && (e.object.distance = this.distance),
        void 0 !== this.angle && (e.object.angle = this.angle),
        void 0 !== this.decay && (e.object.decay = this.decay),
        void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
        void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
        e
      );
    }
  }
  const Mo = new be(),
    So = new Yt(),
    bo = new Yt();
  class Eo {
    constructor(t) {
      (this.camera = t),
        (this.bias = 0),
        (this.normalBias = 0),
        (this.radius = 1),
        (this.blurSamples = 8),
        (this.mapSize = new xt(512, 512)),
        (this.map = null),
        (this.mapPass = null),
        (this.matrix = new be()),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this._frustum = new mi()),
        (this._frameExtents = new xt(1, 1)),
        (this._viewportCount = 1),
        (this._viewports = [new Gt(0, 0, 1, 1)]);
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(t) {
      const e = this.camera,
        n = this.matrix;
      So.setFromMatrixPosition(t.matrixWorld),
        e.position.copy(So),
        bo.setFromMatrixPosition(t.target.matrixWorld),
        e.lookAt(bo),
        e.updateMatrixWorld(),
        Mo.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Mo),
        n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
        n.multiply(Mo);
    }
    getViewport(t) {
      return this._viewports[t];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(t) {
      return (
        (this.camera = t.camera.clone()),
        (this.bias = t.bias),
        (this.radius = t.radius),
        this.mapSize.copy(t.mapSize),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const t = {};
      return (
        0 !== this.bias && (t.bias = this.bias),
        0 !== this.normalBias && (t.normalBias = this.normalBias),
        1 !== this.radius && (t.radius = this.radius),
        (512 === this.mapSize.x && 512 === this.mapSize.y) ||
          (t.mapSize = this.mapSize.toArray()),
        (t.camera = this.camera.toJSON(!1).object),
        delete t.camera.matrix,
        t
      );
    }
  }
  class wo extends Eo {
    constructor() {
      super(new ri(50, 1, 0.5, 500)),
        (this.isSpotLightShadow = !0),
        (this.focus = 1);
    }
    updateMatrices(t) {
      const e = this.camera,
        n = 2 * ht * t.angle * this.focus,
        i = this.mapSize.width / this.mapSize.height,
        r = t.distance || e.far;
      (n === e.fov && i === e.aspect && r === e.far) ||
        ((e.fov = n), (e.aspect = i), (e.far = r), e.updateProjectionMatrix()),
        super.updateMatrices(t);
    }
    copy(t) {
      return super.copy(t), (this.focus = t.focus), this;
    }
  }
  class Ao extends To {
    constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 2) {
      super(t, e),
        (this.isSpotLight = !0),
        (this.type = "SpotLight"),
        this.position.copy(Ke.DEFAULT_UP),
        this.updateMatrix(),
        (this.target = new Ke()),
        (this.distance = n),
        (this.angle = i),
        (this.penumbra = r),
        (this.decay = s),
        (this.map = null),
        (this.shadow = new wo());
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(t) {
      this.intensity = t / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.distance = t.distance),
        (this.angle = t.angle),
        (this.penumbra = t.penumbra),
        (this.decay = t.decay),
        (this.target = t.target.clone()),
        (this.shadow = t.shadow.clone()),
        this
      );
    }
  }
  const Ro = new be(),
    Co = new Yt(),
    Po = new Yt();
  class Lo extends Eo {
    constructor() {
      super(new ri(90, 1, 0.5, 500)),
        (this.isPointLightShadow = !0),
        (this._frameExtents = new xt(4, 2)),
        (this._viewportCount = 6),
        (this._viewports = [
          new Gt(2, 1, 1, 1),
          new Gt(0, 1, 1, 1),
          new Gt(3, 1, 1, 1),
          new Gt(1, 1, 1, 1),
          new Gt(3, 0, 1, 1),
          new Gt(1, 0, 1, 1),
        ]),
        (this._cubeDirections = [
          new Yt(1, 0, 0),
          new Yt(-1, 0, 0),
          new Yt(0, 0, 1),
          new Yt(0, 0, -1),
          new Yt(0, 1, 0),
          new Yt(0, -1, 0),
        ]),
        (this._cubeUps = [
          new Yt(0, 1, 0),
          new Yt(0, 1, 0),
          new Yt(0, 1, 0),
          new Yt(0, 1, 0),
          new Yt(0, 0, 1),
          new Yt(0, 0, -1),
        ]);
    }
    updateMatrices(t, e = 0) {
      const n = this.camera,
        i = this.matrix,
        r = t.distance || n.far;
      r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
        Co.setFromMatrixPosition(t.matrixWorld),
        n.position.copy(Co),
        Po.copy(n.position),
        Po.add(this._cubeDirections[e]),
        n.up.copy(this._cubeUps[e]),
        n.lookAt(Po),
        n.updateMatrixWorld(),
        i.makeTranslation(-Co.x, -Co.y, -Co.z),
        Ro.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Ro);
    }
  }
  class Do extends To {
    constructor(t, e, n = 0, i = 2) {
      super(t, e),
        (this.isPointLight = !0),
        (this.type = "PointLight"),
        (this.distance = n),
        (this.decay = i),
        (this.shadow = new Lo());
    }
    get power() {
      return 4 * this.intensity * Math.PI;
    }
    set power(t) {
      this.intensity = t / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.distance = t.distance),
        (this.decay = t.decay),
        (this.shadow = t.shadow.clone()),
        this
      );
    }
  }
  class Io extends Eo {
    constructor() {
      super(new Ci(-5, 5, 5, -5, 0.5, 500)),
        (this.isDirectionalLightShadow = !0);
    }
  }
  class Uo extends To {
    constructor(t, e) {
      super(t, e),
        (this.isDirectionalLight = !0),
        (this.type = "DirectionalLight"),
        this.position.copy(Ke.DEFAULT_UP),
        this.updateMatrix(),
        (this.target = new Ke()),
        (this.shadow = new Io());
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t) {
      return (
        super.copy(t),
        (this.target = t.target.clone()),
        (this.shadow = t.shadow.clone()),
        this
      );
    }
  }
  class No extends To {
    constructor(t, e) {
      super(t, e), (this.isAmbientLight = !0), (this.type = "AmbientLight");
    }
  }
  class Oo {
    static decodeText(t) {
      if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(t);
      let e = "";
      for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
      try {
        return decodeURIComponent(escape(e));
      } catch (t) {
        return e;
      }
    }
    static extractUrlBase(t) {
      const e = t.lastIndexOf("/");
      return -1 === e ? "./" : t.slice(0, e + 1);
    }
    static resolveURL(t, e) {
      return "string" != typeof t || "" === t
        ? ""
        : (/^https?:\/\//i.test(e) &&
            /^\//.test(t) &&
            (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
          /^(https?:)?\/\//i.test(t) ||
          /^data:.*,.*$/i.test(t) ||
          /^blob:.*$/i.test(t)
            ? t
            : e + t);
    }
  }
  class Fo extends mo {
    constructor(t) {
      super(t),
        (this.isImageBitmapLoader = !0),
        "undefined" == typeof createImageBitmap &&
          console.warn(
            "THREE.ImageBitmapLoader: createImageBitmap() not supported."
          ),
        "undefined" == typeof fetch &&
          console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        (this.options = { premultiplyAlpha: "none" });
    }
    setOptions(t) {
      return (this.options = t), this;
    }
    load(t, e, n, i) {
      void 0 === t && (t = ""),
        void 0 !== this.path && (t = this.path + t),
        (t = this.manager.resolveURL(t));
      const r = this,
        s = uo.get(t);
      if (void 0 !== s)
        return (
          r.manager.itemStart(t),
          s.then
            ? void s
                .then((n) => {
                  e && e(n), r.manager.itemEnd(t);
                })
                .catch((t) => {
                  i && i(t);
                })
            : (setTimeout(function () {
                e && e(s), r.manager.itemEnd(t);
              }, 0),
              s)
        );
      const a = {};
      (a.credentials =
        "anonymous" === this.crossOrigin ? "same-origin" : "include"),
        (a.headers = this.requestHeader);
      const o = fetch(t, a)
        .then(function (t) {
          return t.blob();
        })
        .then(function (t) {
          return createImageBitmap(
            t,
            Object.assign(r.options, { colorSpaceConversion: "none" })
          );
        })
        .then(function (n) {
          return uo.add(t, n), e && e(n), r.manager.itemEnd(t), n;
        })
        .catch(function (e) {
          i && i(e), uo.remove(t), r.manager.itemError(t), r.manager.itemEnd(t);
        });
      uo.add(t, o), r.manager.itemStart(t);
    }
  }
  class ko {
    constructor(t = !0) {
      (this.autoStart = t),
        (this.startTime = 0),
        (this.oldTime = 0),
        (this.elapsedTime = 0),
        (this.running = !1);
    }
    start() {
      (this.startTime = zo()),
        (this.oldTime = this.startTime),
        (this.elapsedTime = 0),
        (this.running = !0);
    }
    stop() {
      this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
    }
    getElapsedTime() {
      return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
      let t = 0;
      if (this.autoStart && !this.running) return this.start(), 0;
      if (this.running) {
        const e = zo();
        (t = (e - this.oldTime) / 1e3),
          (this.oldTime = e),
          (this.elapsedTime += t);
      }
      return t;
    }
  }
  function zo() {
    return ("undefined" == typeof performance ? Date : performance).now();
  }
  const Bo = "\\[\\]\\.:\\/",
    Ho = new RegExp("[" + Bo + "]", "g"),
    Go = "[^" + Bo + "]",
    Vo = "[^" + Bo.replace("\\.", "") + "]",
    Wo = new RegExp(
      "^" +
        /((?:WC+[\/:])*)/.source.replace("WC", Go) +
        /(WCOD+)?/.source.replace("WCOD", Vo) +
        /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Go) +
        /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Go) +
        "$"
    ),
    Xo = ["material", "materials", "bones", "map"];
  class jo {
    constructor(t, e, n) {
      (this.path = e),
        (this.parsedPath = n || jo.parseTrackName(e)),
        (this.node = jo.findNode(t, this.parsedPath.nodeName)),
        (this.rootNode = t),
        (this.getValue = this._getValue_unbound),
        (this.setValue = this._setValue_unbound);
    }
    static create(t, e, n) {
      return t && t.isAnimationObjectGroup
        ? new jo.Composite(t, e, n)
        : new jo(t, e, n);
    }
    static sanitizeNodeName(t) {
      return t.replace(/\s/g, "_").replace(Ho, "");
    }
    static parseTrackName(t) {
      const e = Wo.exec(t);
      if (null === e)
        throw new Error("PropertyBinding: Cannot parse trackName: " + t);
      const n = {
          nodeName: e[2],
          objectName: e[3],
          objectIndex: e[4],
          propertyName: e[5],
          propertyIndex: e[6],
        },
        i = n.nodeName && n.nodeName.lastIndexOf(".");
      if (void 0 !== i && -1 !== i) {
        const t = n.nodeName.substring(i + 1);
        -1 !== Xo.indexOf(t) &&
          ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t));
      }
      if (null === n.propertyName || 0 === n.propertyName.length)
        throw new Error(
          "PropertyBinding: can not parse propertyName from trackName: " + t
        );
      return n;
    }
    static findNode(t, e) {
      if (
        void 0 === e ||
        "" === e ||
        "." === e ||
        -1 === e ||
        e === t.name ||
        e === t.uuid
      )
        return t;
      if (t.skeleton) {
        const n = t.skeleton.getBoneByName(e);
        if (void 0 !== n) return n;
      }
      if (t.children) {
        const n = function (t) {
            for (let i = 0; i < t.length; i++) {
              const r = t[i];
              if (r.name === e || r.uuid === e) return r;
              const s = n(r.children);
              if (s) return s;
            }
            return null;
          },
          i = n(t.children);
        if (i) return i;
      }
      return null;
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(t, e) {
      t[e] = this.targetObject[this.propertyName];
    }
    _getValue_array(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
    }
    _getValue_arrayElement(t, e) {
      t[e] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(t, e) {
      this.resolvedProperty.toArray(t, e);
    }
    _setValue_direct(t, e) {
      this.targetObject[this.propertyName] = t[e];
    }
    _setValue_direct_setNeedsUpdate(t, e) {
      (this.targetObject[this.propertyName] = t[e]),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
      (this.targetObject[this.propertyName] = t[e]),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _setValue_array(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
    }
    _setValue_array_setNeedsUpdate(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
      this.targetObject.needsUpdate = !0;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
      this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _setValue_arrayElement(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e];
    }
    _setValue_arrayElement_setNeedsUpdate(t, e) {
      (this.resolvedProperty[this.propertyIndex] = t[e]),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
      (this.resolvedProperty[this.propertyIndex] = t[e]),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _setValue_fromArray(t, e) {
      this.resolvedProperty.fromArray(t, e);
    }
    _setValue_fromArray_setNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _getValue_unbound(t, e) {
      this.bind(), this.getValue(t, e);
    }
    _setValue_unbound(t, e) {
      this.bind(), this.setValue(t, e);
    }
    bind() {
      let t = this.node;
      const e = this.parsedPath,
        n = e.objectName,
        i = e.propertyName;
      let r = e.propertyIndex;
      if (
        (t || ((t = jo.findNode(this.rootNode, e.nodeName)), (this.node = t)),
        (this.getValue = this._getValue_unavailable),
        (this.setValue = this._setValue_unavailable),
        !t)
      )
        return void console.warn(
          "THREE.PropertyBinding: No target node found for track: " +
            this.path +
            "."
        );
      if (n) {
        let i = e.objectIndex;
        switch (n) {
          case "materials":
            if (!t.material)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                this
              );
            if (!t.material.materials)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                this
              );
            t = t.material.materials;
            break;
          case "bones":
            if (!t.skeleton)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                this
              );
            t = t.skeleton.bones;
            for (let e = 0; e < t.length; e++)
              if (t[e].name === i) {
                i = e;
                break;
              }
            break;
          case "map":
            if ("map" in t) {
              t = t.map;
              break;
            }
            if (!t.material)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                this
              );
            if (!t.material.map)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
                this
              );
            t = t.material.map;
            break;
          default:
            if (void 0 === t[n])
              return void console.error(
                "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                this
              );
            t = t[n];
        }
        if (void 0 !== i) {
          if (void 0 === t[i])
            return void console.error(
              "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
              this,
              t
            );
          t = t[i];
        }
      }
      const s = t[i];
      if (void 0 === s) {
        const n = e.nodeName;
        return void console.error(
          "THREE.PropertyBinding: Trying to update property for track: " +
            n +
            "." +
            i +
            " but it wasn't found.",
          t
        );
      }
      let a = this.Versioning.None;
      (this.targetObject = t),
        void 0 !== t.needsUpdate
          ? (a = this.Versioning.NeedsUpdate)
          : void 0 !== t.matrixWorldNeedsUpdate &&
            (a = this.Versioning.MatrixWorldNeedsUpdate);
      let o = this.BindingType.Direct;
      if (void 0 !== r) {
        if ("morphTargetInfluences" === i) {
          if (!t.geometry)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
              this
            );
          if (!t.geometry.morphAttributes)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
              this
            );
          void 0 !== t.morphTargetDictionary[r] &&
            (r = t.morphTargetDictionary[r]);
        }
        (o = this.BindingType.ArrayElement),
          (this.resolvedProperty = s),
          (this.propertyIndex = r);
      } else
        void 0 !== s.fromArray && void 0 !== s.toArray
          ? ((o = this.BindingType.HasFromToArray), (this.resolvedProperty = s))
          : Array.isArray(s)
          ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = s))
          : (this.propertyName = i);
      (this.getValue = this.GetterByBindingType[o]),
        (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
    }
    unbind() {
      (this.node = null),
        (this.getValue = this._getValue_unbound),
        (this.setValue = this._setValue_unbound);
    }
  }
  (jo.Composite = class {
    constructor(t, e, n) {
      const i = n || jo.parseTrackName(e);
      (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
    }
    getValue(t, e) {
      this.bind();
      const n = this._targetGroup.nCachedObjects_,
        i = this._bindings[n];
      void 0 !== i && i.getValue(t, e);
    }
    setValue(t, e) {
      const n = this._bindings;
      for (
        let i = this._targetGroup.nCachedObjects_, r = n.length;
        i !== r;
        ++i
      )
        n[i].setValue(t, e);
    }
    bind() {
      const t = this._bindings;
      for (
        let e = this._targetGroup.nCachedObjects_, n = t.length;
        e !== n;
        ++e
      )
        t[e].bind();
    }
    unbind() {
      const t = this._bindings;
      for (
        let e = this._targetGroup.nCachedObjects_, n = t.length;
        e !== n;
        ++e
      )
        t[e].unbind();
    }
  }),
    (jo.prototype.BindingType = {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3,
    }),
    (jo.prototype.Versioning = {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2,
    }),
    (jo.prototype.GetterByBindingType = [
      jo.prototype._getValue_direct,
      jo.prototype._getValue_array,
      jo.prototype._getValue_arrayElement,
      jo.prototype._getValue_toArray,
    ]),
    (jo.prototype.SetterByBindingTypeAndVersioning = [
      [
        jo.prototype._setValue_direct,
        jo.prototype._setValue_direct_setNeedsUpdate,
        jo.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
      ],
      [
        jo.prototype._setValue_array,
        jo.prototype._setValue_array_setNeedsUpdate,
        jo.prototype._setValue_array_setMatrixWorldNeedsUpdate,
      ],
      [
        jo.prototype._setValue_arrayElement,
        jo.prototype._setValue_arrayElement_setNeedsUpdate,
        jo.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
      ],
      [
        jo.prototype._setValue_fromArray,
        jo.prototype._setValue_fromArray_setNeedsUpdate,
        jo.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
      ],
    ]),
    new Float32Array(1);
  class qo extends Na {
    constructor(t = 1) {
      const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
        n = new Ln();
      n.setAttribute("position", new Sn(e, 3)),
        n.setAttribute(
          "color",
          new Sn(
            [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
            3
          )
        ),
        super(n, new wa({ vertexColors: !0, toneMapped: !1 })),
        (this.type = "AxesHelper");
    }
    setColors(t, e, n) {
      const i = new pn(),
        r = this.geometry.attributes.color.array;
      return (
        i.set(t),
        i.toArray(r, 0),
        i.toArray(r, 3),
        i.set(e),
        i.toArray(r, 6),
        i.toArray(r, 9),
        i.set(n),
        i.toArray(r, 12),
        i.toArray(r, 15),
        (this.geometry.attributes.color.needsUpdate = !0),
        this
      );
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  function Yo(t) {
    if (void 0 === t)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      );
    return t;
  }
  function Ko(t, e) {
    (t.prototype = Object.create(e.prototype)),
      (t.prototype.constructor = t),
      (t.__proto__ = e);
  }
  "undefined" != typeof __THREE_DEVTOOLS__ &&
    __THREE_DEVTOOLS__.dispatchEvent(
      new CustomEvent("register", { detail: { revision: e } })
    ),
    "undefined" != typeof window &&
      (window.__THREE__
        ? console.warn(
            "WARNING: Multiple instances of Three.js being imported."
          )
        : (window.__THREE__ = e));
  var Zo,
    Jo,
    Qo,
    $o,
    tl,
    el,
    nl,
    il,
    rl,
    sl,
    al,
    ol,
    ll,
    cl,
    hl,
    ul = {
      autoSleep: 120,
      force3D: "auto",
      nullTargetWarn: 1,
      units: { lineHeight: "" },
    },
    dl = { duration: 0.5, overwrite: !1, delay: 0 },
    pl = 1e8,
    fl = 1e-8,
    ml = 2 * Math.PI,
    gl = ml / 4,
    _l = 0,
    vl = Math.sqrt,
    yl = Math.cos,
    xl = Math.sin,
    Tl = function (t) {
      return "string" == typeof t;
    },
    Ml = function (t) {
      return "function" == typeof t;
    },
    Sl = function (t) {
      return "number" == typeof t;
    },
    bl = function (t) {
      return void 0 === t;
    },
    El = function (t) {
      return "object" == typeof t;
    },
    wl = function (t) {
      return !1 !== t;
    },
    Al = function () {
      return "undefined" != typeof window;
    },
    Rl = function (t) {
      return Ml(t) || Tl(t);
    },
    Cl =
      ("function" == typeof ArrayBuffer && ArrayBuffer.isView) ||
      function () {},
    Pl = Array.isArray,
    Ll = /(?:-?\.?\d|\.)+/gi,
    Dl = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    Il = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    Ul = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    Nl = /[+-]=-?[.\d]+/,
    Ol = /[^,'"\[\]\s]+/gi,
    Fl = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
    kl = {},
    zl = {},
    Bl = function (t) {
      return (zl = mc(t, kl)) && mu;
    },
    Hl = function (t, e) {
      return console.warn(
        "Invalid property",
        t,
        "set to",
        e,
        "Missing plugin? gsap.registerPlugin()"
      );
    },
    Gl = function (t, e) {
      return !e && console.warn(t);
    },
    Vl = function (t, e) {
      return (t && (kl[t] = e) && zl && (zl[t] = e)) || kl;
    },
    Wl = function () {
      return 0;
    },
    Xl = { suppressEvents: !0, isStart: !0, kill: !1 },
    jl = { suppressEvents: !0, kill: !1 },
    ql = { suppressEvents: !0 },
    Yl = {},
    Kl = [],
    Zl = {},
    Jl = {},
    Ql = {},
    $l = 30,
    tc = [],
    ec = "",
    nc = function (t) {
      var e,
        n,
        i = t[0];
      if ((El(i) || Ml(i) || (t = [t]), !(e = (i._gsap || {}).harness))) {
        for (n = tc.length; n-- && !tc[n].targetTest(i); );
        e = tc[n];
      }
      for (n = t.length; n--; )
        (t[n] && (t[n]._gsap || (t[n]._gsap = new Ch(t[n], e)))) ||
          t.splice(n, 1);
      return t;
    },
    ic = function (t) {
      return t._gsap || nc(jc(t))[0]._gsap;
    },
    rc = function (t, e, n) {
      return (n = t[e]) && Ml(n)
        ? t[e]()
        : (bl(n) && t.getAttribute && t.getAttribute(e)) || n;
    },
    sc = function (t, e) {
      return (t = t.split(",")).forEach(e) || t;
    },
    ac = function (t) {
      return Math.round(1e5 * t) / 1e5 || 0;
    },
    oc = function (t) {
      return Math.round(1e7 * t) / 1e7 || 0;
    },
    lc = function (t, e) {
      var n = e.charAt(0),
        i = parseFloat(e.substr(2));
      return (
        (t = parseFloat(t)),
        "+" === n ? t + i : "-" === n ? t - i : "*" === n ? t * i : t / i
      );
    },
    cc = function (t, e) {
      for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n; );
      return i < n;
    },
    hc = function () {
      var t,
        e,
        n = Kl.length,
        i = Kl.slice(0);
      for (Zl = {}, Kl.length = 0, t = 0; t < n; t++)
        (e = i[t]) &&
          e._lazy &&
          (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0);
    },
    uc = function (t, e, n, i) {
      Kl.length && !Jo && hc(),
        t.render(e, n, i || (Jo && e < 0 && (t._initted || t._startAt))),
        Kl.length && !Jo && hc();
    },
    dc = function (t) {
      var e = parseFloat(t);
      return (e || 0 === e) && (t + "").match(Ol).length < 2
        ? e
        : Tl(t)
        ? t.trim()
        : t;
    },
    pc = function (t) {
      return t;
    },
    fc = function (t, e) {
      for (var n in e) n in t || (t[n] = e[n]);
      return t;
    },
    mc = function (t, e) {
      for (var n in e) t[n] = e[n];
      return t;
    },
    gc = function t(e, n) {
      for (var i in n)
        "__proto__" !== i &&
          "constructor" !== i &&
          "prototype" !== i &&
          (e[i] = El(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i]);
      return e;
    },
    _c = function (t, e) {
      var n,
        i = {};
      for (n in t) n in e || (i[n] = t[n]);
      return i;
    },
    vc = function (t) {
      var e,
        n = t.parent || $o,
        i = t.keyframes
          ? ((e = Pl(t.keyframes)),
            function (t, n) {
              for (var i in n)
                i in t ||
                  ("duration" === i && e) ||
                  "ease" === i ||
                  (t[i] = n[i]);
            })
          : fc;
      if (wl(t.inherit))
        for (; n; ) i(t, n.vars.defaults), (n = n.parent || n._dp);
      return t;
    },
    yc = function (t, e, n, i, r) {
      void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
      var s,
        a = t[i];
      if (r) for (s = e[r]; a && a[r] > s; ) a = a._prev;
      return (
        a
          ? ((e._next = a._next), (a._next = e))
          : ((e._next = t[n]), (t[n] = e)),
        e._next ? (e._next._prev = e) : (t[i] = e),
        (e._prev = a),
        (e.parent = e._dp = t),
        e
      );
    },
    xc = function (t, e, n, i) {
      void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
      var r = e._prev,
        s = e._next;
      r ? (r._next = s) : t[n] === e && (t[n] = s),
        s ? (s._prev = r) : t[i] === e && (t[i] = r),
        (e._next = e._prev = e.parent = null);
    },
    Tc = function (t, e) {
      t.parent &&
        (!e || t.parent.autoRemoveChildren) &&
        t.parent.remove &&
        t.parent.remove(t),
        (t._act = 0);
    },
    Mc = function (t, e) {
      if (t && (!e || e._end > t._dur || e._start < 0))
        for (var n = t; n; ) (n._dirty = 1), (n = n.parent);
      return t;
    },
    Sc = function (t, e, n, i) {
      return (
        t._startAt &&
        (Jo
          ? t._startAt.revert(jl)
          : (t.vars.immediateRender && !t.vars.autoRevert) ||
            t._startAt.render(e, !0, i))
      );
    },
    bc = function t(e) {
      return !e || (e._ts && t(e.parent));
    },
    Ec = function (t) {
      return t._repeat ? wc(t._tTime, (t = t.duration() + t._rDelay)) * t : 0;
    },
    wc = function (t, e) {
      var n = Math.floor((t /= e));
      return t && n === t ? n - 1 : n;
    },
    Ac = function (t, e) {
      return (
        (t - e._start) * e._ts +
        (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
      );
    },
    Rc = function (t) {
      return (t._end = oc(
        t._start + (t._tDur / Math.abs(t._ts || t._rts || fl) || 0)
      ));
    },
    Cc = function (t, e) {
      var n = t._dp;
      return (
        n &&
          n.smoothChildTiming &&
          t._ts &&
          ((t._start = oc(
            n._time -
              (t._ts > 0
                ? e / t._ts
                : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)
          )),
          Rc(t),
          n._dirty || Mc(n, t)),
        t
      );
    },
    Pc = function (t, e) {
      var n;
      if (
        ((e._time ||
          (!e._dur && e._initted) ||
          (e._start < t._time && (e._dur || !e.add))) &&
          ((n = Ac(t.rawTime(), e)),
          (!e._dur || Gc(0, e.totalDuration(), n) - e._tTime > fl) &&
            e.render(n, !0)),
        Mc(t, e)._dp && t._initted && t._time >= t._dur && t._ts)
      ) {
        if (t._dur < t.duration())
          for (n = t; n._dp; )
            n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
        t._zTime = -1e-8;
      }
    },
    Lc = function (t, e, n, i) {
      return (
        e.parent && Tc(e),
        (e._start = oc(
          (Sl(n) ? n : n || t !== $o ? zc(t, n, e) : t._time) + e._delay
        )),
        (e._end = oc(
          e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)
        )),
        yc(t, e, "_first", "_last", t._sort ? "_start" : 0),
        Nc(e) || (t._recent = e),
        i || Pc(t, e),
        t._ts < 0 && Cc(t, t._tTime),
        t
      );
    },
    Dc = function (t, e) {
      return (
        (kl.ScrollTrigger || Hl("scrollTrigger", e)) &&
        kl.ScrollTrigger.create(e, t)
      );
    },
    Ic = function (t, e, n, i, r) {
      return (
        Fh(t, e, r),
        t._initted
          ? !n &&
            t._pt &&
            !Jo &&
            ((t._dur && !1 !== t.vars.lazy) || (!t._dur && t.vars.lazy)) &&
            rl !== gh.frame
            ? (Kl.push(t), (t._lazy = [r, i]), 1)
            : void 0
          : 1
      );
    },
    Uc = function t(e) {
      var n = e.parent;
      return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n));
    },
    Nc = function (t) {
      var e = t.data;
      return "isFromStart" === e || "isStart" === e;
    },
    Oc = function (t, e, n, i) {
      var r = t._repeat,
        s = oc(e) || 0,
        a = t._tTime / t._tDur;
      return (
        a && !i && (t._time *= s / t._dur),
        (t._dur = s),
        (t._tDur = r ? (r < 0 ? 1e10 : oc(s * (r + 1) + t._rDelay * r)) : s),
        a > 0 && !i && Cc(t, (t._tTime = t._tDur * a)),
        t.parent && Rc(t),
        n || Mc(t.parent, t),
        t
      );
    },
    Fc = function (t) {
      return t instanceof Lh ? Mc(t) : Oc(t, t._dur);
    },
    kc = { _start: 0, endTime: Wl, totalDuration: Wl },
    zc = function t(e, n, i) {
      var r,
        s,
        a,
        o = e.labels,
        l = e._recent || kc,
        c = e.duration() >= pl ? l.endTime(!1) : e._dur;
      return Tl(n) && (isNaN(n) || n in o)
        ? ((s = n.charAt(0)),
          (a = "%" === n.substr(-1)),
          (r = n.indexOf("=")),
          "<" === s || ">" === s
            ? (r >= 0 && (n = n.replace(/=/, "")),
              ("<" === s ? l._start : l.endTime(l._repeat >= 0)) +
                (parseFloat(n.substr(1)) || 0) *
                  (a ? (r < 0 ? l : i).totalDuration() / 100 : 1))
            : r < 0
            ? (n in o || (o[n] = c), o[n])
            : ((s = parseFloat(n.charAt(r - 1) + n.substr(r + 1))),
              a && i && (s = (s / 100) * (Pl(i) ? i[0] : i).totalDuration()),
              r > 1 ? t(e, n.substr(0, r - 1), i) + s : c + s))
        : null == n
        ? c
        : +n;
    },
    Bc = function (t, e, n) {
      var i,
        r,
        s = Sl(e[1]),
        a = (s ? 2 : 1) + (t < 2 ? 0 : 1),
        o = e[a];
      if ((s && (o.duration = e[1]), (o.parent = n), t)) {
        for (i = o, r = n; r && !("immediateRender" in i); )
          (i = r.vars.defaults || {}), (r = wl(r.vars.inherit) && r.parent);
        (o.immediateRender = wl(i.immediateRender)),
          t < 2 ? (o.runBackwards = 1) : (o.startAt = e[a - 1]);
      }
      return new Gh(e[0], o, e[a + 1]);
    },
    Hc = function (t, e) {
      return t || 0 === t ? e(t) : e;
    },
    Gc = function (t, e, n) {
      return n < t ? t : n > e ? e : n;
    },
    Vc = function (t, e) {
      return Tl(t) && (e = Fl.exec(t)) ? e[1] : "";
    },
    Wc = [].slice,
    Xc = function (t, e) {
      return (
        t &&
        El(t) &&
        "length" in t &&
        ((!e && !t.length) || (t.length - 1 in t && El(t[0]))) &&
        !t.nodeType &&
        t !== tl
      );
    },
    jc = function (t, e, n) {
      return Qo && !e && Qo.selector
        ? Qo.selector(t)
        : !Tl(t) || n || (!el && _h())
        ? Pl(t)
          ? (function (t, e, n) {
              return (
                void 0 === n && (n = []),
                t.forEach(function (t) {
                  var i;
                  return (Tl(t) && !e) || Xc(t, 1)
                    ? (i = n).push.apply(i, jc(t))
                    : n.push(t);
                }) || n
              );
            })(t, n)
          : Xc(t)
          ? Wc.call(t, 0)
          : t
          ? [t]
          : []
        : Wc.call((e || nl).querySelectorAll(t), 0);
    },
    qc = function (t) {
      return (
        (t = jc(t)[0] || Gl("Invalid scope") || {}),
        function (e) {
          var n = t.current || t.nativeElement || t;
          return jc(
            e,
            n.querySelectorAll
              ? n
              : n === t
              ? Gl("Invalid scope") || nl.createElement("div")
              : t
          );
        }
      );
    },
    Yc = function (t) {
      return t.sort(function () {
        return 0.5 - Math.random();
      });
    },
    Kc = function (t) {
      if (Ml(t)) return t;
      var e = El(t) ? t : { each: t },
        n = bh(e.ease),
        i = e.from || 0,
        r = parseFloat(e.base) || 0,
        s = {},
        a = i > 0 && i < 1,
        o = isNaN(i) || a,
        l = e.axis,
        c = i,
        h = i;
      return (
        Tl(i)
          ? (c = h = { center: 0.5, edges: 0.5, end: 1 }[i] || 0)
          : !a && o && ((c = i[0]), (h = i[1])),
        function (t, a, u) {
          var d,
            p,
            f,
            m,
            g,
            _,
            v,
            y,
            x,
            T = (u || e).length,
            M = s[T];
          if (!M) {
            if (!(x = "auto" === e.grid ? 0 : (e.grid || [1, pl])[1])) {
              for (
                v = -pl;
                v < (v = u[x++].getBoundingClientRect().left) && x < T;

              );
              x < T && x--;
            }
            for (
              M = s[T] = [],
                d = o ? Math.min(x, T) * c - 0.5 : i % x,
                p = x === pl ? 0 : o ? (T * h) / x - 0.5 : (i / x) | 0,
                v = 0,
                y = pl,
                _ = 0;
              _ < T;
              _++
            )
              (f = (_ % x) - d),
                (m = p - ((_ / x) | 0)),
                (M[_] = g =
                  l ? Math.abs("y" === l ? m : f) : vl(f * f + m * m)),
                g > v && (v = g),
                g < y && (y = g);
            "random" === i && Yc(M),
              (M.max = v - y),
              (M.min = y),
              (M.v = T =
                (parseFloat(e.amount) ||
                  parseFloat(e.each) *
                    (x > T
                      ? T - 1
                      : l
                      ? "y" === l
                        ? T / x
                        : x
                      : Math.max(x, T / x)) ||
                  0) * ("edges" === i ? -1 : 1)),
              (M.b = T < 0 ? r - T : r),
              (M.u = Vc(e.amount || e.each) || 0),
              (n = n && T < 0 ? Mh(n) : n);
          }
          return (
            (T = (M[t] - M.min) / M.max || 0),
            oc(M.b + (n ? n(T) : T) * M.v) + M.u
          );
        }
      );
    },
    Zc = function (t) {
      var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
      return function (n) {
        var i = oc(Math.round(parseFloat(n) / t) * t * e);
        return (i - (i % 1)) / e + (Sl(n) ? 0 : Vc(n));
      };
    },
    Jc = function (t, e) {
      var n,
        i,
        r = Pl(t);
      return (
        !r &&
          El(t) &&
          ((n = r = t.radius || pl),
          t.values
            ? ((t = jc(t.values)), (i = !Sl(t[0])) && (n *= n))
            : (t = Zc(t.increment))),
        Hc(
          e,
          r
            ? Ml(t)
              ? function (e) {
                  return (i = t(e)), Math.abs(i - e) <= n ? i : e;
                }
              : function (e) {
                  for (
                    var r,
                      s,
                      a = parseFloat(i ? e.x : e),
                      o = parseFloat(i ? e.y : 0),
                      l = pl,
                      c = 0,
                      h = t.length;
                    h--;

                  )
                    (r = i
                      ? (r = t[h].x - a) * r + (s = t[h].y - o) * s
                      : Math.abs(t[h] - a)) < l && ((l = r), (c = h));
                  return (
                    (c = !n || l <= n ? t[c] : e),
                    i || c === e || Sl(e) ? c : c + Vc(e)
                  );
                }
            : Zc(t)
        )
      );
    },
    Qc = function (t, e, n, i) {
      return Hc(Pl(t) ? !e : !0 === n ? !!(n = 0) : !i, function () {
        return Pl(t)
          ? t[~~(Math.random() * t.length)]
          : (n = n || 1e-5) &&
              (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) &&
              Math.floor(
                Math.round(
                  (t - n / 2 + Math.random() * (e - t + 0.99 * n)) / n
                ) *
                  n *
                  i
              ) / i;
      });
    },
    $c = function (t, e, n) {
      return Hc(n, function (n) {
        return t[~~e(n)];
      });
    },
    th = function (t) {
      for (var e, n, i, r, s = 0, a = ""; ~(e = t.indexOf("random(", s)); )
        (i = t.indexOf(")", e)),
          (r = "[" === t.charAt(e + 7)),
          (n = t.substr(e + 7, i - e - 7).match(r ? Ol : Ll)),
          (a +=
            t.substr(s, e - s) +
            Qc(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5)),
          (s = i + 1);
      return a + t.substr(s, t.length - s);
    },
    eh = function (t, e, n, i, r) {
      var s = e - t,
        a = i - n;
      return Hc(r, function (e) {
        return n + (((e - t) / s) * a || 0);
      });
    },
    nh = function (t, e, n) {
      var i,
        r,
        s,
        a = t.labels,
        o = pl;
      for (i in a)
        (r = a[i] - e) < 0 == !!n &&
          r &&
          o > (r = Math.abs(r)) &&
          ((s = i), (o = r));
      return s;
    },
    ih = function (t, e, n) {
      var i,
        r,
        s,
        a = t.vars,
        o = a[e],
        l = Qo,
        c = t._ctx;
      if (o)
        return (
          (i = a[e + "Params"]),
          (r = a.callbackScope || t),
          n && Kl.length && hc(),
          c && (Qo = c),
          (s = i ? o.apply(r, i) : o.call(r)),
          (Qo = l),
          s
        );
    },
    rh = function (t) {
      return (
        Tc(t),
        t.scrollTrigger && t.scrollTrigger.kill(!!Jo),
        t.progress() < 1 && ih(t, "onInterrupt"),
        t
      );
    },
    sh = [],
    ah = function (t) {
      if (Al() && t) {
        var e = (t = (!t.name && t.default) || t).name,
          n = Ml(t),
          i =
            e && !n && t.init
              ? function () {
                  this._props = [];
                }
              : t,
          r = {
            init: Wl,
            render: Jh,
            add: Nh,
            kill: $h,
            modifier: Qh,
            rawVars: 0,
          },
          s = {
            targetTest: 0,
            get: 0,
            getSetter: qh,
            aliases: {},
            register: 0,
          };
        if ((_h(), t !== i)) {
          if (Jl[e]) return;
          fc(i, fc(_c(t, r), s)),
            mc(i.prototype, mc(r, _c(t, s))),
            (Jl[(i.prop = e)] = i),
            t.targetTest && (tc.push(i), (Yl[e] = 1)),
            (e =
              ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) +
              "Plugin");
        }
        Vl(e, i), t.register && t.register(mu, i, nu);
      } else t && sh.push(t);
    },
    oh = 255,
    lh = {
      aqua: [0, oh, oh],
      lime: [0, oh, 0],
      silver: [192, 192, 192],
      black: [0, 0, 0],
      maroon: [128, 0, 0],
      teal: [0, 128, 128],
      blue: [0, 0, oh],
      navy: [0, 0, 128],
      white: [oh, oh, oh],
      olive: [128, 128, 0],
      yellow: [oh, oh, 0],
      orange: [oh, 165, 0],
      gray: [128, 128, 128],
      purple: [128, 0, 128],
      green: [0, 128, 0],
      red: [oh, 0, 0],
      pink: [oh, 192, 203],
      cyan: [0, oh, oh],
      transparent: [oh, oh, oh, 0],
    },
    ch = function (t, e, n) {
      return (
        ((6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1
          ? e + (n - e) * t * 6
          : t < 0.5
          ? n
          : 3 * t < 2
          ? e + (n - e) * (2 / 3 - t) * 6
          : e) *
          oh +
          0.5) |
        0
      );
    },
    hh = function (t, e, n) {
      var i,
        r,
        s,
        a,
        o,
        l,
        c,
        h,
        u,
        d,
        p = t ? (Sl(t) ? [t >> 16, (t >> 8) & oh, t & oh] : 0) : lh.black;
      if (!p) {
        if (("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), lh[t]))
          p = lh[t];
        else if ("#" === t.charAt(0)) {
          if (
            (t.length < 6 &&
              ((i = t.charAt(1)),
              (r = t.charAt(2)),
              (s = t.charAt(3)),
              (t =
                "#" +
                i +
                i +
                r +
                r +
                s +
                s +
                (5 === t.length ? t.charAt(4) + t.charAt(4) : ""))),
            9 === t.length)
          )
            return [
              (p = parseInt(t.substr(1, 6), 16)) >> 16,
              (p >> 8) & oh,
              p & oh,
              parseInt(t.substr(7), 16) / 255,
            ];
          p = [(t = parseInt(t.substr(1), 16)) >> 16, (t >> 8) & oh, t & oh];
        } else if ("hsl" === t.substr(0, 3))
          if (((p = d = t.match(Ll)), e)) {
            if (~t.indexOf("="))
              return (p = t.match(Dl)), n && p.length < 4 && (p[3] = 1), p;
          } else
            (a = (+p[0] % 360) / 360),
              (o = +p[1] / 100),
              (i =
                2 * (l = +p[2] / 100) -
                (r = l <= 0.5 ? l * (o + 1) : l + o - l * o)),
              p.length > 3 && (p[3] *= 1),
              (p[0] = ch(a + 1 / 3, i, r)),
              (p[1] = ch(a, i, r)),
              (p[2] = ch(a - 1 / 3, i, r));
        else p = t.match(Ll) || lh.transparent;
        p = p.map(Number);
      }
      return (
        e &&
          !d &&
          ((i = p[0] / oh),
          (r = p[1] / oh),
          (s = p[2] / oh),
          (l = ((c = Math.max(i, r, s)) + (h = Math.min(i, r, s))) / 2),
          c === h
            ? (a = o = 0)
            : ((u = c - h),
              (o = l > 0.5 ? u / (2 - c - h) : u / (c + h)),
              (a =
                c === i
                  ? (r - s) / u + (r < s ? 6 : 0)
                  : c === r
                  ? (s - i) / u + 2
                  : (i - r) / u + 4),
              (a *= 60)),
          (p[0] = ~~(a + 0.5)),
          (p[1] = ~~(100 * o + 0.5)),
          (p[2] = ~~(100 * l + 0.5))),
        n && p.length < 4 && (p[3] = 1),
        p
      );
    },
    uh = function (t) {
      var e = [],
        n = [],
        i = -1;
      return (
        t.split(ph).forEach(function (t) {
          var r = t.match(Il) || [];
          e.push.apply(e, r), n.push((i += r.length + 1));
        }),
        (e.c = n),
        e
      );
    },
    dh = function (t, e, n) {
      var i,
        r,
        s,
        a,
        o = "",
        l = (t + o).match(ph),
        c = e ? "hsla(" : "rgba(",
        h = 0;
      if (!l) return t;
      if (
        ((l = l.map(function (t) {
          return (
            (t = hh(t, e, 1)) &&
            c +
              (e
                ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3]
                : t.join(",")) +
              ")"
          );
        })),
        n && ((s = uh(t)), (i = n.c).join(o) !== s.c.join(o)))
      )
        for (a = (r = t.replace(ph, "1").split(Il)).length - 1; h < a; h++)
          o +=
            r[h] +
            (~i.indexOf(h)
              ? l.shift() || c + "0,0,0,0)"
              : (s.length ? s : l.length ? l : n).shift());
      if (!r)
        for (a = (r = t.split(ph)).length - 1; h < a; h++) o += r[h] + l[h];
      return o + r[a];
    },
    ph = (function () {
      var t,
        e =
          "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
      for (t in lh) e += "|" + t + "\\b";
      return new RegExp(e + ")", "gi");
    })(),
    fh = /hsl[a]?\(/,
    mh = function (t) {
      var e,
        n = t.join(" ");
      if (((ph.lastIndex = 0), ph.test(n)))
        return (
          (e = fh.test(n)),
          (t[1] = dh(t[1], e)),
          (t[0] = dh(t[0], e, uh(t[1]))),
          !0
        );
    },
    gh = (function () {
      var t,
        e,
        n,
        i,
        r,
        s,
        a = Date.now,
        o = 500,
        l = 33,
        c = a(),
        h = c,
        u = 1e3 / 240,
        d = u,
        p = [],
        f = function n(f) {
          var m,
            g,
            _,
            v,
            y = a() - h,
            x = !0 === f;
          if (
            (y > o && (c += y - l),
            ((m = (_ = (h += y) - c) - d) > 0 || x) &&
              ((v = ++i.frame),
              (r = _ - 1e3 * i.time),
              (i.time = _ /= 1e3),
              (d += m + (m >= u ? 4 : u - m)),
              (g = 1)),
            x || (t = e(n)),
            g)
          )
            for (s = 0; s < p.length; s++) p[s](_, r, v, f);
        };
      return (i = {
        time: 0,
        frame: 0,
        tick: function () {
          f(!0);
        },
        deltaRatio: function (t) {
          return r / (1e3 / (t || 60));
        },
        wake: function () {
          il &&
            (!el &&
              Al() &&
              ((tl = el = window),
              (nl = tl.document || {}),
              (kl.gsap = mu),
              (tl.gsapVersions || (tl.gsapVersions = [])).push(mu.version),
              Bl(zl || tl.GreenSockGlobals || (!tl.gsap && tl) || {}),
              (n = tl.requestAnimationFrame),
              sh.forEach(ah)),
            t && i.sleep(),
            (e =
              n ||
              function (t) {
                return setTimeout(t, (d - 1e3 * i.time + 1) | 0);
              }),
            (al = 1),
            f(2));
        },
        sleep: function () {
          (n ? tl.cancelAnimationFrame : clearTimeout)(t), (al = 0), (e = Wl);
        },
        lagSmoothing: function (t, e) {
          (o = t || 1 / 0), (l = Math.min(e || 33, o));
        },
        fps: function (t) {
          (u = 1e3 / (t || 240)), (d = 1e3 * i.time + u);
        },
        add: function (t, e, n) {
          var r = e
            ? function (e, n, s, a) {
                t(e, n, s, a), i.remove(r);
              }
            : t;
          return i.remove(t), p[n ? "unshift" : "push"](r), _h(), r;
        },
        remove: function (t, e) {
          ~(e = p.indexOf(t)) && p.splice(e, 1) && s >= e && s--;
        },
        _listeners: p,
      });
    })(),
    _h = function () {
      return !al && gh.wake();
    },
    vh = {},
    yh = /^[\d.\-M][\d.\-,\s]/,
    xh = /["']/g,
    Th = function (t) {
      for (
        var e,
          n,
          i,
          r = {},
          s = t.substr(1, t.length - 3).split(":"),
          a = s[0],
          o = 1,
          l = s.length;
        o < l;
        o++
      )
        (n = s[o]),
          (e = o !== l - 1 ? n.lastIndexOf(",") : n.length),
          (i = n.substr(0, e)),
          (r[a] = isNaN(i) ? i.replace(xh, "").trim() : +i),
          (a = n.substr(e + 1).trim());
      return r;
    },
    Mh = function (t) {
      return function (e) {
        return 1 - t(1 - e);
      };
    },
    Sh = function t(e, n) {
      for (var i, r = e._first; r; )
        r instanceof Lh
          ? t(r, n)
          : !r.vars.yoyoEase ||
            (r._yoyo && r._repeat) ||
            r._yoyo === n ||
            (r.timeline
              ? t(r.timeline, n)
              : ((i = r._ease),
                (r._ease = r._yEase),
                (r._yEase = i),
                (r._yoyo = n))),
          (r = r._next);
    },
    bh = function (t, e) {
      return (
        (t &&
          (Ml(t)
            ? t
            : vh[t] ||
              (function (t) {
                var e,
                  n,
                  i,
                  r,
                  s = (t + "").split("("),
                  a = vh[s[0]];
                return a && s.length > 1 && a.config
                  ? a.config.apply(
                      null,
                      ~t.indexOf("{")
                        ? [Th(s[1])]
                        : ((e = t),
                          (n = e.indexOf("(") + 1),
                          (i = e.indexOf(")")),
                          (r = e.indexOf("(", n)),
                          e.substring(
                            n,
                            ~r && r < i ? e.indexOf(")", i + 1) : i
                          ))
                            .split(",")
                            .map(dc)
                    )
                  : vh._CE && yh.test(t)
                  ? vh._CE("", t)
                  : a;
              })(t))) ||
        e
      );
    },
    Eh = function (t, e, n, i) {
      void 0 === n &&
        (n = function (t) {
          return 1 - e(1 - t);
        }),
        void 0 === i &&
          (i = function (t) {
            return t < 0.5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2;
          });
      var r,
        s = { easeIn: e, easeOut: n, easeInOut: i };
      return (
        sc(t, function (t) {
          for (var e in ((vh[t] = kl[t] = s),
          (vh[(r = t.toLowerCase())] = n),
          s))
            vh[
              r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")
            ] = vh[t + "." + e] = s[e];
        }),
        s
      );
    },
    wh = function (t) {
      return function (e) {
        return e < 0.5 ? (1 - t(1 - 2 * e)) / 2 : 0.5 + t(2 * (e - 0.5)) / 2;
      };
    },
    Ah = function t(e, n, i) {
      var r = n >= 1 ? n : 1,
        s = (i || (e ? 0.3 : 0.45)) / (n < 1 ? n : 1),
        a = (s / ml) * (Math.asin(1 / r) || 0),
        o = function (t) {
          return 1 === t ? 1 : r * Math.pow(2, -10 * t) * xl((t - a) * s) + 1;
        },
        l =
          "out" === e
            ? o
            : "in" === e
            ? function (t) {
                return 1 - o(1 - t);
              }
            : wh(o);
      return (
        (s = ml / s),
        (l.config = function (n, i) {
          return t(e, n, i);
        }),
        l
      );
    },
    Rh = function t(e, n) {
      void 0 === n && (n = 1.70158);
      var i = function (t) {
          return t ? --t * t * ((n + 1) * t + n) + 1 : 0;
        },
        r =
          "out" === e
            ? i
            : "in" === e
            ? function (t) {
                return 1 - i(1 - t);
              }
            : wh(i);
      return (
        (r.config = function (n) {
          return t(e, n);
        }),
        r
      );
    };
  sc("Linear,Quad,Cubic,Quart,Quint,Strong", function (t, e) {
    var n = e < 5 ? e + 1 : e;
    Eh(
      t + ",Power" + (n - 1),
      e
        ? function (t) {
            return Math.pow(t, n);
          }
        : function (t) {
            return t;
          },
      function (t) {
        return 1 - Math.pow(1 - t, n);
      },
      function (t) {
        return t < 0.5
          ? Math.pow(2 * t, n) / 2
          : 1 - Math.pow(2 * (1 - t), n) / 2;
      }
    );
  }),
    (vh.Linear.easeNone = vh.none = vh.Linear.easeIn),
    Eh("Elastic", Ah("in"), Ah("out"), Ah()),
    (ol = 7.5625),
    (cl = 1 / (ll = 2.75)),
    Eh(
      "Bounce",
      function (t) {
        return 1 - hl(1 - t);
      },
      (hl = function (t) {
        return t < cl
          ? ol * t * t
          : t < 0.7272727272727273
          ? ol * Math.pow(t - 1.5 / ll, 2) + 0.75
          : t < 0.9090909090909092
          ? ol * (t -= 2.25 / ll) * t + 0.9375
          : ol * Math.pow(t - 2.625 / ll, 2) + 0.984375;
      })
    ),
    Eh("Expo", function (t) {
      return t ? Math.pow(2, 10 * (t - 1)) : 0;
    }),
    Eh("Circ", function (t) {
      return -(vl(1 - t * t) - 1);
    }),
    Eh("Sine", function (t) {
      return 1 === t ? 1 : 1 - yl(t * gl);
    }),
    Eh("Back", Rh("in"), Rh("out"), Rh()),
    (vh.SteppedEase =
      vh.steps =
      kl.SteppedEase =
        {
          config: function (t, e) {
            void 0 === t && (t = 1);
            var n = 1 / t,
              i = t + (e ? 0 : 1),
              r = e ? 1 : 0;
            return function (t) {
              return (((i * Gc(0, 0.99999999, t)) | 0) + r) * n;
            };
          },
        }),
    (dl.ease = vh["quad.out"]),
    sc(
      "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
      function (t) {
        return (ec += t + "," + t + "Params,");
      }
    );
  var Ch = function (t, e) {
      (this.id = _l++),
        (t._gsap = this),
        (this.target = t),
        (this.harness = e),
        (this.get = e ? e.get : rc),
        (this.set = e ? e.getSetter : qh);
    },
    Ph = (function () {
      function t(t) {
        (this.vars = t),
          (this._delay = +t.delay || 0),
          (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
            ((this._rDelay = t.repeatDelay || 0),
            (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
          (this._ts = 1),
          Oc(this, +t.duration, 1, 1),
          (this.data = t.data),
          Qo && ((this._ctx = Qo), Qo.data.push(this)),
          al || gh.wake();
      }
      var e = t.prototype;
      return (
        (e.delay = function (t) {
          return t || 0 === t
            ? (this.parent &&
                this.parent.smoothChildTiming &&
                this.startTime(this._start + t - this._delay),
              (this._delay = t),
              this)
            : this._delay;
        }),
        (e.duration = function (t) {
          return arguments.length
            ? this.totalDuration(
                this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t
              )
            : this.totalDuration() && this._dur;
        }),
        (e.totalDuration = function (t) {
          return arguments.length
            ? ((this._dirty = 0),
              Oc(
                this,
                this._repeat < 0
                  ? t
                  : (t - this._repeat * this._rDelay) / (this._repeat + 1)
              ))
            : this._tDur;
        }),
        (e.totalTime = function (t, e) {
          if ((_h(), !arguments.length)) return this._tTime;
          var n = this._dp;
          if (n && n.smoothChildTiming && this._ts) {
            for (
              Cc(this, t), !n._dp || n.parent || Pc(n, this);
              n && n.parent;

            )
              n.parent._time !==
                n._start +
                  (n._ts >= 0
                    ? n._tTime / n._ts
                    : (n.totalDuration() - n._tTime) / -n._ts) &&
                n.totalTime(n._tTime, !0),
                (n = n.parent);
            !this.parent &&
              this._dp.autoRemoveChildren &&
              ((this._ts > 0 && t < this._tDur) ||
                (this._ts < 0 && t > 0) ||
                (!this._tDur && !t)) &&
              Lc(this._dp, this, this._start - this._delay);
          }
          return (
            (this._tTime !== t ||
              (!this._dur && !e) ||
              (this._initted && Math.abs(this._zTime) === fl) ||
              (!t && !this._initted && (this.add || this._ptLookup))) &&
              (this._ts || (this._pTime = t), uc(this, t, e)),
            this
          );
        }),
        (e.time = function (t, e) {
          return arguments.length
            ? this.totalTime(
                Math.min(this.totalDuration(), t + Ec(this)) %
                  (this._dur + this._rDelay) || (t ? this._dur : 0),
                e
              )
            : this._time;
        }),
        (e.totalProgress = function (t, e) {
          return arguments.length
            ? this.totalTime(this.totalDuration() * t, e)
            : this.totalDuration()
            ? Math.min(1, this._tTime / this._tDur)
            : this.rawTime() > 0
            ? 1
            : 0;
        }),
        (e.progress = function (t, e) {
          return arguments.length
            ? this.totalTime(
                this.duration() *
                  (!this._yoyo || 1 & this.iteration() ? t : 1 - t) +
                  Ec(this),
                e
              )
            : this.duration()
            ? Math.min(1, this._time / this._dur)
            : this.rawTime() > 0
            ? 1
            : 0;
        }),
        (e.iteration = function (t, e) {
          var n = this.duration() + this._rDelay;
          return arguments.length
            ? this.totalTime(this._time + (t - 1) * n, e)
            : this._repeat
            ? wc(this._tTime, n) + 1
            : 1;
        }),
        (e.timeScale = function (t, e) {
          if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
          if (this._rts === t) return this;
          var n =
            this.parent && this._ts ? Ac(this.parent._time, this) : this._tTime;
          return (
            (this._rts = +t || 0),
            (this._ts = this._ps || -1e-8 === t ? 0 : this._rts),
            this.totalTime(Gc(-Math.abs(this._delay), this._tDur, n), !1 !== e),
            Rc(this),
            (function (t) {
              for (var e = t.parent; e && e.parent; )
                (e._dirty = 1), e.totalDuration(), (e = e.parent);
              return t;
            })(this)
          );
        }),
        (e.paused = function (t) {
          return arguments.length
            ? (this._ps !== t &&
                ((this._ps = t),
                t
                  ? ((this._pTime =
                      this._tTime || Math.max(-this._delay, this.rawTime())),
                    (this._ts = this._act = 0))
                  : (_h(),
                    (this._ts = this._rts),
                    this.totalTime(
                      this.parent && !this.parent.smoothChildTiming
                        ? this.rawTime()
                        : this._tTime || this._pTime,
                      1 === this.progress() &&
                        Math.abs(this._zTime) !== fl &&
                        (this._tTime -= fl)
                    ))),
              this)
            : this._ps;
        }),
        (e.startTime = function (t) {
          if (arguments.length) {
            this._start = t;
            var e = this.parent || this._dp;
            return (
              e && (e._sort || !this.parent) && Lc(e, this, t - this._delay),
              this
            );
          }
          return this._start;
        }),
        (e.endTime = function (t) {
          return (
            this._start +
            (wl(t) ? this.totalDuration() : this.duration()) /
              Math.abs(this._ts || 1)
          );
        }),
        (e.rawTime = function (t) {
          var e = this.parent || this._dp;
          return e
            ? t &&
              (!this._ts ||
                (this._repeat && this._time && this.totalProgress() < 1))
              ? this._tTime % (this._dur + this._rDelay)
              : this._ts
              ? Ac(e.rawTime(t), this)
              : this._tTime
            : this._tTime;
        }),
        (e.revert = function (t) {
          void 0 === t && (t = ql);
          var e = Jo;
          return (
            (Jo = t),
            (this._initted || this._startAt) &&
              (this.timeline && this.timeline.revert(t),
              this.totalTime(-0.01, t.suppressEvents)),
            "nested" !== this.data && !1 !== t.kill && this.kill(),
            (Jo = e),
            this
          );
        }),
        (e.globalTime = function (t) {
          for (var e = this, n = arguments.length ? t : e.rawTime(); e; )
            (n = e._start + n / (Math.abs(e._ts) || 1)), (e = e._dp);
          return !this.parent && this._sat ? this._sat.globalTime(t) : n;
        }),
        (e.repeat = function (t) {
          return arguments.length
            ? ((this._repeat = t === 1 / 0 ? -2 : t), Fc(this))
            : -2 === this._repeat
            ? 1 / 0
            : this._repeat;
        }),
        (e.repeatDelay = function (t) {
          if (arguments.length) {
            var e = this._time;
            return (this._rDelay = t), Fc(this), e ? this.time(e) : this;
          }
          return this._rDelay;
        }),
        (e.yoyo = function (t) {
          return arguments.length ? ((this._yoyo = t), this) : this._yoyo;
        }),
        (e.seek = function (t, e) {
          return this.totalTime(zc(this, t), wl(e));
        }),
        (e.restart = function (t, e) {
          return this.play().totalTime(t ? -this._delay : 0, wl(e));
        }),
        (e.play = function (t, e) {
          return null != t && this.seek(t, e), this.reversed(!1).paused(!1);
        }),
        (e.reverse = function (t, e) {
          return (
            null != t && this.seek(t || this.totalDuration(), e),
            this.reversed(!0).paused(!1)
          );
        }),
        (e.pause = function (t, e) {
          return null != t && this.seek(t, e), this.paused(!0);
        }),
        (e.resume = function () {
          return this.paused(!1);
        }),
        (e.reversed = function (t) {
          return arguments.length
            ? (!!t !== this.reversed() &&
                this.timeScale(-this._rts || (t ? -1e-8 : 0)),
              this)
            : this._rts < 0;
        }),
        (e.invalidate = function () {
          return (this._initted = this._act = 0), (this._zTime = -1e-8), this;
        }),
        (e.isActive = function () {
          var t,
            e = this.parent || this._dp,
            n = this._start;
          return !(
            e &&
            !(
              this._ts &&
              this._initted &&
              e.isActive() &&
              (t = e.rawTime(!0)) >= n &&
              t < this.endTime(!0) - fl
            )
          );
        }),
        (e.eventCallback = function (t, e, n) {
          var i = this.vars;
          return arguments.length > 1
            ? (e
                ? ((i[t] = e),
                  n && (i[t + "Params"] = n),
                  "onUpdate" === t && (this._onUpdate = e))
                : delete i[t],
              this)
            : i[t];
        }),
        (e.then = function (t) {
          var e = this;
          return new Promise(function (n) {
            var i = Ml(t) ? t : pc,
              r = function () {
                var t = e.then;
                (e.then = null),
                  Ml(i) && (i = i(e)) && (i.then || i === e) && (e.then = t),
                  n(i),
                  (e.then = t);
              };
            (e._initted && 1 === e.totalProgress() && e._ts >= 0) ||
            (!e._tTime && e._ts < 0)
              ? r()
              : (e._prom = r);
          });
        }),
        (e.kill = function () {
          rh(this);
        }),
        t
      );
    })();
  fc(Ph.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -1e-8,
    _prom: 0,
    _ps: !1,
    _rts: 1,
  });
  var Lh = (function (t) {
    function e(e, n) {
      var i;
      return (
        void 0 === e && (e = {}),
        ((i = t.call(this, e) || this).labels = {}),
        (i.smoothChildTiming = !!e.smoothChildTiming),
        (i.autoRemoveChildren = !!e.autoRemoveChildren),
        (i._sort = wl(e.sortChildren)),
        $o && Lc(e.parent || $o, Yo(i), n),
        e.reversed && i.reverse(),
        e.paused && i.paused(!0),
        e.scrollTrigger && Dc(Yo(i), e.scrollTrigger),
        i
      );
    }
    Ko(e, t);
    var n = e.prototype;
    return (
      (n.to = function (t, e, n) {
        return Bc(0, arguments, this), this;
      }),
      (n.from = function (t, e, n) {
        return Bc(1, arguments, this), this;
      }),
      (n.fromTo = function (t, e, n, i) {
        return Bc(2, arguments, this), this;
      }),
      (n.set = function (t, e, n) {
        return (
          (e.duration = 0),
          (e.parent = this),
          vc(e).repeatDelay || (e.repeat = 0),
          (e.immediateRender = !!e.immediateRender),
          new Gh(t, e, zc(this, n), 1),
          this
        );
      }),
      (n.call = function (t, e, n) {
        return Lc(this, Gh.delayedCall(0, t, e), n);
      }),
      (n.staggerTo = function (t, e, n, i, r, s, a) {
        return (
          (n.duration = e),
          (n.stagger = n.stagger || i),
          (n.onComplete = s),
          (n.onCompleteParams = a),
          (n.parent = this),
          new Gh(t, n, zc(this, r)),
          this
        );
      }),
      (n.staggerFrom = function (t, e, n, i, r, s, a) {
        return (
          (n.runBackwards = 1),
          (vc(n).immediateRender = wl(n.immediateRender)),
          this.staggerTo(t, e, n, i, r, s, a)
        );
      }),
      (n.staggerFromTo = function (t, e, n, i, r, s, a, o) {
        return (
          (i.startAt = n),
          (vc(i).immediateRender = wl(i.immediateRender)),
          this.staggerTo(t, e, i, r, s, a, o)
        );
      }),
      (n.render = function (t, e, n) {
        var i,
          r,
          s,
          a,
          o,
          l,
          c,
          h,
          u,
          d,
          p,
          f,
          m = this._time,
          g = this._dirty ? this.totalDuration() : this._tDur,
          _ = this._dur,
          v = t <= 0 ? 0 : oc(t),
          y = this._zTime < 0 != t < 0 && (this._initted || !_);
        if (
          (this !== $o && v > g && t >= 0 && (v = g),
          v !== this._tTime || n || y)
        ) {
          if (
            (m !== this._time &&
              _ &&
              ((v += this._time - m), (t += this._time - m)),
            (i = v),
            (u = this._start),
            (l = !(h = this._ts)),
            y && (_ || (m = this._zTime), (t || !e) && (this._zTime = t)),
            this._repeat)
          ) {
            if (
              ((p = this._yoyo),
              (o = _ + this._rDelay),
              this._repeat < -1 && t < 0)
            )
              return this.totalTime(100 * o + t, e, n);
            if (
              ((i = oc(v % o)),
              v === g
                ? ((a = this._repeat), (i = _))
                : ((a = ~~(v / o)) && a === v / o && ((i = _), a--),
                  i > _ && (i = _)),
              (d = wc(this._tTime, o)),
              !m &&
                this._tTime &&
                d !== a &&
                this._tTime - d * o - this._dur <= 0 &&
                (d = a),
              p && 1 & a && ((i = _ - i), (f = 1)),
              a !== d && !this._lock)
            ) {
              var x = p && 1 & d,
                T = x === (p && 1 & a);
              if (
                (a < d && (x = !x),
                (m = x ? 0 : v % _ ? _ : v),
                (this._lock = 1),
                (this.render(m || (f ? 0 : oc(a * o)), e, !_)._lock = 0),
                (this._tTime = v),
                !e && this.parent && ih(this, "onRepeat"),
                this.vars.repeatRefresh && !f && (this.invalidate()._lock = 1),
                (m && m !== this._time) ||
                  l !== !this._ts ||
                  (this.vars.onRepeat && !this.parent && !this._act))
              )
                return this;
              if (
                ((_ = this._dur),
                (g = this._tDur),
                T &&
                  ((this._lock = 2),
                  (m = x ? _ : -1e-4),
                  this.render(m, !0),
                  this.vars.repeatRefresh && !f && this.invalidate()),
                (this._lock = 0),
                !this._ts && !l)
              )
                return this;
              Sh(this, f);
            }
          }
          if (
            (this._hasPause &&
              !this._forcing &&
              this._lock < 2 &&
              ((c = (function (t, e, n) {
                var i;
                if (n > e)
                  for (i = t._first; i && i._start <= n; ) {
                    if ("isPause" === i.data && i._start > e) return i;
                    i = i._next;
                  }
                else
                  for (i = t._last; i && i._start >= n; ) {
                    if ("isPause" === i.data && i._start < e) return i;
                    i = i._prev;
                  }
              })(this, oc(m), oc(i))),
              c && (v -= i - (i = c._start))),
            (this._tTime = v),
            (this._time = i),
            (this._act = !h),
            this._initted ||
              ((this._onUpdate = this.vars.onUpdate),
              (this._initted = 1),
              (this._zTime = t),
              (m = 0)),
            !m && i && !e && !a && (ih(this, "onStart"), this._tTime !== v))
          )
            return this;
          if (i >= m && t >= 0)
            for (r = this._first; r; ) {
              if (
                ((s = r._next), (r._act || i >= r._start) && r._ts && c !== r)
              ) {
                if (r.parent !== this) return this.render(t, e, n);
                if (
                  (r.render(
                    r._ts > 0
                      ? (i - r._start) * r._ts
                      : (r._dirty ? r.totalDuration() : r._tDur) +
                          (i - r._start) * r._ts,
                    e,
                    n
                  ),
                  i !== this._time || (!this._ts && !l))
                ) {
                  (c = 0), s && (v += this._zTime = -1e-8);
                  break;
                }
              }
              r = s;
            }
          else {
            r = this._last;
            for (var M = t < 0 ? t : i; r; ) {
              if (
                ((s = r._prev), (r._act || M <= r._end) && r._ts && c !== r)
              ) {
                if (r.parent !== this) return this.render(t, e, n);
                if (
                  (r.render(
                    r._ts > 0
                      ? (M - r._start) * r._ts
                      : (r._dirty ? r.totalDuration() : r._tDur) +
                          (M - r._start) * r._ts,
                    e,
                    n || (Jo && (r._initted || r._startAt))
                  ),
                  i !== this._time || (!this._ts && !l))
                ) {
                  (c = 0), s && (v += this._zTime = M ? -1e-8 : fl);
                  break;
                }
              }
              r = s;
            }
          }
          if (
            c &&
            !e &&
            (this.pause(),
            (c.render(i >= m ? 0 : -1e-8)._zTime = i >= m ? 1 : -1),
            this._ts)
          )
            return (this._start = u), Rc(this), this.render(t, e, n);
          this._onUpdate && !e && ih(this, "onUpdate", !0),
            ((v === g && this._tTime >= this.totalDuration()) || (!v && m)) &&
              ((u !== this._start && Math.abs(h) === Math.abs(this._ts)) ||
                this._lock ||
                ((t || !_) &&
                  ((v === g && this._ts > 0) || (!v && this._ts < 0)) &&
                  Tc(this, 1),
                e ||
                  (t < 0 && !m) ||
                  (!v && !m && g) ||
                  (ih(
                    this,
                    v === g && t >= 0 ? "onComplete" : "onReverseComplete",
                    !0
                  ),
                  this._prom &&
                    !(v < g && this.timeScale() > 0) &&
                    this._prom())));
        }
        return this;
      }),
      (n.add = function (t, e) {
        var n = this;
        if ((Sl(e) || (e = zc(this, e, t)), !(t instanceof Ph))) {
          if (Pl(t))
            return (
              t.forEach(function (t) {
                return n.add(t, e);
              }),
              this
            );
          if (Tl(t)) return this.addLabel(t, e);
          if (!Ml(t)) return this;
          t = Gh.delayedCall(0, t);
        }
        return this !== t ? Lc(this, t, e) : this;
      }),
      (n.getChildren = function (t, e, n, i) {
        void 0 === t && (t = !0),
          void 0 === e && (e = !0),
          void 0 === n && (n = !0),
          void 0 === i && (i = -pl);
        for (var r = [], s = this._first; s; )
          s._start >= i &&
            (s instanceof Gh
              ? e && r.push(s)
              : (n && r.push(s),
                t && r.push.apply(r, s.getChildren(!0, e, n)))),
            (s = s._next);
        return r;
      }),
      (n.getById = function (t) {
        for (var e = this.getChildren(1, 1, 1), n = e.length; n--; )
          if (e[n].vars.id === t) return e[n];
      }),
      (n.remove = function (t) {
        return Tl(t)
          ? this.removeLabel(t)
          : Ml(t)
          ? this.killTweensOf(t)
          : (xc(this, t),
            t === this._recent && (this._recent = this._last),
            Mc(this));
      }),
      (n.totalTime = function (e, n) {
        return arguments.length
          ? ((this._forcing = 1),
            !this._dp &&
              this._ts &&
              (this._start = oc(
                gh.time -
                  (this._ts > 0
                    ? e / this._ts
                    : (this.totalDuration() - e) / -this._ts)
              )),
            t.prototype.totalTime.call(this, e, n),
            (this._forcing = 0),
            this)
          : this._tTime;
      }),
      (n.addLabel = function (t, e) {
        return (this.labels[t] = zc(this, e)), this;
      }),
      (n.removeLabel = function (t) {
        return delete this.labels[t], this;
      }),
      (n.addPause = function (t, e, n) {
        var i = Gh.delayedCall(0, e || Wl, n);
        return (
          (i.data = "isPause"), (this._hasPause = 1), Lc(this, i, zc(this, t))
        );
      }),
      (n.removePause = function (t) {
        var e = this._first;
        for (t = zc(this, t); e; )
          e._start === t && "isPause" === e.data && Tc(e), (e = e._next);
      }),
      (n.killTweensOf = function (t, e, n) {
        for (var i = this.getTweensOf(t, n), r = i.length; r--; )
          Dh !== i[r] && i[r].kill(t, e);
        return this;
      }),
      (n.getTweensOf = function (t, e) {
        for (var n, i = [], r = jc(t), s = this._first, a = Sl(e); s; )
          s instanceof Gh
            ? cc(s._targets, r) &&
              (a
                ? (!Dh || (s._initted && s._ts)) &&
                  s.globalTime(0) <= e &&
                  s.globalTime(s.totalDuration()) > e
                : !e || s.isActive()) &&
              i.push(s)
            : (n = s.getTweensOf(r, e)).length && i.push.apply(i, n),
            (s = s._next);
        return i;
      }),
      (n.tweenTo = function (t, e) {
        e = e || {};
        var n,
          i = this,
          r = zc(i, t),
          s = e,
          a = s.startAt,
          o = s.onStart,
          l = s.onStartParams,
          c = s.immediateRender,
          h = Gh.to(
            i,
            fc(
              {
                ease: e.ease || "none",
                lazy: !1,
                immediateRender: !1,
                time: r,
                overwrite: "auto",
                duration:
                  e.duration ||
                  Math.abs(
                    (r - (a && "time" in a ? a.time : i._time)) / i.timeScale()
                  ) ||
                  fl,
                onStart: function () {
                  if ((i.pause(), !n)) {
                    var t =
                      e.duration ||
                      Math.abs(
                        (r - (a && "time" in a ? a.time : i._time)) /
                          i.timeScale()
                      );
                    h._dur !== t && Oc(h, t, 0, 1).render(h._time, !0, !0),
                      (n = 1);
                  }
                  o && o.apply(h, l || []);
                },
              },
              e
            )
          );
        return c ? h.render(0) : h;
      }),
      (n.tweenFromTo = function (t, e, n) {
        return this.tweenTo(e, fc({ startAt: { time: zc(this, t) } }, n));
      }),
      (n.recent = function () {
        return this._recent;
      }),
      (n.nextLabel = function (t) {
        return void 0 === t && (t = this._time), nh(this, zc(this, t));
      }),
      (n.previousLabel = function (t) {
        return void 0 === t && (t = this._time), nh(this, zc(this, t), 1);
      }),
      (n.currentLabel = function (t) {
        return arguments.length
          ? this.seek(t, !0)
          : this.previousLabel(this._time + fl);
      }),
      (n.shiftChildren = function (t, e, n) {
        void 0 === n && (n = 0);
        for (var i, r = this._first, s = this.labels; r; )
          r._start >= n && ((r._start += t), (r._end += t)), (r = r._next);
        if (e) for (i in s) s[i] >= n && (s[i] += t);
        return Mc(this);
      }),
      (n.invalidate = function (e) {
        var n = this._first;
        for (this._lock = 0; n; ) n.invalidate(e), (n = n._next);
        return t.prototype.invalidate.call(this, e);
      }),
      (n.clear = function (t) {
        void 0 === t && (t = !0);
        for (var e, n = this._first; n; )
          (e = n._next), this.remove(n), (n = e);
        return (
          this._dp && (this._time = this._tTime = this._pTime = 0),
          t && (this.labels = {}),
          Mc(this)
        );
      }),
      (n.totalDuration = function (t) {
        var e,
          n,
          i,
          r = 0,
          s = this,
          a = s._last,
          o = pl;
        if (arguments.length)
          return s.timeScale(
            (s._repeat < 0 ? s.duration() : s.totalDuration()) /
              (s.reversed() ? -t : t)
          );
        if (s._dirty) {
          for (i = s.parent; a; )
            (e = a._prev),
              a._dirty && a.totalDuration(),
              (n = a._start) > o && s._sort && a._ts && !s._lock
                ? ((s._lock = 1), (Lc(s, a, n - a._delay, 1)._lock = 0))
                : (o = n),
              n < 0 &&
                a._ts &&
                ((r -= n),
                ((!i && !s._dp) || (i && i.smoothChildTiming)) &&
                  ((s._start += n / s._ts), (s._time -= n), (s._tTime -= n)),
                s.shiftChildren(-n, !1, -Infinity),
                (o = 0)),
              a._end > r && a._ts && (r = a._end),
              (a = e);
          Oc(s, s === $o && s._time > r ? s._time : r, 1, 1), (s._dirty = 0);
        }
        return s._tDur;
      }),
      (e.updateRoot = function (t) {
        if (($o._ts && (uc($o, Ac(t, $o)), (rl = gh.frame)), gh.frame >= $l)) {
          $l += ul.autoSleep || 120;
          var e = $o._first;
          if ((!e || !e._ts) && ul.autoSleep && gh._listeners.length < 2) {
            for (; e && !e._ts; ) e = e._next;
            e || gh.sleep();
          }
        }
      }),
      e
    );
  })(Ph);
  fc(Lh.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
  var Dh,
    Ih,
    Uh = function (t, e, n, i, r, s, a) {
      var o,
        l,
        c,
        h,
        u,
        d,
        p,
        f,
        m = new nu(this._pt, t, e, 0, 1, Zh, null, r),
        g = 0,
        _ = 0;
      for (
        m.b = n,
          m.e = i,
          n += "",
          (p = ~(i += "").indexOf("random(")) && (i = th(i)),
          s && (s((f = [n, i]), t, e), (n = f[0]), (i = f[1])),
          l = n.match(Ul) || [];
        (o = Ul.exec(i));

      )
        (h = o[0]),
          (u = i.substring(g, o.index)),
          c ? (c = (c + 1) % 5) : "rgba(" === u.substr(-5) && (c = 1),
          h !== l[_++] &&
            ((d = parseFloat(l[_ - 1]) || 0),
            (m._pt = {
              _next: m._pt,
              p: u || 1 === _ ? u : ",",
              s: d,
              c: "=" === h.charAt(1) ? lc(d, h) - d : parseFloat(h) - d,
              m: c && c < 4 ? Math.round : 0,
            }),
            (g = Ul.lastIndex));
      return (
        (m.c = g < i.length ? i.substring(g, i.length) : ""),
        (m.fp = a),
        (Nl.test(i) || p) && (m.e = 0),
        (this._pt = m),
        m
      );
    },
    Nh = function (t, e, n, i, r, s, a, o, l, c) {
      Ml(i) && (i = i(r || 0, t, s));
      var h,
        u = t[e],
        d =
          "get" !== n
            ? n
            : Ml(u)
            ? l
              ? t[
                  e.indexOf("set") || !Ml(t["get" + e.substr(3)])
                    ? e
                    : "get" + e.substr(3)
                ](l)
              : t[e]()
            : u,
        p = Ml(u) ? (l ? Xh : Wh) : Vh;
      if (
        (Tl(i) &&
          (~i.indexOf("random(") && (i = th(i)),
          "=" === i.charAt(1) &&
            ((h = lc(d, i) + (Vc(d) || 0)) || 0 === h) &&
            (i = h)),
        !c || d !== i || Ih)
      )
        return isNaN(d * i) || "" === i
          ? (!u && !(e in t) && Hl(e, i),
            Uh.call(this, t, e, d, i, p, o || ul.stringFilter, l))
          : ((h = new nu(
              this._pt,
              t,
              e,
              +d || 0,
              i - (d || 0),
              "boolean" == typeof u ? Kh : Yh,
              0,
              p
            )),
            l && (h.fp = l),
            a && h.modifier(a, this, t),
            (this._pt = h));
    },
    Oh = function (t, e, n, i, r, s) {
      var a, o, l, c;
      if (
        Jl[t] &&
        !1 !==
          (a = new Jl[t]()).init(
            r,
            a.rawVars
              ? e[t]
              : (function (t, e, n, i, r) {
                  if (
                    (Ml(t) && (t = zh(t, r, e, n, i)),
                    !El(t) || (t.style && t.nodeType) || Pl(t) || Cl(t))
                  )
                    return Tl(t) ? zh(t, r, e, n, i) : t;
                  var s,
                    a = {};
                  for (s in t) a[s] = zh(t[s], r, e, n, i);
                  return a;
                })(e[t], i, r, s, n),
            n,
            i,
            s
          ) &&
        ((n._pt = o = new nu(n._pt, r, t, 0, 1, a.render, a, 0, a.priority)),
        n !== sl)
      )
        for (l = n._ptLookup[n._targets.indexOf(r)], c = a._props.length; c--; )
          l[a._props[c]] = o;
      return a;
    },
    Fh = function t(e, n, i) {
      var r,
        s,
        a,
        o,
        l,
        c,
        h,
        u,
        d,
        p,
        f,
        m,
        g,
        _ = e.vars,
        v = _.ease,
        y = _.startAt,
        x = _.immediateRender,
        T = _.lazy,
        M = _.onUpdate,
        S = _.runBackwards,
        b = _.yoyoEase,
        E = _.keyframes,
        w = _.autoRevert,
        A = e._dur,
        R = e._startAt,
        C = e._targets,
        P = e.parent,
        L = P && "nested" === P.data ? P.vars.targets : C,
        D = "auto" === e._overwrite && !Zo,
        I = e.timeline;
      if (
        (I && (!E || !v) && (v = "none"),
        (e._ease = bh(v, dl.ease)),
        (e._yEase = b ? Mh(bh(!0 === b ? v : b, dl.ease)) : 0),
        b &&
          e._yoyo &&
          !e._repeat &&
          ((b = e._yEase), (e._yEase = e._ease), (e._ease = b)),
        (e._from = !I && !!_.runBackwards),
        !I || (E && !_.stagger))
      ) {
        if (
          ((m = (u = C[0] ? ic(C[0]).harness : 0) && _[u.prop]),
          (r = _c(_, Yl)),
          R &&
            (R._zTime < 0 && R.progress(1),
            n < 0 && S && x && !w
              ? R.render(-1, !0)
              : R.revert(S && A ? jl : Xl),
            (R._lazy = 0)),
          y)
        ) {
          if (
            (Tc(
              (e._startAt = Gh.set(
                C,
                fc(
                  {
                    data: "isStart",
                    overwrite: !1,
                    parent: P,
                    immediateRender: !0,
                    lazy: !R && wl(T),
                    startAt: null,
                    delay: 0,
                    onUpdate:
                      M &&
                      function () {
                        return ih(e, "onUpdate");
                      },
                    stagger: 0,
                  },
                  y
                )
              ))
            ),
            (e._startAt._dp = 0),
            (e._startAt._sat = e),
            n < 0 && (Jo || (!x && !w)) && e._startAt.revert(jl),
            x && A && n <= 0 && i <= 0)
          )
            return void (n && (e._zTime = n));
        } else if (S && A && !R)
          if (
            (n && (x = !1),
            (a = fc(
              {
                overwrite: !1,
                data: "isFromStart",
                lazy: x && !R && wl(T),
                immediateRender: x,
                stagger: 0,
                parent: P,
              },
              r
            )),
            m && (a[u.prop] = m),
            Tc((e._startAt = Gh.set(C, a))),
            (e._startAt._dp = 0),
            (e._startAt._sat = e),
            n < 0 && (Jo ? e._startAt.revert(jl) : e._startAt.render(-1, !0)),
            (e._zTime = n),
            x)
          ) {
            if (!n) return;
          } else t(e._startAt, fl, fl);
        for (
          e._pt = e._ptCache = 0, T = (A && wl(T)) || (T && !A), s = 0;
          s < C.length;
          s++
        ) {
          if (
            ((h = (l = C[s])._gsap || nc(C)[s]._gsap),
            (e._ptLookup[s] = p = {}),
            Zl[h.id] && Kl.length && hc(),
            (f = L === C ? s : L.indexOf(l)),
            u &&
              !1 !== (d = new u()).init(l, m || r, e, f, L) &&
              ((e._pt = o =
                new nu(e._pt, l, d.name, 0, 1, d.render, d, 0, d.priority)),
              d._props.forEach(function (t) {
                p[t] = o;
              }),
              d.priority && (c = 1)),
            !u || m)
          )
            for (a in r)
              Jl[a] && (d = Oh(a, r, e, f, l, L))
                ? d.priority && (c = 1)
                : (p[a] = o =
                    Nh.call(e, l, a, "get", r[a], f, L, 0, _.stringFilter));
          e._op && e._op[s] && e.kill(l, e._op[s]),
            D &&
              e._pt &&
              ((Dh = e),
              $o.killTweensOf(l, p, e.globalTime(n)),
              (g = !e.parent),
              (Dh = 0)),
            e._pt && T && (Zl[h.id] = 1);
        }
        c && eu(e), e._onInit && e._onInit(e);
      }
      (e._onUpdate = M),
        (e._initted = (!e._op || e._pt) && !g),
        E && n <= 0 && I.render(pl, !0, !0);
    },
    kh = function (t, e, n, i) {
      var r,
        s,
        a = e.ease || i || "power1.inOut";
      if (Pl(e))
        (s = n[t] || (n[t] = [])),
          e.forEach(function (t, n) {
            return s.push({ t: (n / (e.length - 1)) * 100, v: t, e: a });
          });
      else
        for (r in e)
          (s = n[r] || (n[r] = [])),
            "ease" === r || s.push({ t: parseFloat(t), v: e[r], e: a });
    },
    zh = function (t, e, n, i, r) {
      return Ml(t)
        ? t.call(e, n, i, r)
        : Tl(t) && ~t.indexOf("random(")
        ? th(t)
        : t;
    },
    Bh = ec + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
    Hh = {};
  sc(Bh + ",id,stagger,delay,duration,paused,scrollTrigger", function (t) {
    return (Hh[t] = 1);
  });
  var Gh = (function (t) {
    function e(e, n, i, r) {
      var s;
      "number" == typeof n && ((i.duration = n), (n = i), (i = null));
      var a,
        o,
        l,
        c,
        h,
        u,
        d,
        p,
        f = (s = t.call(this, r ? n : vc(n)) || this).vars,
        m = f.duration,
        g = f.delay,
        _ = f.immediateRender,
        v = f.stagger,
        y = f.overwrite,
        x = f.keyframes,
        T = f.defaults,
        M = f.scrollTrigger,
        S = f.yoyoEase,
        b = n.parent || $o,
        E = (Pl(e) || Cl(e) ? Sl(e[0]) : "length" in n) ? [e] : jc(e);
      if (
        ((s._targets = E.length
          ? nc(E)
          : Gl(
              "GSAP target " + e + " not found. https://gsap.com",
              !ul.nullTargetWarn
            ) || []),
        (s._ptLookup = []),
        (s._overwrite = y),
        x || v || Rl(m) || Rl(g))
      ) {
        if (
          ((n = s.vars),
          (a = s.timeline =
            new Lh({
              data: "nested",
              defaults: T || {},
              targets: b && "nested" === b.data ? b.vars.targets : E,
            })).kill(),
          (a.parent = a._dp = Yo(s)),
          (a._start = 0),
          v || Rl(m) || Rl(g))
        ) {
          if (((c = E.length), (d = v && Kc(v)), El(v)))
            for (h in v) ~Bh.indexOf(h) && (p || (p = {}), (p[h] = v[h]));
          for (o = 0; o < c; o++)
            ((l = _c(n, Hh)).stagger = 0),
              S && (l.yoyoEase = S),
              p && mc(l, p),
              (u = E[o]),
              (l.duration = +zh(m, Yo(s), o, u, E)),
              (l.delay = (+zh(g, Yo(s), o, u, E) || 0) - s._delay),
              !v &&
                1 === c &&
                l.delay &&
                ((s._delay = g = l.delay), (s._start += g), (l.delay = 0)),
              a.to(u, l, d ? d(o, u, E) : 0),
              (a._ease = vh.none);
          a.duration() ? (m = g = 0) : (s.timeline = 0);
        } else if (x) {
          vc(fc(a.vars.defaults, { ease: "none" })),
            (a._ease = bh(x.ease || n.ease || "none"));
          var w,
            A,
            R,
            C = 0;
          if (Pl(x))
            x.forEach(function (t) {
              return a.to(E, t, ">");
            }),
              a.duration();
          else {
            for (h in ((l = {}), x))
              "ease" === h || "easeEach" === h || kh(h, x[h], l, x.easeEach);
            for (h in l)
              for (
                w = l[h].sort(function (t, e) {
                  return t.t - e.t;
                }),
                  C = 0,
                  o = 0;
                o < w.length;
                o++
              )
                ((R = {
                  ease: (A = w[o]).e,
                  duration: ((A.t - (o ? w[o - 1].t : 0)) / 100) * m,
                })[h] = A.v),
                  a.to(E, R, C),
                  (C += R.duration);
            a.duration() < m && a.to({}, { duration: m - a.duration() });
          }
        }
        m || s.duration((m = a.duration()));
      } else s.timeline = 0;
      return (
        !0 !== y || Zo || ((Dh = Yo(s)), $o.killTweensOf(E), (Dh = 0)),
        Lc(b, Yo(s), i),
        n.reversed && s.reverse(),
        n.paused && s.paused(!0),
        (_ ||
          (!m &&
            !x &&
            s._start === oc(b._time) &&
            wl(_) &&
            bc(Yo(s)) &&
            "nested" !== b.data)) &&
          ((s._tTime = -1e-8), s.render(Math.max(0, -g) || 0)),
        M && Dc(Yo(s), M),
        s
      );
    }
    Ko(e, t);
    var n = e.prototype;
    return (
      (n.render = function (t, e, n) {
        var i,
          r,
          s,
          a,
          o,
          l,
          c,
          h,
          u,
          d = this._time,
          p = this._tDur,
          f = this._dur,
          m = t < 0,
          g = t > p - fl && !m ? p : t < fl ? 0 : t;
        if (f) {
          if (
            g !== this._tTime ||
            !t ||
            n ||
            (!this._initted && this._tTime) ||
            (this._startAt && this._zTime < 0 !== m)
          ) {
            if (((i = g), (h = this.timeline), this._repeat)) {
              if (((a = f + this._rDelay), this._repeat < -1 && m))
                return this.totalTime(100 * a + t, e, n);
              if (
                ((i = oc(g % a)),
                g === p
                  ? ((s = this._repeat), (i = f))
                  : ((s = ~~(g / a)) && s === oc(g / a) && ((i = f), s--),
                    i > f && (i = f)),
                (l = this._yoyo && 1 & s) && ((u = this._yEase), (i = f - i)),
                (o = wc(this._tTime, a)),
                i === d && !n && this._initted && s === o)
              )
                return (this._tTime = g), this;
              s !== o &&
                (h && this._yEase && Sh(h, l),
                this.vars.repeatRefresh &&
                  !l &&
                  !this._lock &&
                  this._time !== f &&
                  this._initted &&
                  ((this._lock = n = 1),
                  (this.render(oc(a * s), !0).invalidate()._lock = 0)));
            }
            if (!this._initted) {
              if (Ic(this, m ? t : i, n, e, g)) return (this._tTime = 0), this;
              if (
                !(d === this._time || (n && this.vars.repeatRefresh && s !== o))
              )
                return this;
              if (f !== this._dur) return this.render(t, e, n);
            }
            if (
              ((this._tTime = g),
              (this._time = i),
              !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
              (this.ratio = c = (u || this._ease)(i / f)),
              this._from && (this.ratio = c = 1 - c),
              i && !d && !e && !s && (ih(this, "onStart"), this._tTime !== g))
            )
              return this;
            for (r = this._pt; r; ) r.r(c, r.d), (r = r._next);
            (h &&
              h.render(
                t < 0 ? t : !i && l ? -1e-8 : h._dur * h._ease(i / this._dur),
                e,
                n
              )) ||
              (this._startAt && (this._zTime = t)),
              this._onUpdate &&
                !e &&
                (m && Sc(this, t, 0, n), ih(this, "onUpdate")),
              this._repeat &&
                s !== o &&
                this.vars.onRepeat &&
                !e &&
                this.parent &&
                ih(this, "onRepeat"),
              (g !== this._tDur && g) ||
                this._tTime !== g ||
                (m && !this._onUpdate && Sc(this, t, 0, !0),
                (t || !f) &&
                  ((g === this._tDur && this._ts > 0) ||
                    (!g && this._ts < 0)) &&
                  Tc(this, 1),
                e ||
                  (m && !d) ||
                  !(g || d || l) ||
                  (ih(this, g === p ? "onComplete" : "onReverseComplete", !0),
                  this._prom &&
                    !(g < p && this.timeScale() > 0) &&
                    this._prom()));
          }
        } else
          !(function (t, e, n, i) {
            var r,
              s,
              a,
              o = t.ratio,
              l =
                e < 0 ||
                (!e &&
                  ((!t._start && Uc(t) && (t._initted || !Nc(t))) ||
                    ((t._ts < 0 || t._dp._ts < 0) && !Nc(t))))
                  ? 0
                  : 1,
              c = t._rDelay,
              h = 0;
            if (
              (c &&
                t._repeat &&
                ((h = Gc(0, t._tDur, e)),
                (s = wc(h, c)),
                t._yoyo && 1 & s && (l = 1 - l),
                s !== wc(t._tTime, c) &&
                  ((o = 1 - l),
                  t.vars.repeatRefresh && t._initted && t.invalidate())),
              l !== o || Jo || i || t._zTime === fl || (!e && t._zTime))
            ) {
              if (!t._initted && Ic(t, e, i, n, h)) return;
              for (
                a = t._zTime,
                  t._zTime = e || (n ? fl : 0),
                  n || (n = e && !a),
                  t.ratio = l,
                  t._from && (l = 1 - l),
                  t._time = 0,
                  t._tTime = h,
                  r = t._pt;
                r;

              )
                r.r(l, r.d), (r = r._next);
              e < 0 && Sc(t, e, 0, !0),
                t._onUpdate && !n && ih(t, "onUpdate"),
                h && t._repeat && !n && t.parent && ih(t, "onRepeat"),
                (e >= t._tDur || e < 0) &&
                  t.ratio === l &&
                  (l && Tc(t, 1),
                  n ||
                    Jo ||
                    (ih(t, l ? "onComplete" : "onReverseComplete", !0),
                    t._prom && t._prom()));
            } else t._zTime || (t._zTime = e);
          })(this, t, e, n);
        return this;
      }),
      (n.targets = function () {
        return this._targets;
      }),
      (n.invalidate = function (e) {
        return (
          (!e || !this.vars.runBackwards) && (this._startAt = 0),
          (this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0),
          (this._ptLookup = []),
          this.timeline && this.timeline.invalidate(e),
          t.prototype.invalidate.call(this, e)
        );
      }),
      (n.resetTo = function (t, e, n, i, r) {
        al || gh.wake(), this._ts || this.play();
        var s = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
        return (
          this._initted || Fh(this, s),
          (function (t, e, n, i, r, s, a, o) {
            var l,
              c,
              h,
              u,
              d = ((t._pt && t._ptCache) || (t._ptCache = {}))[e];
            if (!d)
              for (
                d = t._ptCache[e] = [], h = t._ptLookup, u = t._targets.length;
                u--;

              ) {
                if ((l = h[u][e]) && l.d && l.d._pt)
                  for (l = l.d._pt; l && l.p !== e && l.fp !== e; ) l = l._next;
                if (!l)
                  return (
                    (Ih = 1),
                    (t.vars[e] = "+=0"),
                    Fh(t, a),
                    (Ih = 0),
                    o ? Gl(e + " not eligible for reset") : 1
                  );
                d.push(l);
              }
            for (u = d.length; u--; )
              ((l = (c = d[u])._pt || c).s =
                (!i && 0 !== i) || r ? l.s + (i || 0) + s * l.c : i),
                (l.c = n - l.s),
                c.e && (c.e = ac(n) + Vc(c.e)),
                c.b && (c.b = l.s + Vc(c.b));
          })(this, t, e, n, i, this._ease(s / this._dur), s, r)
            ? this.resetTo(t, e, n, i, 1)
            : (Cc(this, 0),
              this.parent ||
                yc(
                  this._dp,
                  this,
                  "_first",
                  "_last",
                  this._dp._sort ? "_start" : 0
                ),
              this.render(0))
        );
      }),
      (n.kill = function (t, e) {
        if ((void 0 === e && (e = "all"), !(t || (e && "all" !== e))))
          return (this._lazy = this._pt = 0), this.parent ? rh(this) : this;
        if (this.timeline) {
          var n = this.timeline.totalDuration();
          return (
            this.timeline.killTweensOf(t, e, Dh && !0 !== Dh.vars.overwrite)
              ._first || rh(this),
            this.parent &&
              n !== this.timeline.totalDuration() &&
              Oc(this, (this._dur * this.timeline._tDur) / n, 0, 1),
            this
          );
        }
        var i,
          r,
          s,
          a,
          o,
          l,
          c,
          h = this._targets,
          u = t ? jc(t) : h,
          d = this._ptLookup,
          p = this._pt;
        if (
          (!e || "all" === e) &&
          (function (t, e) {
            for (
              var n = t.length, i = n === e.length;
              i && n-- && t[n] === e[n];

            );
            return n < 0;
          })(h, u)
        )
          return "all" === e && (this._pt = 0), rh(this);
        for (
          i = this._op = this._op || [],
            "all" !== e &&
              (Tl(e) &&
                ((o = {}),
                sc(e, function (t) {
                  return (o[t] = 1);
                }),
                (e = o)),
              (e = (function (t, e) {
                var n,
                  i,
                  r,
                  s,
                  a = t[0] ? ic(t[0]).harness : 0,
                  o = a && a.aliases;
                if (!o) return e;
                for (i in ((n = mc({}, e)), o))
                  if ((i in n))
                    for (r = (s = o[i].split(",")).length; r--; )
                      n[s[r]] = n[i];
                return n;
              })(h, e))),
            c = h.length;
          c--;

        )
          if (~u.indexOf(h[c]))
            for (o in ((r = d[c]),
            "all" === e
              ? ((i[c] = e), (a = r), (s = {}))
              : ((s = i[c] = i[c] || {}), (a = e)),
            a))
              (l = r && r[o]) &&
                (("kill" in l.d && !0 !== l.d.kill(o)) || xc(this, l, "_pt"),
                delete r[o]),
                "all" !== s && (s[o] = 1);
        return this._initted && !this._pt && p && rh(this), this;
      }),
      (e.to = function (t, n) {
        return new e(t, n, arguments[2]);
      }),
      (e.from = function (t, e) {
        return Bc(1, arguments);
      }),
      (e.delayedCall = function (t, n, i, r) {
        return new e(n, 0, {
          immediateRender: !1,
          lazy: !1,
          overwrite: !1,
          delay: t,
          onComplete: n,
          onReverseComplete: n,
          onCompleteParams: i,
          onReverseCompleteParams: i,
          callbackScope: r,
        });
      }),
      (e.fromTo = function (t, e, n) {
        return Bc(2, arguments);
      }),
      (e.set = function (t, n) {
        return (n.duration = 0), n.repeatDelay || (n.repeat = 0), new e(t, n);
      }),
      (e.killTweensOf = function (t, e, n) {
        return $o.killTweensOf(t, e, n);
      }),
      e
    );
  })(Ph);
  fc(Gh.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }),
    sc("staggerTo,staggerFrom,staggerFromTo", function (t) {
      Gh[t] = function () {
        var e = new Lh(),
          n = Wc.call(arguments, 0);
        return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n);
      };
    });
  var Vh = function (t, e, n) {
      return (t[e] = n);
    },
    Wh = function (t, e, n) {
      return t[e](n);
    },
    Xh = function (t, e, n, i) {
      return t[e](i.fp, n);
    },
    jh = function (t, e, n) {
      return t.setAttribute(e, n);
    },
    qh = function (t, e) {
      return Ml(t[e]) ? Wh : bl(t[e]) && t.setAttribute ? jh : Vh;
    },
    Yh = function (t, e) {
      return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e);
    },
    Kh = function (t, e) {
      return e.set(e.t, e.p, !!(e.s + e.c * t), e);
    },
    Zh = function (t, e) {
      var n = e._pt,
        i = "";
      if (!t && e.b) i = e.b;
      else if (1 === t && e.e) i = e.e;
      else {
        for (; n; )
          (i =
            n.p +
            (n.m
              ? n.m(n.s + n.c * t)
              : Math.round(1e4 * (n.s + n.c * t)) / 1e4) +
            i),
            (n = n._next);
        i += e.c;
      }
      e.set(e.t, e.p, i, e);
    },
    Jh = function (t, e) {
      for (var n = e._pt; n; ) n.r(t, n.d), (n = n._next);
    },
    Qh = function (t, e, n, i) {
      for (var r, s = this._pt; s; )
        (r = s._next), s.p === i && s.modifier(t, e, n), (s = r);
    },
    $h = function (t) {
      for (var e, n, i = this._pt; i; )
        (n = i._next),
          (i.p === t && !i.op) || i.op === t
            ? xc(this, i, "_pt")
            : i.dep || (e = 1),
          (i = n);
      return !e;
    },
    tu = function (t, e, n, i) {
      i.mSet(t, e, i.m.call(i.tween, n, i.mt), i);
    },
    eu = function (t) {
      for (var e, n, i, r, s = t._pt; s; ) {
        for (e = s._next, n = i; n && n.pr > s.pr; ) n = n._next;
        (s._prev = n ? n._prev : r) ? (s._prev._next = s) : (i = s),
          (s._next = n) ? (n._prev = s) : (r = s),
          (s = e);
      }
      t._pt = i;
    },
    nu = (function () {
      function t(t, e, n, i, r, s, a, o, l) {
        (this.t = e),
          (this.s = i),
          (this.c = r),
          (this.p = n),
          (this.r = s || Yh),
          (this.d = a || this),
          (this.set = o || Vh),
          (this.pr = l || 0),
          (this._next = t),
          t && (t._prev = this);
      }
      return (
        (t.prototype.modifier = function (t, e, n) {
          (this.mSet = this.mSet || this.set),
            (this.set = tu),
            (this.m = t),
            (this.mt = n),
            (this.tween = e);
        }),
        t
      );
    })();
  sc(
    ec +
      "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
    function (t) {
      return (Yl[t] = 1);
    }
  ),
    (kl.TweenMax = kl.TweenLite = Gh),
    (kl.TimelineLite = kl.TimelineMax = Lh),
    ($o = new Lh({
      sortChildren: !1,
      defaults: dl,
      autoRemoveChildren: !0,
      id: "root",
      smoothChildTiming: !0,
    })),
    (ul.stringFilter = mh);
  var iu = [],
    ru = {},
    su = [],
    au = 0,
    ou = 0,
    lu = function (t) {
      return (ru[t] || su).map(function (t) {
        return t();
      });
    },
    cu = function () {
      var t = Date.now(),
        e = [];
      t - au > 2 &&
        (lu("matchMediaInit"),
        iu.forEach(function (t) {
          var n,
            i,
            r,
            s,
            a = t.queries,
            o = t.conditions;
          for (i in a)
            (n = tl.matchMedia(a[i]).matches) && (r = 1),
              n !== o[i] && ((o[i] = n), (s = 1));
          s && (t.revert(), r && e.push(t));
        }),
        lu("matchMediaRevert"),
        e.forEach(function (t) {
          return t.onMatch(t, function (e) {
            return t.add(null, e);
          });
        }),
        (au = t),
        lu("matchMedia"));
    },
    hu = (function () {
      function t(t, e) {
        (this.selector = e && qc(e)),
          (this.data = []),
          (this._r = []),
          (this.isReverted = !1),
          (this.id = ou++),
          t && this.add(t);
      }
      var e = t.prototype;
      return (
        (e.add = function (t, e, n) {
          Ml(t) && ((n = e), (e = t), (t = Ml));
          var i = this,
            r = function () {
              var t,
                r = Qo,
                s = i.selector;
              return (
                r && r !== i && r.data.push(i),
                n && (i.selector = qc(n)),
                (Qo = i),
                (t = e.apply(i, arguments)),
                Ml(t) && i._r.push(t),
                (Qo = r),
                (i.selector = s),
                (i.isReverted = !1),
                t
              );
            };
          return (
            (i.last = r),
            t === Ml
              ? r(i, function (t) {
                  return i.add(null, t);
                })
              : t
              ? (i[t] = r)
              : r
          );
        }),
        (e.ignore = function (t) {
          var e = Qo;
          (Qo = null), t(this), (Qo = e);
        }),
        (e.getTweens = function () {
          var e = [];
          return (
            this.data.forEach(function (n) {
              return n instanceof t
                ? e.push.apply(e, n.getTweens())
                : n instanceof Gh &&
                    !(n.parent && "nested" === n.parent.data) &&
                    e.push(n);
            }),
            e
          );
        }),
        (e.clear = function () {
          this._r.length = this.data.length = 0;
        }),
        (e.kill = function (t, e) {
          var n = this;
          if (
            (t
              ? (function () {
                  for (var e, i = n.getTweens(), r = n.data.length; r--; )
                    "isFlip" === (e = n.data[r]).data &&
                      (e.revert(),
                      e.getChildren(!0, !0, !1).forEach(function (t) {
                        return i.splice(i.indexOf(t), 1);
                      }));
                  for (
                    i
                      .map(function (t) {
                        return {
                          g:
                            t._dur ||
                            t._delay ||
                            (t._sat && !t._sat.vars.immediateRender)
                              ? t.globalTime(0)
                              : -1 / 0,
                          t,
                        };
                      })
                      .sort(function (t, e) {
                        return e.g - t.g || -1 / 0;
                      })
                      .forEach(function (e) {
                        return e.t.revert(t);
                      }),
                      r = n.data.length;
                    r--;

                  )
                    (e = n.data[r]) instanceof Lh
                      ? "nested" !== e.data &&
                        (e.scrollTrigger && e.scrollTrigger.revert(), e.kill())
                      : !(e instanceof Gh) && e.revert && e.revert(t);
                  n._r.forEach(function (e) {
                    return e(t, n);
                  }),
                    (n.isReverted = !0);
                })()
              : this.data.forEach(function (t) {
                  return t.kill && t.kill();
                }),
            this.clear(),
            e)
          )
            for (var i = iu.length; i--; )
              iu[i].id === this.id && iu.splice(i, 1);
        }),
        (e.revert = function (t) {
          this.kill(t || {});
        }),
        t
      );
    })(),
    uu = (function () {
      function t(t) {
        (this.contexts = []), (this.scope = t);
      }
      var e = t.prototype;
      return (
        (e.add = function (t, e, n) {
          El(t) || (t = { matches: t });
          var i,
            r,
            s,
            a = new hu(0, n || this.scope),
            o = (a.conditions = {});
          for (r in (Qo && !a.selector && (a.selector = Qo.selector),
          this.contexts.push(a),
          (e = a.add("onMatch", e)),
          (a.queries = t),
          t))
            "all" === r
              ? (s = 1)
              : (i = tl.matchMedia(t[r])) &&
                (iu.indexOf(a) < 0 && iu.push(a),
                (o[r] = i.matches) && (s = 1),
                i.addListener
                  ? i.addListener(cu)
                  : i.addEventListener("change", cu));
          return (
            s &&
              e(a, function (t) {
                return a.add(null, t);
              }),
            this
          );
        }),
        (e.revert = function (t) {
          this.kill(t || {});
        }),
        (e.kill = function (t) {
          this.contexts.forEach(function (e) {
            return e.kill(t, !0);
          });
        }),
        t
      );
    })(),
    du = {
      registerPlugin: function () {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        e.forEach(function (t) {
          return ah(t);
        });
      },
      timeline: function (t) {
        return new Lh(t);
      },
      getTweensOf: function (t, e) {
        return $o.getTweensOf(t, e);
      },
      getProperty: function (t, e, n, i) {
        Tl(t) && (t = jc(t)[0]);
        var r = ic(t || {}).get,
          s = n ? pc : dc;
        return (
          "native" === n && (n = ""),
          t
            ? e
              ? s(((Jl[e] && Jl[e].get) || r)(t, e, n, i))
              : function (e, n, i) {
                  return s(((Jl[e] && Jl[e].get) || r)(t, e, n, i));
                }
            : t
        );
      },
      quickSetter: function (t, e, n) {
        if ((t = jc(t)).length > 1) {
          var i = t.map(function (t) {
              return mu.quickSetter(t, e, n);
            }),
            r = i.length;
          return function (t) {
            for (var e = r; e--; ) i[e](t);
          };
        }
        t = t[0] || {};
        var s = Jl[e],
          a = ic(t),
          o = (a.harness && (a.harness.aliases || {})[e]) || e,
          l = s
            ? function (e) {
                var i = new s();
                (sl._pt = 0),
                  i.init(t, n ? e + n : e, sl, 0, [t]),
                  i.render(1, i),
                  sl._pt && Jh(1, sl);
              }
            : a.set(t, o);
        return s
          ? l
          : function (e) {
              return l(t, o, n ? e + n : e, a, 1);
            };
      },
      quickTo: function (t, e, n) {
        var i,
          r = mu.to(
            t,
            mc((((i = {})[e] = "+=0.1"), (i.paused = !0), i), n || {})
          ),
          s = function (t, n, i) {
            return r.resetTo(e, t, n, i);
          };
        return (s.tween = r), s;
      },
      isTweening: function (t) {
        return $o.getTweensOf(t, !0).length > 0;
      },
      defaults: function (t) {
        return t && t.ease && (t.ease = bh(t.ease, dl.ease)), gc(dl, t || {});
      },
      config: function (t) {
        return gc(ul, t || {});
      },
      registerEffect: function (t) {
        var e = t.name,
          n = t.effect,
          i = t.plugins,
          r = t.defaults,
          s = t.extendTimeline;
        (i || "").split(",").forEach(function (t) {
          return (
            t &&
            !Jl[t] &&
            !kl[t] &&
            Gl(e + " effect requires " + t + " plugin.")
          );
        }),
          (Ql[e] = function (t, e, i) {
            return n(jc(t), fc(e || {}, r), i);
          }),
          s &&
            (Lh.prototype[e] = function (t, n, i) {
              return this.add(Ql[e](t, El(n) ? n : (i = n) && {}, this), i);
            });
      },
      registerEase: function (t, e) {
        vh[t] = bh(e);
      },
      parseEase: function (t, e) {
        return arguments.length ? bh(t, e) : vh;
      },
      getById: function (t) {
        return $o.getById(t);
      },
      exportRoot: function (t, e) {
        void 0 === t && (t = {});
        var n,
          i,
          r = new Lh(t);
        for (
          r.smoothChildTiming = wl(t.smoothChildTiming),
            $o.remove(r),
            r._dp = 0,
            r._time = r._tTime = $o._time,
            n = $o._first;
          n;

        )
          (i = n._next),
            (!e &&
              !n._dur &&
              n instanceof Gh &&
              n.vars.onComplete === n._targets[0]) ||
              Lc(r, n, n._start - n._delay),
            (n = i);
        return Lc($o, r, 0), r;
      },
      context: function (t, e) {
        return t ? new hu(t, e) : Qo;
      },
      matchMedia: function (t) {
        return new uu(t);
      },
      matchMediaRefresh: function () {
        return (
          iu.forEach(function (t) {
            var e,
              n,
              i = t.conditions;
            for (n in i) i[n] && ((i[n] = !1), (e = 1));
            e && t.revert();
          }) || cu()
        );
      },
      addEventListener: function (t, e) {
        var n = ru[t] || (ru[t] = []);
        ~n.indexOf(e) || n.push(e);
      },
      removeEventListener: function (t, e) {
        var n = ru[t],
          i = n && n.indexOf(e);
        i >= 0 && n.splice(i, 1);
      },
      utils: {
        wrap: function t(e, n, i) {
          var r = n - e;
          return Pl(e)
            ? $c(e, t(0, e.length), n)
            : Hc(i, function (t) {
                return ((r + ((t - e) % r)) % r) + e;
              });
        },
        wrapYoyo: function t(e, n, i) {
          var r = n - e,
            s = 2 * r;
          return Pl(e)
            ? $c(e, t(0, e.length - 1), n)
            : Hc(i, function (t) {
                return e + ((t = (s + ((t - e) % s)) % s || 0) > r ? s - t : t);
              });
        },
        distribute: Kc,
        random: Qc,
        snap: Jc,
        normalize: function (t, e, n) {
          return eh(t, e, 0, 1, n);
        },
        getUnit: Vc,
        clamp: function (t, e, n) {
          return Hc(n, function (n) {
            return Gc(t, e, n);
          });
        },
        splitColor: hh,
        toArray: jc,
        selector: qc,
        mapRange: eh,
        pipe: function () {
          for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
            e[n] = arguments[n];
          return function (t) {
            return e.reduce(function (t, e) {
              return e(t);
            }, t);
          };
        },
        unitize: function (t, e) {
          return function (n) {
            return t(parseFloat(n)) + (e || Vc(n));
          };
        },
        interpolate: function t(e, n, i, r) {
          var s = isNaN(e + n)
            ? 0
            : function (t) {
                return (1 - t) * e + t * n;
              };
          if (!s) {
            var a,
              o,
              l,
              c,
              h,
              u = Tl(e),
              d = {};
            if ((!0 === i && (r = 1) && (i = null), u))
              (e = { p: e }), (n = { p: n });
            else if (Pl(e) && !Pl(n)) {
              for (l = [], c = e.length, h = c - 2, o = 1; o < c; o++)
                l.push(t(e[o - 1], e[o]));
              c--,
                (s = function (t) {
                  t *= c;
                  var e = Math.min(h, ~~t);
                  return l[e](t - e);
                }),
                (i = n);
            } else r || (e = mc(Pl(e) ? [] : {}, e));
            if (!l) {
              for (a in n) Nh.call(d, e, a, "get", n[a]);
              s = function (t) {
                return Jh(t, d) || (u ? e.p : e);
              };
            }
          }
          return Hc(i, s);
        },
        shuffle: Yc,
      },
      install: Bl,
      effects: Ql,
      ticker: gh,
      updateRoot: Lh.updateRoot,
      plugins: Jl,
      globalTimeline: $o,
      core: {
        PropTween: nu,
        globals: Vl,
        Tween: Gh,
        Timeline: Lh,
        Animation: Ph,
        getCache: ic,
        _removeLinkedListItem: xc,
        reverting: function () {
          return Jo;
        },
        context: function (t) {
          return t && Qo && (Qo.data.push(t), (t._ctx = Qo)), Qo;
        },
        suppressOverwrites: function (t) {
          return (Zo = t);
        },
      },
    };
  sc("to,from,fromTo,delayedCall,set,killTweensOf", function (t) {
    return (du[t] = Gh[t]);
  }),
    gh.add(Lh.updateRoot),
    (sl = du.to({}, { duration: 0 }));
  var pu = function (t, e) {
      for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e; )
        n = n._next;
      return n;
    },
    fu = function (t, e) {
      return {
        name: t,
        rawVars: 1,
        init: function (t, n, i) {
          i._onInit = function (t) {
            var i, r;
            if (
              (Tl(n) &&
                ((i = {}),
                sc(n, function (t) {
                  return (i[t] = 1);
                }),
                (n = i)),
              e)
            ) {
              for (r in ((i = {}), n)) i[r] = e(n[r]);
              n = i;
            }
            !(function (t, e) {
              var n,
                i,
                r,
                s = t._targets;
              for (n in e)
                for (i = s.length; i--; )
                  (r = t._ptLookup[i][n]) &&
                    (r = r.d) &&
                    (r._pt && (r = pu(r, n)),
                    r && r.modifier && r.modifier(e[n], t, s[i], n));
            })(t, n);
          };
        },
      };
    },
    mu =
      du.registerPlugin(
        {
          name: "attr",
          init: function (t, e, n, i, r) {
            var s, a, o;
            for (s in ((this.tween = n), e))
              (o = t.getAttribute(s) || ""),
                ((a = this.add(
                  t,
                  "setAttribute",
                  (o || 0) + "",
                  e[s],
                  i,
                  r,
                  0,
                  0,
                  s
                )).op = s),
                (a.b = o),
                this._props.push(s);
          },
          render: function (t, e) {
            for (var n = e._pt; n; )
              Jo ? n.set(n.t, n.p, n.b, n) : n.r(t, n.d), (n = n._next);
          },
        },
        {
          name: "endArray",
          init: function (t, e) {
            for (var n = e.length; n--; )
              this.add(t, n, t[n] || 0, e[n], 0, 0, 0, 0, 0, 1);
          },
        },
        fu("roundProps", Zc),
        fu("modifiers"),
        fu("snap", Jc)
      ) || du;
  (Gh.version = Lh.version = mu.version = "3.12.4"),
    (il = 1),
    Al() && _h(),
    vh.Power0,
    vh.Power1,
    vh.Power2,
    vh.Power3;
  var gu,
    _u,
    vu,
    yu,
    xu,
    Tu,
    Mu,
    Su,
    bu = vh.Power4,
    Eu =
      (vh.Linear,
      vh.Quad,
      vh.Cubic,
      vh.Quart,
      vh.Quint,
      vh.Strong,
      vh.Elastic,
      vh.Back,
      vh.SteppedEase,
      vh.Bounce,
      vh.Sine,
      vh.Expo),
    wu = (vh.Circ, {}),
    Au = 180 / Math.PI,
    Ru = Math.PI / 180,
    Cu = Math.atan2,
    Pu = /([A-Z])/g,
    Lu = /(left|right|width|margin|padding|x)/i,
    Du = /[\s,\(]\S/,
    Iu = {
      autoAlpha: "opacity,visibility",
      scale: "scaleX,scaleY",
      alpha: "opacity",
    },
    Uu = function (t, e) {
      return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e);
    },
    Nu = function (t, e) {
      return e.set(
        e.t,
        e.p,
        1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u,
        e
      );
    },
    Ou = function (t, e) {
      return e.set(
        e.t,
        e.p,
        t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b,
        e
      );
    },
    Fu = function (t, e) {
      var n = e.s + e.c * t;
      e.set(e.t, e.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + e.u, e);
    },
    ku = function (t, e) {
      return e.set(e.t, e.p, t ? e.e : e.b, e);
    },
    zu = function (t, e) {
      return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e);
    },
    Bu = function (t, e, n) {
      return (t.style[e] = n);
    },
    Hu = function (t, e, n) {
      return t.style.setProperty(e, n);
    },
    Gu = function (t, e, n) {
      return (t._gsap[e] = n);
    },
    Vu = function (t, e, n) {
      return (t._gsap.scaleX = t._gsap.scaleY = n);
    },
    Wu = function (t, e, n, i, r) {
      var s = t._gsap;
      (s.scaleX = s.scaleY = n), s.renderTransform(r, s);
    },
    Xu = function (t, e, n, i, r) {
      var s = t._gsap;
      (s[e] = n), s.renderTransform(r, s);
    },
    ju = "transform",
    qu = ju + "Origin",
    Yu = function t(e, n) {
      var i = this,
        r = this.target,
        s = r.style,
        a = r._gsap;
      if (e in wu && s) {
        if (((this.tfm = this.tfm || {}), "transform" === e))
          return Iu.transform.split(",").forEach(function (e) {
            return t.call(i, e, n);
          });
        if (
          (~(e = Iu[e] || e).indexOf(",")
            ? e.split(",").forEach(function (t) {
                return (i.tfm[t] = dd(r, t));
              })
            : (this.tfm[e] = a.x ? a[e] : dd(r, e)),
          e === qu && (this.tfm.zOrigin = a.zOrigin),
          this.props.indexOf(ju) >= 0)
        )
          return;
        a.svg &&
          ((this.svgo = r.getAttribute("data-svg-origin")),
          this.props.push(qu, n, "")),
          (e = ju);
      }
      (s || n) && this.props.push(e, n, s[e]);
    },
    Ku = function (t) {
      t.translate &&
        (t.removeProperty("translate"),
        t.removeProperty("scale"),
        t.removeProperty("rotate"));
    },
    Zu = function () {
      var t,
        e,
        n = this.props,
        i = this.target,
        r = i.style,
        s = i._gsap;
      for (t = 0; t < n.length; t += 3)
        n[t + 1]
          ? (i[n[t]] = n[t + 2])
          : n[t + 2]
          ? (r[n[t]] = n[t + 2])
          : r.removeProperty(
              "--" === n[t].substr(0, 2)
                ? n[t]
                : n[t].replace(Pu, "-$1").toLowerCase()
            );
      if (this.tfm) {
        for (e in this.tfm) s[e] = this.tfm[e];
        s.svg &&
          (s.renderTransform(),
          i.setAttribute("data-svg-origin", this.svgo || "")),
          ((t = Mu()) && t.isStart) ||
            r[ju] ||
            (Ku(r),
            s.zOrigin &&
              r[qu] &&
              ((r[qu] += " " + s.zOrigin + "px"),
              (s.zOrigin = 0),
              s.renderTransform()),
            (s.uncache = 1));
      }
    },
    Ju = function (t, e) {
      var n = { target: t, props: [], revert: Zu, save: Yu };
      return (
        t._gsap || mu.core.getCache(t),
        e &&
          e.split(",").forEach(function (t) {
            return n.save(t);
          }),
        n
      );
    },
    Qu = function (t, e) {
      var n = _u.createElementNS
        ? _u.createElementNS(
            (e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
            t
          )
        : _u.createElement(t);
      return n && n.style ? n : _u.createElement(t);
    },
    $u = function t(e, n, i) {
      var r = getComputedStyle(e);
      return (
        r[n] ||
        r.getPropertyValue(n.replace(Pu, "-$1").toLowerCase()) ||
        r.getPropertyValue(n) ||
        (!i && t(e, ed(n) || n, 1)) ||
        ""
      );
    },
    td = "O,Moz,ms,Ms,Webkit".split(","),
    ed = function (t, e, n) {
      var i = (e || xu).style,
        r = 5;
      if (t in i && !n) return t;
      for (
        t = t.charAt(0).toUpperCase() + t.substr(1);
        r-- && !(td[r] + t in i);

      );
      return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? td[r] : "") + t;
    },
    nd = function () {
      "undefined" != typeof window &&
        window.document &&
        ((gu = window),
        (_u = gu.document),
        (vu = _u.documentElement),
        (xu = Qu("div") || { style: {} }),
        Qu("div"),
        (ju = ed(ju)),
        (qu = ju + "Origin"),
        (xu.style.cssText =
          "border-width:0;line-height:0;position:absolute;padding:0"),
        (Su = !!ed("perspective")),
        (Mu = mu.core.reverting),
        (yu = 1));
    },
    id = function t(e) {
      var n,
        i = Qu(
          "svg",
          (this.ownerSVGElement &&
            this.ownerSVGElement.getAttribute("xmlns")) ||
            "http://www.w3.org/2000/svg"
        ),
        r = this.parentNode,
        s = this.nextSibling,
        a = this.style.cssText;
      if (
        (vu.appendChild(i),
        i.appendChild(this),
        (this.style.display = "block"),
        e)
      )
        try {
          (n = this.getBBox()),
            (this._gsapBBox = this.getBBox),
            (this.getBBox = t);
        } catch (t) {}
      else this._gsapBBox && (n = this._gsapBBox());
      return (
        r && (s ? r.insertBefore(this, s) : r.appendChild(this)),
        vu.removeChild(i),
        (this.style.cssText = a),
        n
      );
    },
    rd = function (t, e) {
      for (var n = e.length; n--; )
        if (t.hasAttribute(e[n])) return t.getAttribute(e[n]);
    },
    sd = function (t) {
      var e;
      try {
        e = t.getBBox();
      } catch (n) {
        e = id.call(t, !0);
      }
      return (
        (e && (e.width || e.height)) ||
          t.getBBox === id ||
          (e = id.call(t, !0)),
        !e || e.width || e.x || e.y
          ? e
          : {
              x: +rd(t, ["x", "cx", "x1"]) || 0,
              y: +rd(t, ["y", "cy", "y1"]) || 0,
              width: 0,
              height: 0,
            }
      );
    },
    ad = function (t) {
      return !(!t.getCTM || (t.parentNode && !t.ownerSVGElement) || !sd(t));
    },
    od = function (t, e) {
      if (e) {
        var n,
          i = t.style;
        e in wu && e !== qu && (e = ju),
          i.removeProperty
            ? (("ms" !== (n = e.substr(0, 2)) && "webkit" !== e.substr(0, 6)) ||
                (e = "-" + e),
              i.removeProperty(
                "--" === n ? e : e.replace(Pu, "-$1").toLowerCase()
              ))
            : i.removeAttribute(e);
      }
    },
    ld = function (t, e, n, i, r, s) {
      var a = new nu(t._pt, e, n, 0, 1, s ? zu : ku);
      return (t._pt = a), (a.b = i), (a.e = r), t._props.push(n), a;
    },
    cd = { deg: 1, rad: 1, turn: 1 },
    hd = { grid: 1, flex: 1 },
    ud = function t(e, n, i, r) {
      var s,
        a,
        o,
        l,
        c = parseFloat(i) || 0,
        h = (i + "").trim().substr((c + "").length) || "px",
        u = xu.style,
        d = Lu.test(n),
        p = "svg" === e.tagName.toLowerCase(),
        f = (p ? "client" : "offset") + (d ? "Width" : "Height"),
        m = 100,
        g = "px" === r,
        _ = "%" === r;
      if (r === h || !c || cd[r] || cd[h]) return c;
      if (
        ("px" !== h && !g && (c = t(e, n, i, "px")),
        (l = e.getCTM && ad(e)),
        (_ || "%" === h) && (wu[n] || ~n.indexOf("adius")))
      )
        return (
          (s = l ? e.getBBox()[d ? "width" : "height"] : e[f]),
          ac(_ ? (c / s) * m : (c / 100) * s)
        );
      if (
        ((u[d ? "width" : "height"] = m + (g ? h : r)),
        (a =
          ~n.indexOf("adius") || ("em" === r && e.appendChild && !p)
            ? e
            : e.parentNode),
        l && (a = (e.ownerSVGElement || {}).parentNode),
        (a && a !== _u && a.appendChild) || (a = _u.body),
        (o = a._gsap) && _ && o.width && d && o.time === gh.time && !o.uncache)
      )
        return ac((c / o.width) * m);
      if (!_ || ("height" !== n && "width" !== n))
        (_ || "%" === h) &&
          !hd[$u(a, "display")] &&
          (u.position = $u(e, "position")),
          a === e && (u.position = "static"),
          a.appendChild(xu),
          (s = xu[f]),
          a.removeChild(xu),
          (u.position = "absolute");
      else {
        var v = e.style[n];
        (e.style[n] = m + r), (s = e[f]), v ? (e.style[n] = v) : od(e, n);
      }
      return (
        d && _ && (((o = ic(a)).time = gh.time), (o.width = a[f])),
        ac(g ? (s * c) / m : s && c ? (m / s) * c : 0)
      );
    },
    dd = function (t, e, n, i) {
      var r;
      return (
        yu || nd(),
        e in Iu &&
          "transform" !== e &&
          ~(e = Iu[e]).indexOf(",") &&
          (e = e.split(",")[0]),
        wu[e] && "transform" !== e
          ? ((r = Sd(t, i)),
            (r =
              "transformOrigin" !== e
                ? r[e]
                : r.svg
                ? r.origin
                : bd($u(t, qu)) + " " + r.zOrigin + "px"))
          : (!(r = t.style[e]) ||
              "auto" === r ||
              i ||
              ~(r + "").indexOf("calc(")) &&
            (r =
              (gd[e] && gd[e](t, e, n)) ||
              $u(t, e) ||
              rc(t, e) ||
              ("opacity" === e ? 1 : 0)),
        n && !~(r + "").trim().indexOf(" ") ? ud(t, e, r, n) + n : r
      );
    },
    pd = function (t, e, n, i) {
      if (!n || "none" === n) {
        var r = ed(e, t, 1),
          s = r && $u(t, r, 1);
        s && s !== n
          ? ((e = r), (n = s))
          : "borderColor" === e && (n = $u(t, "borderTopColor"));
      }
      var a,
        o,
        l,
        c,
        h,
        u,
        d,
        p,
        f,
        m,
        g,
        _ = new nu(this._pt, t.style, e, 0, 1, Zh),
        v = 0,
        y = 0;
      if (
        ((_.b = n),
        (_.e = i),
        (n += ""),
        "auto" == (i += "") &&
          ((u = t.style[e]),
          (t.style[e] = i),
          (i = $u(t, e) || i),
          u ? (t.style[e] = u) : od(t, e)),
        mh((a = [n, i])),
        (i = a[1]),
        (l = (n = a[0]).match(Il) || []),
        (i.match(Il) || []).length)
      ) {
        for (; (o = Il.exec(i)); )
          (d = o[0]),
            (f = i.substring(v, o.index)),
            h
              ? (h = (h + 1) % 5)
              : ("rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5)) ||
                (h = 1),
            d !== (u = l[y++] || "") &&
              ((c = parseFloat(u) || 0),
              (g = u.substr((c + "").length)),
              "=" === d.charAt(1) && (d = lc(c, d) + g),
              (p = parseFloat(d)),
              (m = d.substr((p + "").length)),
              (v = Il.lastIndex - m.length),
              m ||
                ((m = m || ul.units[e] || g),
                v === i.length && ((i += m), (_.e += m))),
              g !== m && (c = ud(t, e, u, m) || 0),
              (_._pt = {
                _next: _._pt,
                p: f || 1 === y ? f : ",",
                s: c,
                c: p - c,
                m: (h && h < 4) || "zIndex" === e ? Math.round : 0,
              }));
        _.c = v < i.length ? i.substring(v, i.length) : "";
      } else _.r = "display" === e && "none" === i ? zu : ku;
      return Nl.test(i) && (_.e = 0), (this._pt = _), _;
    },
    fd = {
      top: "0%",
      bottom: "100%",
      left: "0%",
      right: "100%",
      center: "50%",
    },
    md = function (t, e) {
      if (e.tween && e.tween._time === e.tween._dur) {
        var n,
          i,
          r,
          s = e.t,
          a = s.style,
          o = e.u,
          l = s._gsap;
        if ("all" === o || !0 === o) (a.cssText = ""), (i = 1);
        else
          for (r = (o = o.split(",")).length; --r > -1; )
            (n = o[r]),
              wu[n] && ((i = 1), (n = "transformOrigin" === n ? qu : ju)),
              od(s, n);
        i &&
          (od(s, ju),
          l &&
            (l.svg && s.removeAttribute("transform"),
            Sd(s, 1),
            (l.uncache = 1),
            Ku(a)));
      }
    },
    gd = {
      clearProps: function (t, e, n, i, r) {
        if ("isFromStart" !== r.data) {
          var s = (t._pt = new nu(t._pt, e, n, 0, 0, md));
          return (s.u = i), (s.pr = -10), (s.tween = r), t._props.push(n), 1;
        }
      },
    },
    _d = [1, 0, 0, 1, 0, 0],
    vd = {},
    yd = function (t) {
      return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t;
    },
    xd = function (t) {
      var e = $u(t, ju);
      return yd(e) ? _d : e.substr(7).match(Dl).map(ac);
    },
    Td = function (t, e) {
      var n,
        i,
        r,
        s,
        a = t._gsap || ic(t),
        o = t.style,
        l = xd(t);
      return a.svg && t.getAttribute("transform")
        ? "1,0,0,1,0,0" ===
          (l = [
            (r = t.transform.baseVal.consolidate().matrix).a,
            r.b,
            r.c,
            r.d,
            r.e,
            r.f,
          ]).join(",")
          ? _d
          : l
        : (l !== _d ||
            t.offsetParent ||
            t === vu ||
            a.svg ||
            ((r = o.display),
            (o.display = "block"),
            ((n = t.parentNode) && t.offsetParent) ||
              ((s = 1), (i = t.nextElementSibling), vu.appendChild(t)),
            (l = xd(t)),
            r ? (o.display = r) : od(t, "display"),
            s &&
              (i
                ? n.insertBefore(t, i)
                : n
                ? n.appendChild(t)
                : vu.removeChild(t))),
          e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l);
    },
    Md = function (t, e, n, i, r, s) {
      var a,
        o,
        l,
        c = t._gsap,
        h = r || Td(t, !0),
        u = c.xOrigin || 0,
        d = c.yOrigin || 0,
        p = c.xOffset || 0,
        f = c.yOffset || 0,
        m = h[0],
        g = h[1],
        _ = h[2],
        v = h[3],
        y = h[4],
        x = h[5],
        T = e.split(" "),
        M = parseFloat(T[0]) || 0,
        S = parseFloat(T[1]) || 0;
      n
        ? h !== _d &&
          (o = m * v - g * _) &&
          ((l = M * (-g / o) + S * (m / o) - (m * x - g * y) / o),
          (M = M * (v / o) + S * (-_ / o) + (_ * x - v * y) / o),
          (S = l))
        : ((M = (a = sd(t)).x + (~T[0].indexOf("%") ? (M / 100) * a.width : M)),
          (S =
            a.y + (~(T[1] || T[0]).indexOf("%") ? (S / 100) * a.height : S))),
        i || (!1 !== i && c.smooth)
          ? ((y = M - u),
            (x = S - d),
            (c.xOffset = p + (y * m + x * _) - y),
            (c.yOffset = f + (y * g + x * v) - x))
          : (c.xOffset = c.yOffset = 0),
        (c.xOrigin = M),
        (c.yOrigin = S),
        (c.smooth = !!i),
        (c.origin = e),
        (c.originIsAbsolute = !!n),
        (t.style[qu] = "0px 0px"),
        s &&
          (ld(s, c, "xOrigin", u, M),
          ld(s, c, "yOrigin", d, S),
          ld(s, c, "xOffset", p, c.xOffset),
          ld(s, c, "yOffset", f, c.yOffset)),
        t.setAttribute("data-svg-origin", M + " " + S);
    },
    Sd = function (t, e) {
      var n = t._gsap || new Ch(t);
      if ("x" in n && !e && !n.uncache) return n;
      var i,
        r,
        s,
        a,
        o,
        l,
        c,
        h,
        u,
        d,
        p,
        f,
        m,
        g,
        _,
        v,
        y,
        x,
        T,
        M,
        S,
        b,
        E,
        w,
        A,
        R,
        C,
        P,
        L,
        D,
        I,
        U,
        N = t.style,
        O = n.scaleX < 0,
        F = "px",
        k = "deg",
        z = getComputedStyle(t),
        B = $u(t, qu) || "0";
      return (
        (i = r = s = l = c = h = u = d = p = 0),
        (a = o = 1),
        (n.svg = !(!t.getCTM || !ad(t))),
        z.translate &&
          (("none" === z.translate &&
            "none" === z.scale &&
            "none" === z.rotate) ||
            (N[ju] =
              ("none" !== z.translate
                ? "translate3d(" +
                  (z.translate + " 0 0").split(" ").slice(0, 3).join(", ") +
                  ") "
                : "") +
              ("none" !== z.rotate ? "rotate(" + z.rotate + ") " : "") +
              ("none" !== z.scale
                ? "scale(" + z.scale.split(" ").join(",") + ") "
                : "") +
              ("none" !== z[ju] ? z[ju] : "")),
          (N.scale = N.rotate = N.translate = "none")),
        (g = Td(t, n.svg)),
        n.svg &&
          (n.uncache
            ? ((A = t.getBBox()),
              (B = n.xOrigin - A.x + "px " + (n.yOrigin - A.y) + "px"),
              (w = ""))
            : (w = !e && t.getAttribute("data-svg-origin")),
          Md(t, w || B, !!w || n.originIsAbsolute, !1 !== n.smooth, g)),
        (f = n.xOrigin || 0),
        (m = n.yOrigin || 0),
        g !== _d &&
          ((x = g[0]),
          (T = g[1]),
          (M = g[2]),
          (S = g[3]),
          (i = b = g[4]),
          (r = E = g[5]),
          6 === g.length
            ? ((a = Math.sqrt(x * x + T * T)),
              (o = Math.sqrt(S * S + M * M)),
              (l = x || T ? Cu(T, x) * Au : 0),
              (u = M || S ? Cu(M, S) * Au + l : 0) &&
                (o *= Math.abs(Math.cos(u * Ru))),
              n.svg && ((i -= f - (f * x + m * M)), (r -= m - (f * T + m * S))))
            : ((U = g[6]),
              (D = g[7]),
              (C = g[8]),
              (P = g[9]),
              (L = g[10]),
              (I = g[11]),
              (i = g[12]),
              (r = g[13]),
              (s = g[14]),
              (c = (_ = Cu(U, L)) * Au),
              _ &&
                ((w = b * (v = Math.cos(-_)) + C * (y = Math.sin(-_))),
                (A = E * v + P * y),
                (R = U * v + L * y),
                (C = b * -y + C * v),
                (P = E * -y + P * v),
                (L = U * -y + L * v),
                (I = D * -y + I * v),
                (b = w),
                (E = A),
                (U = R)),
              (h = (_ = Cu(-M, L)) * Au),
              _ &&
                ((v = Math.cos(-_)),
                (I = S * (y = Math.sin(-_)) + I * v),
                (x = w = x * v - C * y),
                (T = A = T * v - P * y),
                (M = R = M * v - L * y)),
              (l = (_ = Cu(T, x)) * Au),
              _ &&
                ((w = x * (v = Math.cos(_)) + T * (y = Math.sin(_))),
                (A = b * v + E * y),
                (T = T * v - x * y),
                (E = E * v - b * y),
                (x = w),
                (b = A)),
              c &&
                Math.abs(c) + Math.abs(l) > 359.9 &&
                ((c = l = 0), (h = 180 - h)),
              (a = ac(Math.sqrt(x * x + T * T + M * M))),
              (o = ac(Math.sqrt(E * E + U * U))),
              (_ = Cu(b, E)),
              (u = Math.abs(_) > 2e-4 ? _ * Au : 0),
              (p = I ? 1 / (I < 0 ? -I : I) : 0)),
          n.svg &&
            ((w = t.getAttribute("transform")),
            (n.forceCSS = t.setAttribute("transform", "") || !yd($u(t, ju))),
            w && t.setAttribute("transform", w))),
        Math.abs(u) > 90 &&
          Math.abs(u) < 270 &&
          (O
            ? ((a *= -1),
              (u += l <= 0 ? 180 : -180),
              (l += l <= 0 ? 180 : -180))
            : ((o *= -1), (u += u <= 0 ? 180 : -180))),
        (e = e || n.uncache),
        (n.x =
          i -
          ((n.xPercent =
            i &&
            ((!e && n.xPercent) ||
              (Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0)))
            ? (t.offsetWidth * n.xPercent) / 100
            : 0) +
          F),
        (n.y =
          r -
          ((n.yPercent =
            r &&
            ((!e && n.yPercent) ||
              (Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0)))
            ? (t.offsetHeight * n.yPercent) / 100
            : 0) +
          F),
        (n.z = s + F),
        (n.scaleX = ac(a)),
        (n.scaleY = ac(o)),
        (n.rotation = ac(l) + k),
        (n.rotationX = ac(c) + k),
        (n.rotationY = ac(h) + k),
        (n.skewX = u + k),
        (n.skewY = d + k),
        (n.transformPerspective = p + F),
        (n.zOrigin = parseFloat(B.split(" ")[2]) || (!e && n.zOrigin) || 0) &&
          (N[qu] = bd(B)),
        (n.xOffset = n.yOffset = 0),
        (n.force3D = ul.force3D),
        (n.renderTransform = n.svg ? Ld : Su ? Pd : wd),
        (n.uncache = 0),
        n
      );
    },
    bd = function (t) {
      return (t = t.split(" "))[0] + " " + t[1];
    },
    Ed = function (t, e, n) {
      var i = Vc(e);
      return ac(parseFloat(e) + parseFloat(ud(t, "x", n + "px", i))) + i;
    },
    wd = function (t, e) {
      (e.z = "0px"),
        (e.rotationY = e.rotationX = "0deg"),
        (e.force3D = 0),
        Pd(t, e);
    },
    Ad = "0deg",
    Rd = "0px",
    Cd = ") ",
    Pd = function (t, e) {
      var n = e || this,
        i = n.xPercent,
        r = n.yPercent,
        s = n.x,
        a = n.y,
        o = n.z,
        l = n.rotation,
        c = n.rotationY,
        h = n.rotationX,
        u = n.skewX,
        d = n.skewY,
        p = n.scaleX,
        f = n.scaleY,
        m = n.transformPerspective,
        g = n.force3D,
        _ = n.target,
        v = n.zOrigin,
        y = "",
        x = ("auto" === g && t && 1 !== t) || !0 === g;
      if (v && (h !== Ad || c !== Ad)) {
        var T,
          M = parseFloat(c) * Ru,
          S = Math.sin(M),
          b = Math.cos(M);
        (M = parseFloat(h) * Ru),
          (T = Math.cos(M)),
          (s = Ed(_, s, S * T * -v)),
          (a = Ed(_, a, -Math.sin(M) * -v)),
          (o = Ed(_, o, b * T * -v + v));
      }
      m !== Rd && (y += "perspective(" + m + Cd),
        (i || r) && (y += "translate(" + i + "%, " + r + "%) "),
        (x || s !== Rd || a !== Rd || o !== Rd) &&
          (y +=
            o !== Rd || x
              ? "translate3d(" + s + ", " + a + ", " + o + ") "
              : "translate(" + s + ", " + a + Cd),
        l !== Ad && (y += "rotate(" + l + Cd),
        c !== Ad && (y += "rotateY(" + c + Cd),
        h !== Ad && (y += "rotateX(" + h + Cd),
        (u === Ad && d === Ad) || (y += "skew(" + u + ", " + d + Cd),
        (1 === p && 1 === f) || (y += "scale(" + p + ", " + f + Cd),
        (_.style[ju] = y || "translate(0, 0)");
    },
    Ld = function (t, e) {
      var n,
        i,
        r,
        s,
        a,
        o = e || this,
        l = o.xPercent,
        c = o.yPercent,
        h = o.x,
        u = o.y,
        d = o.rotation,
        p = o.skewX,
        f = o.skewY,
        m = o.scaleX,
        g = o.scaleY,
        _ = o.target,
        v = o.xOrigin,
        y = o.yOrigin,
        x = o.xOffset,
        T = o.yOffset,
        M = o.forceCSS,
        S = parseFloat(h),
        b = parseFloat(u);
      (d = parseFloat(d)),
        (p = parseFloat(p)),
        (f = parseFloat(f)) && ((p += f = parseFloat(f)), (d += f)),
        d || p
          ? ((d *= Ru),
            (p *= Ru),
            (n = Math.cos(d) * m),
            (i = Math.sin(d) * m),
            (r = Math.sin(d - p) * -g),
            (s = Math.cos(d - p) * g),
            p &&
              ((f *= Ru),
              (a = Math.tan(p - f)),
              (r *= a = Math.sqrt(1 + a * a)),
              (s *= a),
              f &&
                ((a = Math.tan(f)), (n *= a = Math.sqrt(1 + a * a)), (i *= a))),
            (n = ac(n)),
            (i = ac(i)),
            (r = ac(r)),
            (s = ac(s)))
          : ((n = m), (s = g), (i = r = 0)),
        ((S && !~(h + "").indexOf("px")) || (b && !~(u + "").indexOf("px"))) &&
          ((S = ud(_, "x", h, "px")), (b = ud(_, "y", u, "px"))),
        (v || y || x || T) &&
          ((S = ac(S + v - (v * n + y * r) + x)),
          (b = ac(b + y - (v * i + y * s) + T))),
        (l || c) &&
          ((a = _.getBBox()),
          (S = ac(S + (l / 100) * a.width)),
          (b = ac(b + (c / 100) * a.height))),
        (a =
          "matrix(" +
          n +
          "," +
          i +
          "," +
          r +
          "," +
          s +
          "," +
          S +
          "," +
          b +
          ")"),
        _.setAttribute("transform", a),
        M && (_.style[ju] = a);
    },
    Dd = function (t, e, n, i, r) {
      var s,
        a,
        o = 360,
        l = Tl(r),
        c = parseFloat(r) * (l && ~r.indexOf("rad") ? Au : 1) - i,
        h = i + c + "deg";
      return (
        l &&
          ("short" === (s = r.split("_")[1]) &&
            (c %= o) != c % 180 &&
            (c += c < 0 ? o : -360),
          "cw" === s && c < 0
            ? (c = ((c + 36e9) % o) - ~~(c / o) * o)
            : "ccw" === s && c > 0 && (c = ((c - 36e9) % o) - ~~(c / o) * o)),
        (t._pt = a = new nu(t._pt, e, n, i, c, Nu)),
        (a.e = h),
        (a.u = "deg"),
        t._props.push(n),
        a
      );
    },
    Id = function (t, e) {
      for (var n in e) t[n] = e[n];
      return t;
    },
    Ud = function (t, e, n) {
      var i,
        r,
        s,
        a,
        o,
        l,
        c,
        h = Id({}, n._gsap),
        u = n.style;
      for (r in (h.svg
        ? ((s = n.getAttribute("transform")),
          n.setAttribute("transform", ""),
          (u[ju] = e),
          (i = Sd(n, 1)),
          od(n, ju),
          n.setAttribute("transform", s))
        : ((s = getComputedStyle(n)[ju]),
          (u[ju] = e),
          (i = Sd(n, 1)),
          (u[ju] = s)),
      wu))
        (s = h[r]) !== (a = i[r]) &&
          "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 &&
          ((o = Vc(s) !== (c = Vc(a)) ? ud(n, r, s, c) : parseFloat(s)),
          (l = parseFloat(a)),
          (t._pt = new nu(t._pt, i, r, o, l - o, Uu)),
          (t._pt.u = c || 0),
          t._props.push(r));
      Id(i, h);
    };
  sc("padding,margin,Width,Radius", function (t, e) {
    var n = "Top",
      i = "Right",
      r = "Bottom",
      s = "Left",
      a = (e < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map(function (
        n
      ) {
        return e < 2 ? t + n : "border" + n + t;
      });
    gd[e > 1 ? "border" + t : t] = function (t, e, n, i, r) {
      var s, o;
      if (arguments.length < 4)
        return (
          (s = a.map(function (e) {
            return dd(t, e, n);
          })),
          5 === (o = s.join(" ")).split(s[0]).length ? s[0] : o
        );
      (s = (i + "").split(" ")),
        (o = {}),
        a.forEach(function (t, e) {
          return (o[t] = s[e] = s[e] || s[((e - 1) / 2) | 0]);
        }),
        t.init(e, o, r);
    };
  });
  var Nd,
    Od,
    Fd = {
      name: "css",
      register: nd,
      targetTest: function (t) {
        return t.style && t.nodeType;
      },
      init: function (t, e, n, i, r) {
        var s,
          a,
          o,
          l,
          c,
          h,
          u,
          d,
          p,
          f,
          m,
          g,
          _,
          v,
          y,
          x,
          T,
          M,
          S,
          b,
          E = this._props,
          w = t.style,
          A = n.vars.startAt;
        for (u in (yu || nd(),
        (this.styles = this.styles || Ju(t)),
        (x = this.styles.props),
        (this.tween = n),
        e))
          if (
            "autoRound" !== u &&
            ((a = e[u]), !Jl[u] || !Oh(u, e, n, i, t, r))
          )
            if (
              ((c = typeof a),
              (h = gd[u]),
              "function" === c && (c = typeof (a = a.call(n, i, t, r))),
              "string" === c && ~a.indexOf("random(") && (a = th(a)),
              h)
            )
              h(this, t, u, a, n) && (y = 1);
            else if ("--" === u.substr(0, 2))
              (s = (getComputedStyle(t).getPropertyValue(u) + "").trim()),
                (a += ""),
                (ph.lastIndex = 0),
                ph.test(s) || ((d = Vc(s)), (p = Vc(a))),
                p ? d !== p && (s = ud(t, u, s, p) + p) : d && (a += d),
                this.add(w, "setProperty", s, a, i, r, 0, 0, u),
                E.push(u),
                x.push(u, 0, w[u]);
            else if ("undefined" !== c) {
              if (
                (A && u in A
                  ? ((s =
                      "function" == typeof A[u] ? A[u].call(n, i, t, r) : A[u]),
                    Tl(s) && ~s.indexOf("random(") && (s = th(s)),
                    Vc(s + "") ||
                      "auto" === s ||
                      (s += ul.units[u] || Vc(dd(t, u)) || ""),
                    "=" === (s + "").charAt(1) && (s = dd(t, u)))
                  : (s = dd(t, u)),
                (l = parseFloat(s)),
                (f = "string" === c && "=" === a.charAt(1) && a.substr(0, 2)) &&
                  (a = a.substr(2)),
                (o = parseFloat(a)),
                u in Iu &&
                  ("autoAlpha" === u &&
                    (1 === l &&
                      "hidden" === dd(t, "visibility") &&
                      o &&
                      (l = 0),
                    x.push("visibility", 0, w.visibility),
                    ld(
                      this,
                      w,
                      "visibility",
                      l ? "inherit" : "hidden",
                      o ? "inherit" : "hidden",
                      !o
                    )),
                  "scale" !== u &&
                    "transform" !== u &&
                    ~(u = Iu[u]).indexOf(",") &&
                    (u = u.split(",")[0])),
                (m = u in wu))
              )
                if (
                  (this.styles.save(u),
                  g ||
                    (((_ = t._gsap).renderTransform && !e.parseTransform) ||
                      Sd(t, e.parseTransform),
                    (v = !1 !== e.smoothOrigin && _.smooth),
                    ((g = this._pt =
                      new nu(
                        this._pt,
                        w,
                        ju,
                        0,
                        1,
                        _.renderTransform,
                        _,
                        0,
                        -1
                      )).dep = 1)),
                  "scale" === u)
                )
                  (this._pt = new nu(
                    this._pt,
                    _,
                    "scaleY",
                    _.scaleY,
                    (f ? lc(_.scaleY, f + o) : o) - _.scaleY || 0,
                    Uu
                  )),
                    (this._pt.u = 0),
                    E.push("scaleY", u),
                    (u += "X");
                else {
                  if ("transformOrigin" === u) {
                    x.push(qu, 0, w[qu]),
                      (M = void 0),
                      (S = void 0),
                      (b = void 0),
                      (S = (M = (T = a).split(" "))[0]),
                      (b = M[1] || "50%"),
                      ("top" !== S &&
                        "bottom" !== S &&
                        "left" !== b &&
                        "right" !== b) ||
                        ((T = S), (S = b), (b = T)),
                      (M[0] = fd[S] || S),
                      (M[1] = fd[b] || b),
                      (a = M.join(" ")),
                      _.svg
                        ? Md(t, a, 0, v, 0, this)
                        : ((p = parseFloat(a.split(" ")[2]) || 0) !==
                            _.zOrigin && ld(this, _, "zOrigin", _.zOrigin, p),
                          ld(this, w, u, bd(s), bd(a)));
                    continue;
                  }
                  if ("svgOrigin" === u) {
                    Md(t, a, 1, v, 0, this);
                    continue;
                  }
                  if (u in vd) {
                    Dd(this, _, u, l, f ? lc(l, f + a) : a);
                    continue;
                  }
                  if ("smoothOrigin" === u) {
                    ld(this, _, "smooth", _.smooth, a);
                    continue;
                  }
                  if ("force3D" === u) {
                    _[u] = a;
                    continue;
                  }
                  if ("transform" === u) {
                    Ud(this, a, t);
                    continue;
                  }
                }
              else u in w || (u = ed(u) || u);
              if (
                m ||
                ((o || 0 === o) && (l || 0 === l) && !Du.test(a) && u in w)
              )
                o || (o = 0),
                  (d = (s + "").substr((l + "").length)) !==
                    (p = Vc(a) || (u in ul.units ? ul.units[u] : d)) &&
                    (l = ud(t, u, s, p)),
                  (this._pt = new nu(
                    this._pt,
                    m ? _ : w,
                    u,
                    l,
                    (f ? lc(l, f + o) : o) - l,
                    m || ("px" !== p && "zIndex" !== u) || !1 === e.autoRound
                      ? Uu
                      : Fu
                  )),
                  (this._pt.u = p || 0),
                  d !== p && "%" !== p && ((this._pt.b = s), (this._pt.r = Ou));
              else if (u in w) pd.call(this, t, u, s, f ? f + a : a);
              else if (u in t) this.add(t, u, s || t[u], f ? f + a : a, i, r);
              else if ("parseTransform" !== u) {
                Hl(u, a);
                continue;
              }
              m || (u in w ? x.push(u, 0, w[u]) : x.push(u, 1, s || t[u])),
                E.push(u);
            }
        y && eu(this);
      },
      render: function (t, e) {
        if (e.tween._time || !Mu())
          for (var n = e._pt; n; ) n.r(t, n.d), (n = n._next);
        else e.styles.revert();
      },
      get: dd,
      aliases: Iu,
      getSetter: function (t, e, n) {
        var i = Iu[e];
        return (
          i && i.indexOf(",") < 0 && (e = i),
          e in wu && e !== qu && (t._gsap.x || dd(t, "x"))
            ? n && Tu === n
              ? "scale" === e
                ? Vu
                : Gu
              : (Tu = n || {}) && ("scale" === e ? Wu : Xu)
            : t.style && !bl(t.style[e])
            ? Bu
            : ~e.indexOf("-")
            ? Hu
            : qh(t, e)
        );
      },
      core: { _removeProperty: od, _getMatrix: Td },
    };
  (mu.utils.checkPrefix = ed),
    (mu.core.getStyleSaver = Ju),
    (Od = sc(
      "x,y,z,scale,scaleX,scaleY,xPercent,yPercent" +
        "," +
        (Nd = "rotation,rotationX,rotationY,skewX,skewY") +
        ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
      function (t) {
        wu[t] = 1;
      }
    )),
    sc(Nd, function (t) {
      (ul.units[t] = "deg"), (vd[t] = 1);
    }),
    (Iu[Od[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + Nd),
    sc(
      "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY",
      function (t) {
        var e = t.split(":");
        Iu[e[1]] = Od[e[0]];
      }
    ),
    sc(
      "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
      function (t) {
        ul.units[t] = "px";
      }
    ),
    mu.registerPlugin(Fd);
  var kd = mu.registerPlugin(Fd) || mu,
    zd = (kd.core.Tween, /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi),
    Bd = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi,
    Hd = Math.PI / 180,
    Gd = (Math.PI, Math.sin),
    Vd = Math.cos,
    Wd = Math.abs,
    Xd = Math.sqrt,
    jd =
      (Math.atan2,
      function (t) {
        return "number" == typeof t;
      }),
    qd = 1e5,
    Yd = function (t) {
      return Math.round(t * qd) / qd || 0;
    };
  function Kd(t, e, n, i, r, s, a, o, l) {
    if (t !== o || e !== l) {
      (n = Wd(n)), (i = Wd(i));
      var c = (r % 360) * Hd,
        h = Vd(c),
        u = Gd(c),
        d = Math.PI,
        p = 2 * d,
        f = (t - o) / 2,
        m = (e - l) / 2,
        g = h * f + u * m,
        _ = -u * f + h * m,
        v = g * g,
        y = _ * _,
        x = v / (n * n) + y / (i * i);
      x > 1 && ((n = Xd(x) * n), (i = Xd(x) * i));
      var T = n * n,
        M = i * i,
        S = (T * M - T * y - M * v) / (T * y + M * v);
      S < 0 && (S = 0);
      var b = (s === a ? -1 : 1) * Xd(S),
        E = b * ((n * _) / i),
        w = b * ((-i * g) / n),
        A = (t + o) / 2 + (h * E - u * w),
        R = (e + l) / 2 + (u * E + h * w),
        C = (g - E) / n,
        P = (_ - w) / i,
        L = (-g - E) / n,
        D = (-_ - w) / i,
        I = C * C + P * P,
        U = (P < 0 ? -1 : 1) * Math.acos(C / Xd(I)),
        N =
          (C * D - P * L < 0 ? -1 : 1) *
          Math.acos((C * L + P * D) / Xd(I * (L * L + D * D)));
      isNaN(N) && (N = d),
        !a && N > 0 ? (N -= p) : a && N < 0 && (N += p),
        (U %= p),
        (N %= p);
      var O,
        F = Math.ceil(Wd(N) / (p / 4)),
        k = [],
        z = N / F,
        B = ((4 / 3) * Gd(z / 2)) / (1 + Vd(z / 2)),
        H = h * n,
        G = u * n,
        V = u * -i,
        W = h * i;
      for (O = 0; O < F; O++)
        (g = Vd((r = U + O * z))),
          (_ = Gd(r)),
          (C = Vd((r += z))),
          (P = Gd(r)),
          k.push(g - B * _, _ + B * g, C + B * P, P - B * C, C, P);
      for (O = 0; O < k.length; O += 2)
        (g = k[O]),
          (_ = k[O + 1]),
          (k[O] = g * H + _ * V + A),
          (k[O + 1] = g * G + _ * W + R);
      return (k[O - 2] = o), (k[O - 1] = l), k;
    }
  }
  var Zd,
    Jd,
    Qd = function () {
      return (
        Zd ||
        ("undefined" != typeof window &&
          (Zd = window.gsap) &&
          Zd.registerPlugin &&
          Zd)
      );
    },
    $d = function () {
      (Zd = Qd())
        ? (Zd.registerEase("_CE", rp.create), (Jd = 1))
        : console.warn("Please gsap.registerPlugin(CustomEase)");
    },
    tp = function (t) {
      return ~~(1e3 * t + (t < 0 ? -0.5 : 0.5)) / 1e3;
    },
    ep = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/gi,
    np = /[cLlsSaAhHvVtTqQ]/g,
    ip = function t(e, n, i, r, s, a, o, l, c, h, u) {
      var d,
        p = (e + i) / 2,
        f = (n + r) / 2,
        m = (i + s) / 2,
        g = (r + a) / 2,
        _ = (s + o) / 2,
        v = (a + l) / 2,
        y = (p + m) / 2,
        x = (f + g) / 2,
        T = (m + _) / 2,
        M = (g + v) / 2,
        S = (y + T) / 2,
        b = (x + M) / 2,
        E = o - e,
        w = l - n,
        A = Math.abs((i - o) * w - (r - l) * E),
        R = Math.abs((s - o) * w - (a - l) * E);
      return (
        h ||
          ((h = [
            { x: e, y: n },
            { x: o, y: l },
          ]),
          (u = 1)),
        h.splice(u || h.length - 1, 0, { x: S, y: b }),
        (A + R) * (A + R) > c * (E * E + w * w) &&
          ((d = h.length),
          t(e, n, p, f, y, x, S, b, c, h, u),
          t(S, b, T, M, _, v, o, l, c, h, u + 1 + (h.length - d))),
        h
      );
    },
    rp = (function () {
      function t(t, e, n) {
        Jd || $d(), (this.id = t), this.setData(e, n);
      }
      var e = t.prototype;
      return (
        (e.setData = function (t, e) {
          e = e || {};
          var n,
            i,
            r,
            s,
            a,
            o,
            l,
            c,
            h,
            u = (t = t || "0,0,1,1").match(ep),
            d = 1,
            p = [],
            f = [],
            m = e.precision || 1,
            g = m <= 1;
          if (
            ((this.data = t),
            (np.test(t) || (~t.indexOf("M") && t.indexOf("C") < 0)) &&
              (u = (function (t) {
                var e,
                  n,
                  i,
                  r,
                  s,
                  a,
                  o,
                  l,
                  c,
                  h,
                  u,
                  d,
                  p,
                  f,
                  m,
                  g =
                    (t + "")
                      .replace(Bd, function (t) {
                        var e = +t;
                        return e < 1e-4 && e > -1e-4 ? 0 : e;
                      })
                      .match(zd) || [],
                  _ = [],
                  v = 0,
                  y = 0,
                  x = 2 / 3,
                  T = g.length,
                  M = 0,
                  S = "ERROR: malformed path: " + t,
                  b = function (t, e, n, i) {
                    (h = (n - t) / 3),
                      (u = (i - e) / 3),
                      o.push(t + h, e + u, n - h, i - u, n, i);
                  };
                if (!t || !isNaN(g[0]) || isNaN(g[1])) return console.log(S), _;
                for (e = 0; e < T; e++)
                  if (
                    ((p = s),
                    isNaN(g[e]) ? (a = (s = g[e].toUpperCase()) !== g[e]) : e--,
                    (i = +g[e + 1]),
                    (r = +g[e + 2]),
                    a && ((i += v), (r += y)),
                    e || ((l = i), (c = r)),
                    "M" === s)
                  )
                    o && (o.length < 8 ? (_.length -= 1) : (M += o.length)),
                      (v = l = i),
                      (y = c = r),
                      (o = [i, r]),
                      _.push(o),
                      (e += 2),
                      (s = "L");
                  else if ("C" === s)
                    o || (o = [0, 0]),
                      a || (v = y = 0),
                      o.push(
                        i,
                        r,
                        v + 1 * g[e + 3],
                        y + 1 * g[e + 4],
                        (v += 1 * g[e + 5]),
                        (y += 1 * g[e + 6])
                      ),
                      (e += 6);
                  else if ("S" === s)
                    (h = v),
                      (u = y),
                      ("C" !== p && "S" !== p) ||
                        ((h += v - o[o.length - 4]),
                        (u += y - o[o.length - 3])),
                      a || (v = y = 0),
                      o.push(
                        h,
                        u,
                        i,
                        r,
                        (v += 1 * g[e + 3]),
                        (y += 1 * g[e + 4])
                      ),
                      (e += 4);
                  else if ("Q" === s)
                    (h = v + (i - v) * x),
                      (u = y + (r - y) * x),
                      a || (v = y = 0),
                      (v += 1 * g[e + 3]),
                      (y += 1 * g[e + 4]),
                      o.push(h, u, v + (i - v) * x, y + (r - y) * x, v, y),
                      (e += 4);
                  else if ("T" === s)
                    (h = v - o[o.length - 4]),
                      (u = y - o[o.length - 3]),
                      o.push(
                        v + h,
                        y + u,
                        i + (v + 1.5 * h - i) * x,
                        r + (y + 1.5 * u - r) * x,
                        (v = i),
                        (y = r)
                      ),
                      (e += 2);
                  else if ("H" === s) b(v, y, (v = i), y), (e += 1);
                  else if ("V" === s)
                    b(v, y, v, (y = i + (a ? y - v : 0))), (e += 1);
                  else if ("L" === s || "Z" === s)
                    "Z" === s && ((i = l), (r = c), (o.closed = !0)),
                      ("L" === s || Wd(v - i) > 0.5 || Wd(y - r) > 0.5) &&
                        (b(v, y, i, r), "L" === s && (e += 2)),
                      (v = i),
                      (y = r);
                  else if ("A" === s) {
                    if (
                      ((f = g[e + 4]),
                      (m = g[e + 5]),
                      (h = g[e + 6]),
                      (u = g[e + 7]),
                      (n = 7),
                      f.length > 1 &&
                        (f.length < 3
                          ? ((u = h), (h = m), n--)
                          : ((u = m), (h = f.substr(2)), (n -= 2)),
                        (m = f.charAt(1)),
                        (f = f.charAt(0))),
                      (d = Kd(
                        v,
                        y,
                        +g[e + 1],
                        +g[e + 2],
                        +g[e + 3],
                        +f,
                        +m,
                        (a ? v : 0) + 1 * h,
                        (a ? y : 0) + 1 * u
                      )),
                      (e += n),
                      d)
                    )
                      for (n = 0; n < d.length; n++) o.push(d[n]);
                    (v = o[o.length - 2]), (y = o[o.length - 1]);
                  } else console.log(S);
                return (
                  (e = o.length) < 6
                    ? (_.pop(), (e = 0))
                    : o[0] === o[e - 2] && o[1] === o[e - 1] && (o.closed = !0),
                  (_.totalPoints = M + e),
                  _
                );
              })(t)[0]),
            4 === (n = u.length))
          )
            u.unshift(0, 0), u.push(1, 1), (n = 8);
          else if ((n - 2) % 6) throw "Invalid CustomEase";
          for (
            (0 == +u[0] && 1 == +u[n - 2]) ||
              (function (t, e, n) {
                n || 0 === n || (n = Math.max(+t[t.length - 1], +t[1]));
                var i,
                  r = -1 * +t[0],
                  s = -n,
                  a = t.length,
                  o = 1 / (+t[a - 2] + r),
                  l =
                    -e ||
                    (Math.abs(+t[a - 1] - +t[1]) < 0.01 * (+t[a - 2] - +t[0])
                      ? (function (t) {
                          var e,
                            n = t.length,
                            i = 1e20;
                          for (e = 1; e < n; e += 6) +t[e] < i && (i = +t[e]);
                          return i;
                        })(t) + s
                      : +t[a - 1] + s);
                for (l = l ? 1 / l : -o, i = 0; i < a; i += 2)
                  (t[i] = (+t[i] + r) * o), (t[i + 1] = (+t[i + 1] + s) * l);
              })(u, e.height, e.originY),
              this.segment = u,
              s = 2;
            s < n;
            s += 6
          )
            (i = { x: +u[s - 2], y: +u[s - 1] }),
              (r = { x: +u[s + 4], y: +u[s + 5] }),
              p.push(i, r),
              ip(
                i.x,
                i.y,
                +u[s],
                +u[s + 1],
                +u[s + 2],
                +u[s + 3],
                r.x,
                r.y,
                1 / (2e5 * m),
                p,
                p.length - 1
              );
          for (n = p.length, s = 0; s < n; s++)
            (l = p[s]),
              (c = p[s - 1] || l),
              (l.x > c.x || (c.y !== l.y && c.x === l.x) || l === c) && l.x <= 1
                ? ((c.cx = l.x - c.x),
                  (c.cy = l.y - c.y),
                  (c.n = l),
                  (c.nx = l.x),
                  g &&
                    s > 1 &&
                    Math.abs(c.cy / c.cx - p[s - 2].cy / p[s - 2].cx) > 2 &&
                    (g = 0),
                  c.cx < d &&
                    (c.cx
                      ? (d = c.cx)
                      : ((c.cx = 0.001),
                        s === n - 1 &&
                          ((c.x -= 0.001), (d = Math.min(d, 0.001)), (g = 0)))))
                : (p.splice(s--, 1), n--);
          if (((a = 1 / (n = (1 / d + 1) | 0)), (o = 0), (l = p[0]), g)) {
            for (s = 0; s < n; s++)
              (h = s * a),
                l.nx < h && (l = p[++o]),
                (i = l.y + ((h - l.x) / l.cx) * l.cy),
                (f[s] = { x: h, cx: a, y: i, cy: 0, nx: 9 }),
                s && (f[s - 1].cy = i - f[s - 1].y);
            f[n - 1].cy = p[p.length - 1].y - i;
          } else {
            for (s = 0; s < n; s++) l.nx < s * a && (l = p[++o]), (f[s] = l);
            o < p.length - 1 && (f[s - 1] = p[p.length - 2]);
          }
          return (
            (this.ease = function (t) {
              var e = f[(t * n) | 0] || f[n - 1];
              return e.nx < t && (e = e.n), e.y + ((t - e.x) / e.cx) * e.cy;
            }),
            (this.ease.custom = this),
            this.id && Zd && Zd.registerEase(this.id, this.ease),
            this
          );
        }),
        (e.getSVGData = function (e) {
          return t.getSVGData(this, e);
        }),
        (t.create = function (e, n, i) {
          return new t(e, n, i).ease;
        }),
        (t.register = function (t) {
          (Zd = t), $d();
        }),
        (t.get = function (t) {
          return Zd.parseEase(t);
        }),
        (t.getSVGData = function (e, n) {
          var i,
            r,
            s,
            a,
            o,
            l,
            c,
            h,
            u,
            d,
            p = (n = n || {}).width || 100,
            f = n.height || 100,
            m = n.x || 0,
            g = (n.y || 0) + f,
            _ = Zd.utils.toArray(n.path)[0];
          if (
            (n.invert && ((f = -f), (g = 0)),
            "string" == typeof e && (e = Zd.parseEase(e)),
            e.custom && (e = e.custom),
            e instanceof t)
          )
            i = (function (t) {
              jd(t[0]) && (t = [t]);
              var e,
                n,
                i,
                r,
                s = "",
                a = t.length;
              for (n = 0; n < a; n++) {
                for (
                  r = t[n],
                    s += "M" + Yd(r[0]) + "," + Yd(r[1]) + " C",
                    e = r.length,
                    i = 2;
                  i < e;
                  i++
                )
                  s +=
                    Yd(r[i++]) +
                    "," +
                    Yd(r[i++]) +
                    " " +
                    Yd(r[i++]) +
                    "," +
                    Yd(r[i++]) +
                    " " +
                    Yd(r[i++]) +
                    "," +
                    Yd(r[i]) +
                    " ";
                r.closed && (s += "z");
              }
              return s;
            })(
              (function (t, e, n, i, r, s, a) {
                for (var o, l, c, h, u, d = t.length; --d > -1; )
                  for (l = (o = t[d]).length, c = 0; c < l; c += 2)
                    (h = o[c]),
                      (u = o[c + 1]),
                      (o[c] = h * e + 0 * u + s),
                      (o[c + 1] = 0 * h + u * r + a);
                return (t._dirty = 1), t;
              })([e.segment], p, 0, 0, -f, m, g)
            );
          else {
            for (
              i = [m, g],
                a = 1 / (c = Math.max(5, 200 * (n.precision || 1))),
                h = 5 / (c += 2),
                u = tp(m + a * p),
                r = ((d = tp(g + e(a) * -f)) - g) / (u - m),
                s = 2;
              s < c;
              s++
            )
              (o = tp(m + s * a * p)),
                (l = tp(g + e(s * a) * -f)),
                (Math.abs((l - d) / (o - u) - r) > h || s === c - 1) &&
                  (i.push(u, d), (r = (l - d) / (o - u))),
                (u = o),
                (d = l);
            i = "M" + i.join(",");
          }
          return _ && _.setAttribute("d", i), i;
        }),
        t
      );
    })();
  function sp(t, e) {
    for (var n = 0; n < e.length; n++) {
      var i = e[n];
      (i.enumerable = i.enumerable || !1),
        (i.configurable = !0),
        "value" in i && (i.writable = !0),
        Object.defineProperty(t, i.key, i);
    }
  }
  Qd() && Zd.registerPlugin(rp), (rp.version = "3.12.4");
  var ap,
    op,
    lp,
    cp,
    hp,
    up,
    dp,
    pp,
    fp,
    mp,
    gp,
    _p,
    vp,
    yp = function () {
      return (
        ap ||
        ("undefined" != typeof window &&
          (ap = window.gsap) &&
          ap.registerPlugin &&
          ap)
      );
    },
    xp = 1,
    Tp = [],
    Mp = [],
    Sp = [],
    bp = Date.now,
    Ep = function (t, e) {
      return e;
    },
    wp = function (t, e) {
      return ~Sp.indexOf(t) && Sp[Sp.indexOf(t) + 1][e];
    },
    Ap = function (t) {
      return !!~mp.indexOf(t);
    },
    Rp = function (t, e, n, i, r) {
      return t.addEventListener(e, n, { passive: !i, capture: !!r });
    },
    Cp = function (t, e, n, i) {
      return t.removeEventListener(e, n, !!i);
    },
    Pp = "scrollLeft",
    Lp = "scrollTop",
    Dp = function () {
      return (gp && gp.isPressed) || Mp.cache++;
    },
    Ip = function (t, e) {
      var n = function n(i) {
        if (i || 0 === i) {
          xp && (lp.history.scrollRestoration = "manual");
          var r = gp && gp.isPressed;
          (i = n.v = Math.round(i) || (gp && gp.iOS ? 1 : 0)),
            t(i),
            (n.cacheID = Mp.cache),
            r && Ep("ss", i);
        } else
          (e || Mp.cache !== n.cacheID || Ep("ref")) &&
            ((n.cacheID = Mp.cache), (n.v = t()));
        return n.v + n.offset;
      };
      return (n.offset = 0), t && n;
    },
    Up = {
      s: Pp,
      p: "left",
      p2: "Left",
      os: "right",
      os2: "Right",
      d: "width",
      d2: "Width",
      a: "x",
      sc: Ip(function (t) {
        return arguments.length
          ? lp.scrollTo(t, Np.sc())
          : lp.pageXOffset || cp[Pp] || hp[Pp] || up[Pp] || 0;
      }),
    },
    Np = {
      s: Lp,
      p: "top",
      p2: "Top",
      os: "bottom",
      os2: "Bottom",
      d: "height",
      d2: "Height",
      a: "y",
      op: Up,
      sc: Ip(function (t) {
        return arguments.length
          ? lp.scrollTo(Up.sc(), t)
          : lp.pageYOffset || cp[Lp] || hp[Lp] || up[Lp] || 0;
      }),
    },
    Op = function (t, e) {
      return (
        ((e && e._ctx && e._ctx.selector) || ap.utils.toArray)(t)[0] ||
        ("string" == typeof t && !1 !== ap.config().nullTargetWarn
          ? console.warn("Element not found:", t)
          : null)
      );
    },
    Fp = function (t, e) {
      var n = e.s,
        i = e.sc;
      Ap(t) && (t = cp.scrollingElement || hp);
      var r = Mp.indexOf(t),
        s = i === Np.sc ? 1 : 2;
      !~r && (r = Mp.push(t) - 1), Mp[r + s] || Rp(t, "scroll", Dp);
      var a = Mp[r + s],
        o =
          a ||
          (Mp[r + s] =
            Ip(wp(t, n), !0) ||
            (Ap(t)
              ? i
              : Ip(function (e) {
                  return arguments.length ? (t[n] = e) : t[n];
                })));
      return (
        (o.target = t),
        a || (o.smooth = "smooth" === ap.getProperty(t, "scrollBehavior")),
        o
      );
    },
    kp = function (t, e, n) {
      var i = t,
        r = t,
        s = bp(),
        a = s,
        o = e || 50,
        l = Math.max(500, 3 * o),
        c = function (t, e) {
          var l = bp();
          e || l - s > o
            ? ((r = i), (i = t), (a = s), (s = l))
            : n
            ? (i += t)
            : (i = r + ((t - r) / (l - a)) * (s - a));
        };
      return {
        update: c,
        reset: function () {
          (r = i = n ? 0 : i), (a = s = 0);
        },
        getVelocity: function (t) {
          var e = a,
            o = r,
            h = bp();
          return (
            (t || 0 === t) && t !== i && c(t),
            s === a || h - a > l
              ? 0
              : ((i + (n ? o : -o)) / ((n ? h : s) - e)) * 1e3
          );
        },
      };
    },
    zp = function (t, e) {
      return (
        e && !t._gsapAllow && t.preventDefault(),
        t.changedTouches ? t.changedTouches[0] : t
      );
    },
    Bp = function (t) {
      var e = Math.max.apply(Math, t),
        n = Math.min.apply(Math, t);
      return Math.abs(e) >= Math.abs(n) ? e : n;
    },
    Hp = function () {
      var t, e, n, i;
      (fp = ap.core.globals().ScrollTrigger) &&
        fp.core &&
        ((t = fp.core),
        (e = t.bridge || {}),
        (n = t._scrollers),
        (i = t._proxies),
        n.push.apply(n, Mp),
        i.push.apply(i, Sp),
        (Mp = n),
        (Sp = i),
        (Ep = function (t, n) {
          return e[t](n);
        }));
    },
    Gp = function (t) {
      return (
        (ap = t || yp()),
        !op &&
          ap &&
          "undefined" != typeof document &&
          document.body &&
          ((lp = window),
          (cp = document),
          (hp = cp.documentElement),
          (up = cp.body),
          (mp = [lp, cp, hp, up]),
          ap.utils.clamp,
          (vp = ap.core.context || function () {}),
          (pp = "onpointerenter" in up ? "pointer" : "mouse"),
          (dp = Vp.isTouch =
            lp.matchMedia &&
            lp.matchMedia("(hover: none), (pointer: coarse)").matches
              ? 1
              : "ontouchstart" in lp ||
                navigator.maxTouchPoints > 0 ||
                navigator.msMaxTouchPoints > 0
              ? 2
              : 0),
          (_p = Vp.eventTypes =
            (
              "ontouchstart" in hp
                ? "touchstart,touchmove,touchcancel,touchend"
                : "onpointerdown" in hp
                ? "pointerdown,pointermove,pointercancel,pointerup"
                : "mousedown,mousemove,mouseup,mouseup"
            ).split(",")),
          setTimeout(function () {
            return (xp = 0);
          }, 500),
          Hp(),
          (op = 1)),
        op
      );
    };
  (Up.op = Np), (Mp.cache = 0);
  var Vp = (function () {
    function t(t) {
      this.init(t);
    }
    var e, n;
    return (
      (t.prototype.init = function (t) {
        op || Gp(ap) || console.warn("Please gsap.registerPlugin(Observer)"),
          fp || Hp();
        var e = t.tolerance,
          n = t.dragMinimum,
          i = t.type,
          r = t.target,
          s = t.lineHeight,
          a = t.debounce,
          o = t.preventDefault,
          l = t.onStop,
          c = t.onStopDelay,
          h = t.ignore,
          u = t.wheelSpeed,
          d = t.event,
          p = t.onDragStart,
          f = t.onDragEnd,
          m = t.onDrag,
          g = t.onPress,
          _ = t.onRelease,
          v = t.onRight,
          y = t.onLeft,
          x = t.onUp,
          T = t.onDown,
          M = t.onChangeX,
          S = t.onChangeY,
          b = t.onChange,
          E = t.onToggleX,
          w = t.onToggleY,
          A = t.onHover,
          R = t.onHoverEnd,
          C = t.onMove,
          P = t.ignoreCheck,
          L = t.isNormalizer,
          D = t.onGestureStart,
          I = t.onGestureEnd,
          U = t.onWheel,
          N = t.onEnable,
          O = t.onDisable,
          F = t.onClick,
          k = t.scrollSpeed,
          z = t.capture,
          B = t.allowClicks,
          H = t.lockAxis,
          G = t.onLockAxis;
        (this.target = r = Op(r) || hp),
          (this.vars = t),
          h && (h = ap.utils.toArray(h)),
          (e = e || 1e-9),
          (n = n || 0),
          (u = u || 1),
          (k = k || 1),
          (i = i || "wheel,touch,pointer"),
          (a = !1 !== a),
          s || (s = parseFloat(lp.getComputedStyle(up).lineHeight) || 22);
        var V,
          W,
          X,
          j,
          q,
          Y,
          K,
          Z = this,
          J = 0,
          Q = 0,
          $ = Fp(r, Up),
          tt = Fp(r, Np),
          et = $(),
          nt = tt(),
          it =
            ~i.indexOf("touch") &&
            !~i.indexOf("pointer") &&
            "pointerdown" === _p[0],
          rt = Ap(r),
          st = r.ownerDocument || cp,
          at = [0, 0, 0],
          ot = [0, 0, 0],
          lt = 0,
          ct = function () {
            return (lt = bp());
          },
          ht = function (t, e) {
            return (
              ((Z.event = t) && h && ~h.indexOf(t.target)) ||
              (e && it && "touch" !== t.pointerType) ||
              (P && P(t, e))
            );
          },
          ut = function () {
            var t = (Z.deltaX = Bp(at)),
              n = (Z.deltaY = Bp(ot)),
              i = Math.abs(t) >= e,
              r = Math.abs(n) >= e;
            b && (i || r) && b(Z, t, n, at, ot),
              i &&
                (v && Z.deltaX > 0 && v(Z),
                y && Z.deltaX < 0 && y(Z),
                M && M(Z),
                E && Z.deltaX < 0 != J < 0 && E(Z),
                (J = Z.deltaX),
                (at[0] = at[1] = at[2] = 0)),
              r &&
                (T && Z.deltaY > 0 && T(Z),
                x && Z.deltaY < 0 && x(Z),
                S && S(Z),
                w && Z.deltaY < 0 != Q < 0 && w(Z),
                (Q = Z.deltaY),
                (ot[0] = ot[1] = ot[2] = 0)),
              (j || X) && (C && C(Z), X && (m(Z), (X = !1)), (j = !1)),
              Y && !(Y = !1) && G && G(Z),
              q && (U(Z), (q = !1)),
              (V = 0);
          },
          dt = function (t, e, n) {
            (at[n] += t),
              (ot[n] += e),
              Z._vx.update(t),
              Z._vy.update(e),
              a ? V || (V = requestAnimationFrame(ut)) : ut();
          },
          pt = function (t, e) {
            H &&
              !K &&
              ((Z.axis = K = Math.abs(t) > Math.abs(e) ? "x" : "y"), (Y = !0)),
              "y" !== K && ((at[2] += t), Z._vx.update(t, !0)),
              "x" !== K && ((ot[2] += e), Z._vy.update(e, !0)),
              a ? V || (V = requestAnimationFrame(ut)) : ut();
          },
          ft = function (t) {
            if (!ht(t, 1)) {
              var e = (t = zp(t, o)).clientX,
                i = t.clientY,
                r = e - Z.x,
                s = i - Z.y,
                a = Z.isDragging;
              (Z.x = e),
                (Z.y = i),
                (a ||
                  Math.abs(Z.startX - e) >= n ||
                  Math.abs(Z.startY - i) >= n) &&
                  (m && (X = !0),
                  a || (Z.isDragging = !0),
                  pt(r, s),
                  a || (p && p(Z)));
            }
          },
          mt = (Z.onPress = function (t) {
            ht(t, 1) ||
              (t && t.button) ||
              ((Z.axis = K = null),
              W.pause(),
              (Z.isPressed = !0),
              (t = zp(t)),
              (J = Q = 0),
              (Z.startX = Z.x = t.clientX),
              (Z.startY = Z.y = t.clientY),
              Z._vx.reset(),
              Z._vy.reset(),
              Rp(L ? r : st, _p[1], ft, o, !0),
              (Z.deltaX = Z.deltaY = 0),
              g && g(Z));
          }),
          gt = (Z.onRelease = function (t) {
            if (!ht(t, 1)) {
              Cp(L ? r : st, _p[1], ft, !0);
              var e = !isNaN(Z.y - Z.startY),
                n = Z.isDragging,
                i =
                  n &&
                  (Math.abs(Z.x - Z.startX) > 3 ||
                    Math.abs(Z.y - Z.startY) > 3),
                s = zp(t);
              !i &&
                e &&
                (Z._vx.reset(),
                Z._vy.reset(),
                o &&
                  B &&
                  ap.delayedCall(0.08, function () {
                    if (bp() - lt > 300 && !t.defaultPrevented)
                      if (t.target.click) t.target.click();
                      else if (st.createEvent) {
                        var e = st.createEvent("MouseEvents");
                        e.initMouseEvent(
                          "click",
                          !0,
                          !0,
                          lp,
                          1,
                          s.screenX,
                          s.screenY,
                          s.clientX,
                          s.clientY,
                          !1,
                          !1,
                          !1,
                          !1,
                          0,
                          null
                        ),
                          t.target.dispatchEvent(e);
                      }
                  })),
                (Z.isDragging = Z.isGesturing = Z.isPressed = !1),
                l && n && !L && W.restart(!0),
                f && n && f(Z),
                _ && _(Z, i);
            }
          }),
          _t = function (t) {
            return (
              t.touches &&
              t.touches.length > 1 &&
              (Z.isGesturing = !0) &&
              D(t, Z.isDragging)
            );
          },
          vt = function () {
            return (Z.isGesturing = !1) || I(Z);
          },
          yt = function (t) {
            if (!ht(t)) {
              var e = $(),
                n = tt();
              dt((e - et) * k, (n - nt) * k, 1),
                (et = e),
                (nt = n),
                l && W.restart(!0);
            }
          },
          xt = function (t) {
            if (!ht(t)) {
              (t = zp(t, o)), U && (q = !0);
              var e =
                (1 === t.deltaMode
                  ? s
                  : 2 === t.deltaMode
                  ? lp.innerHeight
                  : 1) * u;
              dt(t.deltaX * e, t.deltaY * e, 0), l && !L && W.restart(!0);
            }
          },
          Tt = function (t) {
            if (!ht(t)) {
              var e = t.clientX,
                n = t.clientY,
                i = e - Z.x,
                r = n - Z.y;
              (Z.x = e),
                (Z.y = n),
                (j = !0),
                l && W.restart(!0),
                (i || r) && pt(i, r);
            }
          },
          Mt = function (t) {
            (Z.event = t), A(Z);
          },
          St = function (t) {
            (Z.event = t), R(Z);
          },
          bt = function (t) {
            return ht(t) || (zp(t, o) && F(Z));
          };
        (W = Z._dc =
          ap
            .delayedCall(c || 0.25, function () {
              Z._vx.reset(), Z._vy.reset(), W.pause(), l && l(Z);
            })
            .pause()),
          (Z.deltaX = Z.deltaY = 0),
          (Z._vx = kp(0, 50, !0)),
          (Z._vy = kp(0, 50, !0)),
          (Z.scrollX = $),
          (Z.scrollY = tt),
          (Z.isDragging = Z.isGesturing = Z.isPressed = !1),
          vp(this),
          (Z.enable = function (t) {
            return (
              Z.isEnabled ||
                (Rp(rt ? st : r, "scroll", Dp),
                i.indexOf("scroll") >= 0 && Rp(rt ? st : r, "scroll", yt, o, z),
                i.indexOf("wheel") >= 0 && Rp(r, "wheel", xt, o, z),
                ((i.indexOf("touch") >= 0 && dp) ||
                  i.indexOf("pointer") >= 0) &&
                  (Rp(r, _p[0], mt, o, z),
                  Rp(st, _p[2], gt),
                  Rp(st, _p[3], gt),
                  B && Rp(r, "click", ct, !1, !0),
                  F && Rp(r, "click", bt),
                  D && Rp(st, "gesturestart", _t),
                  I && Rp(st, "gestureend", vt),
                  A && Rp(r, pp + "enter", Mt),
                  R && Rp(r, pp + "leave", St),
                  C && Rp(r, pp + "move", Tt)),
                (Z.isEnabled = !0),
                t && t.type && mt(t),
                N && N(Z)),
              Z
            );
          }),
          (Z.disable = function () {
            Z.isEnabled &&
              (Tp.filter(function (t) {
                return t !== Z && Ap(t.target);
              }).length || Cp(rt ? st : r, "scroll", Dp),
              Z.isPressed &&
                (Z._vx.reset(), Z._vy.reset(), Cp(L ? r : st, _p[1], ft, !0)),
              Cp(rt ? st : r, "scroll", yt, z),
              Cp(r, "wheel", xt, z),
              Cp(r, _p[0], mt, z),
              Cp(st, _p[2], gt),
              Cp(st, _p[3], gt),
              Cp(r, "click", ct, !0),
              Cp(r, "click", bt),
              Cp(st, "gesturestart", _t),
              Cp(st, "gestureend", vt),
              Cp(r, pp + "enter", Mt),
              Cp(r, pp + "leave", St),
              Cp(r, pp + "move", Tt),
              (Z.isEnabled = Z.isPressed = Z.isDragging = !1),
              O && O(Z));
          }),
          (Z.kill = Z.revert =
            function () {
              Z.disable();
              var t = Tp.indexOf(Z);
              t >= 0 && Tp.splice(t, 1), gp === Z && (gp = 0);
            }),
          Tp.push(Z),
          L && Ap(r) && (gp = Z),
          Z.enable(d);
      }),
      (e = t),
      (n = [
        {
          key: "velocityX",
          get: function () {
            return this._vx.getVelocity();
          },
        },
        {
          key: "velocityY",
          get: function () {
            return this._vy.getVelocity();
          },
        },
      ]) && sp(e.prototype, n),
      t
    );
  })();
  (Vp.version = "3.12.4"),
    (Vp.create = function (t) {
      return new Vp(t);
    }),
    (Vp.register = Gp),
    (Vp.getAll = function () {
      return Tp.slice();
    }),
    (Vp.getById = function (t) {
      return Tp.filter(function (e) {
        return e.vars.id === t;
      })[0];
    }),
    yp() && ap.registerPlugin(Vp);
  var Wp,
    Xp,
    jp,
    qp,
    Yp,
    Kp,
    Zp,
    Jp,
    Qp,
    $p,
    tf,
    ef,
    nf,
    rf,
    sf,
    af,
    of,
    lf,
    cf,
    hf,
    uf,
    df,
    pf,
    ff,
    mf,
    gf,
    _f,
    vf,
    yf,
    xf,
    Tf,
    Mf,
    Sf,
    bf,
    Ef,
    wf,
    Af,
    Rf,
    Cf = 1,
    Pf = Date.now,
    Lf = Pf(),
    Df = 0,
    If = 0,
    Uf = function (t, e, n) {
      var i = Yf(t) && ("clamp(" === t.substr(0, 6) || t.indexOf("max") > -1);
      return (n["_" + e + "Clamp"] = i), i ? t.substr(6, t.length - 7) : t;
    },
    Nf = function (t, e) {
      return !e || (Yf(t) && "clamp(" === t.substr(0, 6))
        ? t
        : "clamp(" + t + ")";
    },
    Of = function t() {
      return If && requestAnimationFrame(t);
    },
    Ff = function () {
      return (rf = 1);
    },
    kf = function () {
      return (rf = 0);
    },
    zf = function (t) {
      return t;
    },
    Bf = function (t) {
      return Math.round(1e5 * t) / 1e5 || 0;
    },
    Hf = function () {
      return "undefined" != typeof window;
    },
    Gf = function () {
      return Wp || (Hf() && (Wp = window.gsap) && Wp.registerPlugin && Wp);
    },
    Vf = function (t) {
      return !!~Zp.indexOf(t);
    },
    Wf = function (t) {
      return (
        ("Height" === t ? Tf : jp["inner" + t]) ||
        Yp["client" + t] ||
        Kp["client" + t]
      );
    },
    Xf = function (t) {
      return (
        wp(t, "getBoundingClientRect") ||
        (Vf(t)
          ? function () {
              return (rg.width = jp.innerWidth), (rg.height = Tf), rg;
            }
          : function () {
              return _m(t);
            })
      );
    },
    jf = function (t, e) {
      var n = e.s,
        i = e.d2,
        r = e.d,
        s = e.a;
      return Math.max(
        0,
        (n = "scroll" + i) && (s = wp(t, n))
          ? s() - Xf(t)()[r]
          : Vf(t)
          ? (Yp[n] || Kp[n]) - Wf(i)
          : t[n] - t["offset" + i]
      );
    },
    qf = function (t, e) {
      for (var n = 0; n < cf.length; n += 3)
        (!e || ~e.indexOf(cf[n + 1])) && t(cf[n], cf[n + 1], cf[n + 2]);
    },
    Yf = function (t) {
      return "string" == typeof t;
    },
    Kf = function (t) {
      return "function" == typeof t;
    },
    Zf = function (t) {
      return "number" == typeof t;
    },
    Jf = function (t) {
      return "object" == typeof t;
    },
    Qf = function (t, e, n) {
      return t && t.progress(e ? 0 : 1) && n && t.pause();
    },
    $f = function (t, e) {
      if (t.enabled) {
        var n = t._ctx
          ? t._ctx.add(function () {
              return e(t);
            })
          : e(t);
        n && n.totalTime && (t.callbackAnimation = n);
      }
    },
    tm = Math.abs,
    em = "left",
    nm = "right",
    im = "bottom",
    rm = "width",
    sm = "height",
    am = "Right",
    om = "Left",
    lm = "Top",
    cm = "Bottom",
    hm = "padding",
    um = "margin",
    dm = "Width",
    pm = "Height",
    fm = "px",
    mm = function (t) {
      return jp.getComputedStyle(t);
    },
    gm = function (t, e) {
      for (var n in e) n in t || (t[n] = e[n]);
      return t;
    },
    _m = function (t, e) {
      var n =
          e &&
          "matrix(1, 0, 0, 1, 0, 0)" !== mm(t)[sf] &&
          Wp.to(t, {
            x: 0,
            y: 0,
            xPercent: 0,
            yPercent: 0,
            rotation: 0,
            rotationX: 0,
            rotationY: 0,
            scale: 1,
            skewX: 0,
            skewY: 0,
          }).progress(1),
        i = t.getBoundingClientRect();
      return n && n.progress(0).kill(), i;
    },
    vm = function (t, e) {
      var n = e.d2;
      return t["offset" + n] || t["client" + n] || 0;
    },
    ym = function (t) {
      var e,
        n = [],
        i = t.labels,
        r = t.duration();
      for (e in i) n.push(i[e] / r);
      return n;
    },
    xm = function (t) {
      var e = Wp.utils.snap(t),
        n =
          Array.isArray(t) &&
          t.slice(0).sort(function (t, e) {
            return t - e;
          });
      return n
        ? function (t, i, r) {
            var s;
            if ((void 0 === r && (r = 0.001), !i)) return e(t);
            if (i > 0) {
              for (t -= r, s = 0; s < n.length; s++) if (n[s] >= t) return n[s];
              return n[s - 1];
            }
            for (s = n.length, t += r; s--; ) if (n[s] <= t) return n[s];
            return n[0];
          }
        : function (n, i, r) {
            void 0 === r && (r = 0.001);
            var s = e(n);
            return !i || Math.abs(s - n) < r || s - n < 0 == i < 0
              ? s
              : e(i < 0 ? n - t : n + t);
          };
    },
    Tm = function (t, e, n, i) {
      return n.split(",").forEach(function (n) {
        return t(e, n, i);
      });
    },
    Mm = function (t, e, n, i, r) {
      return t.addEventListener(e, n, { passive: !i, capture: !!r });
    },
    Sm = function (t, e, n, i) {
      return t.removeEventListener(e, n, !!i);
    },
    bm = function (t, e, n) {
      (n = n && n.wheelHandler) && (t(e, "wheel", n), t(e, "touchmove", n));
    },
    Em = {
      startColor: "green",
      endColor: "red",
      indent: 0,
      fontSize: "16px",
      fontWeight: "normal",
    },
    wm = { toggleActions: "play", anticipatePin: 0 },
    Am = { top: 0, left: 0, center: 0.5, bottom: 1, right: 1 },
    Rm = function (t, e) {
      if (Yf(t)) {
        var n = t.indexOf("="),
          i = ~n ? +(t.charAt(n - 1) + 1) * parseFloat(t.substr(n + 1)) : 0;
        ~n && (t.indexOf("%") > n && (i *= e / 100), (t = t.substr(0, n - 1))),
          (t =
            i +
            (t in Am
              ? Am[t] * e
              : ~t.indexOf("%")
              ? (parseFloat(t) * e) / 100
              : parseFloat(t) || 0));
      }
      return t;
    },
    Cm = function (t, e, n, i, r, s, a, o) {
      var l = r.startColor,
        c = r.endColor,
        h = r.fontSize,
        u = r.indent,
        d = r.fontWeight,
        p = qp.createElement("div"),
        f = Vf(n) || "fixed" === wp(n, "pinType"),
        m = -1 !== t.indexOf("scroller"),
        g = f ? Kp : n,
        _ = -1 !== t.indexOf("start"),
        v = _ ? l : c,
        y =
          "border-color:" +
          v +
          ";font-size:" +
          h +
          ";color:" +
          v +
          ";font-weight:" +
          d +
          ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
      return (
        (y += "position:" + ((m || o) && f ? "fixed;" : "absolute;")),
        (m || o || !f) &&
          (y += (i === Np ? nm : im) + ":" + (s + parseFloat(u)) + "px;"),
        a &&
          (y +=
            "box-sizing:border-box;text-align:left;width:" +
            a.offsetWidth +
            "px;"),
        (p._isStart = _),
        p.setAttribute("class", "gsap-marker-" + t + (e ? " marker-" + e : "")),
        (p.style.cssText = y),
        (p.innerText = e || 0 === e ? t + "-" + e : t),
        g.children[0] ? g.insertBefore(p, g.children[0]) : g.appendChild(p),
        (p._offset = p["offset" + i.op.d2]),
        Pm(p, 0, i, _),
        p
      );
    },
    Pm = function (t, e, n, i) {
      var r = { display: "block" },
        s = n[i ? "os2" : "p2"],
        a = n[i ? "p2" : "os2"];
      (t._isFlipped = i),
        (r[n.a + "Percent"] = i ? -100 : 0),
        (r[n.a] = i ? "1px" : 0),
        (r["border" + s + dm] = 1),
        (r["border" + a + dm] = 0),
        (r[n.p] = e + "px"),
        Wp.set(t, r);
    },
    Lm = [],
    Dm = {},
    Im = function () {
      return Pf() - Df > 34 && (Ef || (Ef = requestAnimationFrame(Jm)));
    },
    Um = function () {
      (!pf || !pf.isPressed || pf.startX > Kp.clientWidth) &&
        (Mp.cache++,
        pf ? Ef || (Ef = requestAnimationFrame(Jm)) : Jm(),
        Df || Bm("scrollStart"),
        (Df = Pf()));
    },
    Nm = function () {
      (gf = jp.innerWidth), (mf = jp.innerHeight);
    },
    Om = function () {
      Mp.cache++,
        !nf &&
          !df &&
          !qp.fullscreenElement &&
          !qp.webkitFullscreenElement &&
          (!ff ||
            gf !== jp.innerWidth ||
            Math.abs(jp.innerHeight - mf) > 0.25 * jp.innerHeight) &&
          Jp.restart(!0);
    },
    Fm = {},
    km = [],
    zm = function t() {
      return Sm(ug, "scrollEnd", t) || Ym(!0);
    },
    Bm = function (t) {
      return (
        (Fm[t] &&
          Fm[t].map(function (t) {
            return t();
          })) ||
        km
      );
    },
    Hm = [],
    Gm = function (t) {
      for (var e = 0; e < Hm.length; e += 5)
        (!t || (Hm[e + 4] && Hm[e + 4].query === t)) &&
          ((Hm[e].style.cssText = Hm[e + 1]),
          Hm[e].getBBox && Hm[e].setAttribute("transform", Hm[e + 2] || ""),
          (Hm[e + 3].uncache = 1));
    },
    Vm = function (t, e) {
      var n;
      for (af = 0; af < Lm.length; af++)
        !(n = Lm[af]) ||
          (e && n._ctx !== e) ||
          (t ? n.kill(1) : n.revert(!0, !0));
      (Mf = !0), e && Gm(e), e || Bm("revert");
    },
    Wm = function (t, e) {
      Mp.cache++,
        (e || !wf) &&
          Mp.forEach(function (t) {
            return Kf(t) && t.cacheID++ && (t.rec = 0);
          }),
        Yf(t) && (jp.history.scrollRestoration = yf = t);
    },
    Xm = 0,
    jm = function () {
      Kp.appendChild(xf),
        (Tf = (!pf && xf.offsetHeight) || jp.innerHeight),
        Kp.removeChild(xf);
    },
    qm = function (t) {
      return Qp(
        ".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end"
      ).forEach(function (e) {
        return (e.style.display = t ? "none" : "block");
      });
    },
    Ym = function (t, e) {
      if (!Df || t || Mf) {
        jm(),
          (wf = ug.isRefreshing = !0),
          Mp.forEach(function (t) {
            return Kf(t) && ++t.cacheID && (t.rec = t());
          });
        var n = Bm("refreshInit");
        hf && ug.sort(),
          e || Vm(),
          Mp.forEach(function (t) {
            Kf(t) &&
              (t.smooth && (t.target.style.scrollBehavior = "auto"), t(0));
          }),
          Lm.slice(0).forEach(function (t) {
            return t.refresh();
          }),
          (Mf = !1),
          Lm.forEach(function (t) {
            if (t._subPinOffset && t.pin) {
              var e = t.vars.horizontal ? "offsetWidth" : "offsetHeight",
                n = t.pin[e];
              t.revert(!0, 1), t.adjustPinSpacing(t.pin[e] - n), t.refresh();
            }
          }),
          (Sf = 1),
          qm(!0),
          Lm.forEach(function (t) {
            var e = jf(t.scroller, t._dir),
              n = "max" === t.vars.end || (t._endClamp && t.end > e),
              i = t._startClamp && t.start >= e;
            (n || i) &&
              t.setPositions(
                i ? e - 1 : t.start,
                n ? Math.max(i ? e : t.start + 1, e) : t.end,
                !0
              );
          }),
          qm(!1),
          (Sf = 0),
          n.forEach(function (t) {
            return t && t.render && t.render(-1);
          }),
          Mp.forEach(function (t) {
            Kf(t) &&
              (t.smooth &&
                requestAnimationFrame(function () {
                  return (t.target.style.scrollBehavior = "smooth");
                }),
              t.rec && t(t.rec));
          }),
          Wm(yf, 1),
          Jp.pause(),
          Xm++,
          (wf = 2),
          Jm(2),
          Lm.forEach(function (t) {
            return Kf(t.vars.onRefresh) && t.vars.onRefresh(t);
          }),
          (wf = ug.isRefreshing = !1),
          Bm("refresh");
      } else Mm(ug, "scrollEnd", zm);
    },
    Km = 0,
    Zm = 1,
    Jm = function (t) {
      if (2 === t || (!wf && !Mf)) {
        (ug.isUpdating = !0), Rf && Rf.update(0);
        var e = Lm.length,
          n = Pf(),
          i = n - Lf >= 50,
          r = e && Lm[0].scroll();
        if (
          ((Zm = Km > r ? -1 : 1),
          wf || (Km = r),
          i &&
            (Df && !rf && n - Df > 200 && ((Df = 0), Bm("scrollEnd")),
            (tf = Lf),
            (Lf = n)),
          Zm < 0)
        ) {
          for (af = e; af-- > 0; ) Lm[af] && Lm[af].update(0, i);
          Zm = 1;
        } else for (af = 0; af < e; af++) Lm[af] && Lm[af].update(0, i);
        ug.isUpdating = !1;
      }
      Ef = 0;
    },
    Qm = [
      em,
      "top",
      im,
      nm,
      um + cm,
      um + am,
      um + lm,
      um + om,
      "display",
      "flexShrink",
      "float",
      "zIndex",
      "gridColumnStart",
      "gridColumnEnd",
      "gridRowStart",
      "gridRowEnd",
      "gridArea",
      "justifySelf",
      "alignSelf",
      "placeSelf",
      "order",
    ],
    $m = Qm.concat([
      rm,
      sm,
      "boxSizing",
      "max" + dm,
      "max" + pm,
      "position",
      um,
      hm,
      hm + lm,
      hm + am,
      hm + cm,
      hm + om,
    ]),
    tg = function (t, e, n, i) {
      if (!t._gsap.swappedIn) {
        for (var r, s = Qm.length, a = e.style, o = t.style; s--; )
          a[(r = Qm[s])] = n[r];
        (a.position = "absolute" === n.position ? "absolute" : "relative"),
          "inline" === n.display && (a.display = "inline-block"),
          (o[im] = o[nm] = "auto"),
          (a.flexBasis = n.flexBasis || "auto"),
          (a.overflow = "visible"),
          (a.boxSizing = "border-box"),
          (a[rm] = vm(t, Up) + fm),
          (a[sm] = vm(t, Np) + fm),
          (a[hm] = o[um] = o.top = o[em] = "0"),
          ng(i),
          (o[rm] = o["max" + dm] = n[rm]),
          (o[sm] = o["max" + pm] = n[sm]),
          (o[hm] = n[hm]),
          t.parentNode !== e &&
            (t.parentNode.insertBefore(e, t), e.appendChild(t)),
          (t._gsap.swappedIn = !0);
      }
    },
    eg = /([A-Z])/g,
    ng = function (t) {
      if (t) {
        var e,
          n,
          i = t.t.style,
          r = t.length,
          s = 0;
        for ((t.t._gsap || Wp.core.getCache(t.t)).uncache = 1; s < r; s += 2)
          (n = t[s + 1]),
            (e = t[s]),
            n
              ? (i[e] = n)
              : i[e] && i.removeProperty(e.replace(eg, "-$1").toLowerCase());
      }
    },
    ig = function (t) {
      for (var e = $m.length, n = t.style, i = [], r = 0; r < e; r++)
        i.push($m[r], n[$m[r]]);
      return (i.t = t), i;
    },
    rg = { left: 0, top: 0 },
    sg = function (t, e, n, i, r, s, a, o, l, c, h, u, d, p) {
      Kf(t) && (t = t(o)),
        Yf(t) &&
          "max" === t.substr(0, 3) &&
          (t = u + ("=" === t.charAt(4) ? Rm("0" + t.substr(3), n) : 0));
      var f,
        m,
        g,
        _ = d ? d.time() : 0;
      if ((d && d.seek(0), isNaN(t) || (t = +t), Zf(t)))
        d &&
          (t = Wp.utils.mapRange(
            d.scrollTrigger.start,
            d.scrollTrigger.end,
            0,
            u,
            t
          )),
          a && Pm(a, n, i, !0);
      else {
        Kf(e) && (e = e(o));
        var v,
          y,
          x,
          T,
          M = (t || "0").split(" ");
        (g = Op(e, o) || Kp),
          ((v = _m(g) || {}) && (v.left || v.top)) ||
            "none" !== mm(g).display ||
            ((T = g.style.display),
            (g.style.display = "block"),
            (v = _m(g)),
            T ? (g.style.display = T) : g.style.removeProperty("display")),
          (y = Rm(M[0], v[i.d])),
          (x = Rm(M[1] || "0", n)),
          (t = v[i.p] - l[i.p] - c + y + r - x),
          a && Pm(a, x, i, n - x < 20 || (a._isStart && x > 20)),
          (n -= n - x);
      }
      if ((p && ((o[p] = t || -0.001), t < 0 && (t = 0)), s)) {
        var S = t + n,
          b = s._isStart;
        (f = "scroll" + i.d2),
          Pm(
            s,
            S,
            i,
            (b && S > 20) ||
              (!b && (h ? Math.max(Kp[f], Yp[f]) : s.parentNode[f]) <= S + 1)
          ),
          h &&
            ((l = _m(a)),
            h && (s.style[i.op.p] = l[i.op.p] - i.op.m - s._offset + fm));
      }
      return (
        d &&
          g &&
          ((f = _m(g)),
          d.seek(u),
          (m = _m(g)),
          (d._caScrollDist = f[i.p] - m[i.p]),
          (t = (t / d._caScrollDist) * u)),
        d && d.seek(_),
        d ? t : Math.round(t)
      );
    },
    ag = /(webkit|moz|length|cssText|inset)/i,
    og = function (t, e, n, i) {
      if (t.parentNode !== e) {
        var r,
          s,
          a = t.style;
        if (e === Kp) {
          for (r in ((t._stOrig = a.cssText), (s = mm(t))))
            +r ||
              ag.test(r) ||
              !s[r] ||
              "string" != typeof a[r] ||
              "0" === r ||
              (a[r] = s[r]);
          (a.top = n), (a.left = i);
        } else a.cssText = t._stOrig;
        (Wp.core.getCache(t).uncache = 1), e.appendChild(t);
      }
    },
    lg = function (t, e, n) {
      var i = e,
        r = i;
      return function (e) {
        var s = Math.round(t());
        return (
          s !== i &&
            s !== r &&
            Math.abs(s - i) > 3 &&
            Math.abs(s - r) > 3 &&
            ((e = s), n && n()),
          (r = i),
          (i = e),
          e
        );
      };
    },
    cg = function (t, e, n) {
      var i = {};
      (i[e.p] = "+=" + n), Wp.set(t, i);
    },
    hg = function (t, e) {
      var n = Fp(t, e),
        i = "_scroll" + e.p2,
        r = function e(r, s, a, o, l) {
          var c = e.tween,
            h = s.onComplete,
            u = {};
          a = a || n();
          var d = lg(n, a, function () {
            c.kill(), (e.tween = 0);
          });
          return (
            (l = (o && l) || 0),
            (o = o || r - a),
            c && c.kill(),
            (s[i] = r),
            (s.modifiers = u),
            (u[i] = function () {
              return d(a + o * c.ratio + l * c.ratio * c.ratio);
            }),
            (s.onUpdate = function () {
              Mp.cache++, e.tween && Jm();
            }),
            (s.onComplete = function () {
              (e.tween = 0), h && h.call(c);
            }),
            (c = e.tween = Wp.to(t, s))
          );
        };
      return (
        (t[i] = n),
        (n.wheelHandler = function () {
          return r.tween && r.tween.kill() && (r.tween = 0);
        }),
        Mm(t, "wheel", n.wheelHandler),
        ug.isTouch && Mm(t, "touchmove", n.wheelHandler),
        r
      );
    },
    ug = (function () {
      function t(e, n) {
        Xp ||
          t.register(Wp) ||
          console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
          vf(this),
          this.init(e, n);
      }
      return (
        (t.prototype.init = function (e, n) {
          if (
            ((this.progress = this.start = 0),
            this.vars && this.kill(!0, !0),
            If)
          ) {
            var i,
              r,
              s,
              a,
              o,
              l,
              c,
              h,
              u,
              d,
              p,
              f,
              m,
              g,
              _,
              v,
              y,
              x,
              T,
              M,
              S,
              b,
              E,
              w,
              A,
              R,
              C,
              P,
              L,
              D,
              I,
              U,
              N,
              O,
              F,
              k,
              z,
              B,
              H,
              G,
              V,
              W,
              X = (e = gm(
                Yf(e) || Zf(e) || e.nodeType ? { trigger: e } : e,
                wm
              )),
              j = X.onUpdate,
              q = X.toggleClass,
              Y = X.id,
              K = X.onToggle,
              Z = X.onRefresh,
              J = X.scrub,
              Q = X.trigger,
              $ = X.pin,
              tt = X.pinSpacing,
              et = X.invalidateOnRefresh,
              nt = X.anticipatePin,
              it = X.onScrubComplete,
              rt = X.onSnapComplete,
              st = X.once,
              at = X.snap,
              ot = X.pinReparent,
              lt = X.pinSpacer,
              ct = X.containerAnimation,
              ht = X.fastScrollEnd,
              ut = X.preventOverlaps,
              dt =
                e.horizontal || (e.containerAnimation && !1 !== e.horizontal)
                  ? Up
                  : Np,
              pt = !J && 0 !== J,
              ft = Op(e.scroller || jp),
              mt = Wp.core.getCache(ft),
              gt = Vf(ft),
              _t =
                "fixed" ===
                ("pinType" in e
                  ? e.pinType
                  : wp(ft, "pinType") || (gt && "fixed")),
              vt = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack],
              yt = pt && e.toggleActions.split(" "),
              xt = "markers" in e ? e.markers : wm.markers,
              Tt = gt ? 0 : parseFloat(mm(ft)["border" + dt.p2 + dm]) || 0,
              Mt = this,
              St =
                e.onRefreshInit &&
                function () {
                  return e.onRefreshInit(Mt);
                },
              bt = (function (t, e, n) {
                var i = n.d,
                  r = n.d2,
                  s = n.a;
                return (s = wp(t, "getBoundingClientRect"))
                  ? function () {
                      return s()[i];
                    }
                  : function () {
                      return (e ? Wf(r) : t["client" + r]) || 0;
                    };
              })(ft, gt, dt),
              Et = (function (t, e) {
                return !e || ~Sp.indexOf(t)
                  ? Xf(t)
                  : function () {
                      return rg;
                    };
              })(ft, gt),
              wt = 0,
              At = 0,
              Rt = 0,
              Ct = Fp(ft, dt);
            if (
              ((Mt._startClamp = Mt._endClamp = !1),
              (Mt._dir = dt),
              (nt *= 45),
              (Mt.scroller = ft),
              (Mt.scroll = ct ? ct.time.bind(ct) : Ct),
              (a = Ct()),
              (Mt.vars = e),
              (n = n || e.animation),
              "refreshPriority" in e &&
                ((hf = 1), -9999 === e.refreshPriority && (Rf = Mt)),
              (mt.tweenScroll = mt.tweenScroll || {
                top: hg(ft, Np),
                left: hg(ft, Up),
              }),
              (Mt.tweenTo = i = mt.tweenScroll[dt.p]),
              (Mt.scrubDuration = function (t) {
                (N = Zf(t) && t)
                  ? U
                    ? U.duration(t)
                    : (U = Wp.to(n, {
                        ease: "expo",
                        totalProgress: "+=0",
                        duration: N,
                        paused: !0,
                        onComplete: function () {
                          return it && it(Mt);
                        },
                      }))
                  : (U && U.progress(1).kill(), (U = 0));
              }),
              n &&
                ((n.vars.lazy = !1),
                (n._initted && !Mt.isReverted) ||
                  (!1 !== n.vars.immediateRender &&
                    !1 !== e.immediateRender &&
                    n.duration() &&
                    n.render(0, !0, !0)),
                (Mt.animation = n.pause()),
                (n.scrollTrigger = Mt),
                Mt.scrubDuration(J),
                (D = 0),
                Y || (Y = n.vars.id)),
              at &&
                ((Jf(at) && !at.push) || (at = { snapTo: at }),
                "scrollBehavior" in Kp.style &&
                  Wp.set(gt ? [Kp, Yp] : ft, { scrollBehavior: "auto" }),
                Mp.forEach(function (t) {
                  return (
                    Kf(t) &&
                    t.target === (gt ? qp.scrollingElement || Yp : ft) &&
                    (t.smooth = !1)
                  );
                }),
                (s = Kf(at.snapTo)
                  ? at.snapTo
                  : "labels" === at.snapTo
                  ? (function (t) {
                      return function (e) {
                        return Wp.utils.snap(ym(t), e);
                      };
                    })(n)
                  : "labelsDirectional" === at.snapTo
                  ? ((G = n),
                    function (t, e) {
                      return xm(ym(G))(t, e.direction);
                    })
                  : !1 !== at.directional
                  ? function (t, e) {
                      return xm(at.snapTo)(
                        t,
                        Pf() - At < 500 ? 0 : e.direction
                      );
                    }
                  : Wp.utils.snap(at.snapTo)),
                (O = at.duration || { min: 0.1, max: 2 }),
                (O = Jf(O) ? $p(O.min, O.max) : $p(O, O)),
                (F = Wp.delayedCall(at.delay || N / 2 || 0.1, function () {
                  var t = Ct(),
                    e = Pf() - At < 500,
                    r = i.tween;
                  if (
                    !(e || Math.abs(Mt.getVelocity()) < 10) ||
                    r ||
                    rf ||
                    wt === t
                  )
                    Mt.isActive && wt !== t && F.restart(!0);
                  else {
                    var a = (t - l) / g,
                      o = n && !pt ? n.totalProgress() : a,
                      h = e ? 0 : ((o - I) / (Pf() - tf)) * 1e3 || 0,
                      u = Wp.utils.clamp(-a, 1 - a, (tm(h / 2) * h) / 0.185),
                      d = a + (!1 === at.inertia ? 0 : u),
                      p = $p(0, 1, s(d, Mt)),
                      f = Math.round(l + p * g),
                      m = at,
                      _ = m.onStart,
                      v = m.onInterrupt,
                      y = m.onComplete;
                    if (t <= c && t >= l && f !== t) {
                      if (r && !r._initted && r.data <= tm(f - t)) return;
                      !1 === at.inertia && (u = p - a),
                        i(
                          f,
                          {
                            duration: O(
                              tm(
                                (0.185 * Math.max(tm(d - o), tm(p - o))) /
                                  h /
                                  0.05 || 0
                              )
                            ),
                            ease: at.ease || "power3",
                            data: tm(f - t),
                            onInterrupt: function () {
                              return F.restart(!0) && v && v(Mt);
                            },
                            onComplete: function () {
                              Mt.update(),
                                (wt = Ct()),
                                U && n && n.progress(p),
                                (D = I =
                                  n && !pt ? n.totalProgress() : Mt.progress),
                                rt && rt(Mt),
                                y && y(Mt);
                            },
                          },
                          t,
                          u * g,
                          f - t - u * g
                        ),
                        _ && _(Mt, i.tween);
                    }
                  }
                }).pause())),
              Y && (Dm[Y] = Mt),
              (H =
                (Q = Mt.trigger = Op(Q || (!0 !== $ && $))) &&
                Q._gsap &&
                Q._gsap.stRevert) && (H = H(Mt)),
              ($ = !0 === $ ? Q : Op($)),
              Yf(q) && (q = { targets: Q, className: q }),
              $ &&
                (!1 === tt ||
                  tt === um ||
                  (tt =
                    !(
                      !tt &&
                      $.parentNode &&
                      $.parentNode.style &&
                      "flex" === mm($.parentNode).display
                    ) && hm),
                (Mt.pin = $),
                (r = Wp.core.getCache($)).spacer
                  ? (_ = r.pinState)
                  : (lt &&
                      ((lt = Op(lt)) &&
                        !lt.nodeType &&
                        (lt = lt.current || lt.nativeElement),
                      (r.spacerIsNative = !!lt),
                      lt && (r.spacerState = ig(lt))),
                    (r.spacer = x = lt || qp.createElement("div")),
                    x.classList.add("pin-spacer"),
                    Y && x.classList.add("pin-spacer-" + Y),
                    (r.pinState = _ = ig($))),
                !1 !== e.force3D && Wp.set($, { force3D: !0 }),
                (Mt.spacer = x = r.spacer),
                (L = mm($)),
                (w = L[tt + dt.os2]),
                (M = Wp.getProperty($)),
                (S = Wp.quickSetter($, dt.a, fm)),
                tg($, x, L),
                (y = ig($))),
              xt)
            ) {
              (f = Jf(xt) ? gm(xt, Em) : Em),
                (d = Cm("scroller-start", Y, ft, dt, f, 0)),
                (p = Cm("scroller-end", Y, ft, dt, f, 0, d)),
                (T = d["offset" + dt.op.d2]);
              var Pt = Op(wp(ft, "content") || ft);
              (h = this.markerStart = Cm("start", Y, Pt, dt, f, T, 0, ct)),
                (u = this.markerEnd = Cm("end", Y, Pt, dt, f, T, 0, ct)),
                ct && (B = Wp.quickSetter([h, u], dt.a, fm)),
                _t ||
                  (Sp.length && !0 === wp(ft, "fixedMarkers")) ||
                  ((W = mm((V = gt ? Kp : ft)).position),
                  (V.style.position =
                    "absolute" === W || "fixed" === W ? W : "relative"),
                  Wp.set([d, p], { force3D: !0 }),
                  (R = Wp.quickSetter(d, dt.a, fm)),
                  (P = Wp.quickSetter(p, dt.a, fm)));
            }
            if (ct) {
              var Lt = ct.vars.onUpdate,
                Dt = ct.vars.onUpdateParams;
              ct.eventCallback("onUpdate", function () {
                Mt.update(0, 0, 1), Lt && Lt.apply(ct, Dt || []);
              });
            }
            if (
              ((Mt.previous = function () {
                return Lm[Lm.indexOf(Mt) - 1];
              }),
              (Mt.next = function () {
                return Lm[Lm.indexOf(Mt) + 1];
              }),
              (Mt.revert = function (t, e) {
                if (!e) return Mt.kill(!0);
                var i = !1 !== t || !Mt.enabled,
                  r = nf;
                i !== Mt.isReverted &&
                  (i &&
                    ((k = Math.max(Ct(), Mt.scroll.rec || 0)),
                    (Rt = Mt.progress),
                    (z = n && n.progress())),
                  h &&
                    [h, u, d, p].forEach(function (t) {
                      return (t.style.display = i ? "none" : "block");
                    }),
                  i && ((nf = Mt), Mt.update(i)),
                  !$ ||
                    (ot && Mt.isActive) ||
                    (i
                      ? (function (t, e, n) {
                          ng(n);
                          var i = t._gsap;
                          if (i.spacerIsNative) ng(i.spacerState);
                          else if (t._gsap.swappedIn) {
                            var r = e.parentNode;
                            r && (r.insertBefore(t, e), r.removeChild(e));
                          }
                          t._gsap.swappedIn = !1;
                        })($, x, _)
                      : tg($, x, mm($), A)),
                  i || Mt.update(i),
                  (nf = r),
                  (Mt.isReverted = i));
              }),
              (Mt.refresh = function (r, s, f, T) {
                if ((!nf && Mt.enabled) || s)
                  if ($ && r && Df) Mm(t, "scrollEnd", zm);
                  else {
                    !wf && St && St(Mt),
                      (nf = Mt),
                      i.tween && !f && (i.tween.kill(), (i.tween = 0)),
                      U && U.pause(),
                      et && n && n.revert({ kill: !1 }).invalidate(),
                      Mt.isReverted || Mt.revert(!0, !0),
                      (Mt._subPinOffset = !1);
                    var S,
                      w,
                      R,
                      P,
                      L,
                      D,
                      I,
                      N,
                      O,
                      B,
                      H,
                      G,
                      V,
                      W = bt(),
                      X = Et(),
                      j = ct ? ct.duration() : jf(ft, dt),
                      q = g <= 0.01,
                      Y = 0,
                      K = T || 0,
                      J = Jf(f) ? f.end : e.end,
                      nt = e.endTrigger || Q,
                      it = Jf(f)
                        ? f.start
                        : e.start ||
                          (0 !== e.start && Q ? ($ ? "0 0" : "0 100%") : 0),
                      rt = (Mt.pinnedContainer =
                        e.pinnedContainer && Op(e.pinnedContainer, Mt)),
                      st = (Q && Math.max(0, Lm.indexOf(Mt))) || 0,
                      at = st;
                    for (
                      xt &&
                      Jf(f) &&
                      ((G = Wp.getProperty(d, dt.p)),
                      (V = Wp.getProperty(p, dt.p)));
                      at--;

                    )
                      (D = Lm[at]).end || D.refresh(0, 1) || (nf = Mt),
                        !(I = D.pin) ||
                          (I !== Q && I !== $ && I !== rt) ||
                          D.isReverted ||
                          (B || (B = []), B.unshift(D), D.revert(!0, !0)),
                        D !== Lm[at] && (st--, at--);
                    for (
                      Kf(it) && (it = it(Mt)),
                        it = Uf(it, "start", Mt),
                        l =
                          sg(
                            it,
                            Q,
                            W,
                            dt,
                            Ct(),
                            h,
                            d,
                            Mt,
                            X,
                            Tt,
                            _t,
                            j,
                            ct,
                            Mt._startClamp && "_startClamp"
                          ) || ($ ? -0.001 : 0),
                        Kf(J) && (J = J(Mt)),
                        Yf(J) &&
                          !J.indexOf("+=") &&
                          (~J.indexOf(" ")
                            ? (J = (Yf(it) ? it.split(" ")[0] : "") + J)
                            : ((Y = Rm(J.substr(2), W)),
                              (J = Yf(it)
                                ? it
                                : (ct
                                    ? Wp.utils.mapRange(
                                        0,
                                        ct.duration(),
                                        ct.scrollTrigger.start,
                                        ct.scrollTrigger.end,
                                        l
                                      )
                                    : l) + Y),
                              (nt = Q))),
                        J = Uf(J, "end", Mt),
                        c =
                          Math.max(
                            l,
                            sg(
                              J || (nt ? "100% 0" : j),
                              nt,
                              W,
                              dt,
                              Ct() + Y,
                              u,
                              p,
                              Mt,
                              X,
                              Tt,
                              _t,
                              j,
                              ct,
                              Mt._endClamp && "_endClamp"
                            )
                          ) || -0.001,
                        Y = 0,
                        at = st;
                      at--;

                    )
                      (I = (D = Lm[at]).pin) &&
                        D.start - D._pinPush <= l &&
                        !ct &&
                        D.end > 0 &&
                        ((S =
                          D.end -
                          (Mt._startClamp ? Math.max(0, D.start) : D.start)),
                        ((I === Q && D.start - D._pinPush < l) || I === rt) &&
                          isNaN(it) &&
                          (Y += S * (1 - D.progress)),
                        I === $ && (K += S));
                    if (
                      ((l += Y),
                      (c += Y),
                      Mt._startClamp && (Mt._startClamp += Y),
                      Mt._endClamp &&
                        !wf &&
                        ((Mt._endClamp = c || -0.001),
                        (c = Math.min(c, jf(ft, dt)))),
                      (g = c - l || ((l -= 0.01) && 0.001)),
                      q &&
                        (Rt = Wp.utils.clamp(
                          0,
                          1,
                          Wp.utils.normalize(l, c, k)
                        )),
                      (Mt._pinPush = K),
                      h &&
                        Y &&
                        (((S = {})[dt.a] = "+=" + Y),
                        rt && (S[dt.p] = "-=" + Ct()),
                        Wp.set([h, u], S)),
                      !$ || (Sf && Mt.end >= jf(ft, dt)))
                    ) {
                      if (Q && Ct() && !ct)
                        for (w = Q.parentNode; w && w !== Kp; )
                          w._pinOffset &&
                            ((l -= w._pinOffset), (c -= w._pinOffset)),
                            (w = w.parentNode);
                    } else
                      (S = mm($)),
                        (P = dt === Np),
                        (R = Ct()),
                        (b = parseFloat(M(dt.a)) + K),
                        !j &&
                          c > 1 &&
                          ((H = {
                            style: (H = (gt ? qp.scrollingElement || Yp : ft)
                              .style),
                            value: H["overflow" + dt.a.toUpperCase()],
                          }),
                          gt &&
                            "scroll" !==
                              mm(Kp)["overflow" + dt.a.toUpperCase()] &&
                            (H.style["overflow" + dt.a.toUpperCase()] =
                              "scroll")),
                        tg($, x, S),
                        (y = ig($)),
                        (w = _m($, !0)),
                        (N = _t && Fp(ft, P ? Up : Np)()),
                        tt &&
                          (((A = [tt + dt.os2, g + K + fm]).t = x),
                          (at = tt === hm ? vm($, dt) + g + K : 0) &&
                            (A.push(dt.d, at + fm),
                            "auto" !== x.style.flexBasis &&
                              (x.style.flexBasis = at + fm)),
                          ng(A),
                          rt &&
                            Lm.forEach(function (t) {
                              t.pin === rt &&
                                !1 !== t.vars.pinSpacing &&
                                (t._subPinOffset = !0);
                            }),
                          _t && Ct(k)),
                        _t &&
                          (((L = {
                            top: w.top + (P ? R - l : N) + fm,
                            left: w.left + (P ? N : R - l) + fm,
                            boxSizing: "border-box",
                            position: "fixed",
                          })[rm] = L["max" + dm] =
                            Math.ceil(w.width) + fm),
                          (L[sm] = L["max" + pm] = Math.ceil(w.height) + fm),
                          (L[um] =
                            L[um + lm] =
                            L[um + am] =
                            L[um + cm] =
                            L[um + om] =
                              "0"),
                          (L[hm] = S[hm]),
                          (L[hm + lm] = S[hm + lm]),
                          (L[hm + am] = S[hm + am]),
                          (L[hm + cm] = S[hm + cm]),
                          (L[hm + om] = S[hm + om]),
                          (v = (function (t, e, n) {
                            for (
                              var i, r = [], s = t.length, a = n ? 8 : 0;
                              a < s;
                              a += 2
                            )
                              (i = t[a]), r.push(i, i in e ? e[i] : t[a + 1]);
                            return (r.t = t.t), r;
                          })(_, L, ot)),
                          wf && Ct(0)),
                        n
                          ? ((O = n._initted),
                            uf(1),
                            n.render(n.duration(), !0, !0),
                            (E = M(dt.a) - b + g + K),
                            (C = Math.abs(g - E) > 1),
                            _t && C && v.splice(v.length - 2, 2),
                            n.render(0, !0, !0),
                            O || n.invalidate(!0),
                            n.parent || n.totalTime(n.totalTime()),
                            uf(0))
                          : (E = g),
                        H &&
                          (H.value
                            ? (H.style["overflow" + dt.a.toUpperCase()] =
                                H.value)
                            : H.style.removeProperty("overflow-" + dt.a));
                    B &&
                      B.forEach(function (t) {
                        return t.revert(!1, !0);
                      }),
                      (Mt.start = l),
                      (Mt.end = c),
                      (a = o = wf ? k : Ct()),
                      ct || wf || (a < k && Ct(k), (Mt.scroll.rec = 0)),
                      Mt.revert(!1, !0),
                      (At = Pf()),
                      F && ((wt = -1), F.restart(!0)),
                      (nf = 0),
                      n &&
                        pt &&
                        (n._initted || z) &&
                        n.progress() !== z &&
                        n.progress(z || 0, !0).render(n.time(), !0, !0),
                      (q || Rt !== Mt.progress || ct) &&
                        (n &&
                          !pt &&
                          n.totalProgress(
                            ct && l < -0.001 && !Rt
                              ? Wp.utils.normalize(l, c, 0)
                              : Rt,
                            !0
                          ),
                        (Mt.progress = q || (a - l) / g === Rt ? 0 : Rt)),
                      $ && tt && (x._pinOffset = Math.round(Mt.progress * E)),
                      U && U.invalidate(),
                      isNaN(G) ||
                        ((G -= Wp.getProperty(d, dt.p)),
                        (V -= Wp.getProperty(p, dt.p)),
                        cg(d, dt, G),
                        cg(h, dt, G - (T || 0)),
                        cg(p, dt, V),
                        cg(u, dt, V - (T || 0))),
                      q && !wf && Mt.update(),
                      !Z || wf || m || ((m = !0), Z(Mt), (m = !1));
                  }
              }),
              (Mt.getVelocity = function () {
                return ((Ct() - o) / (Pf() - tf)) * 1e3 || 0;
              }),
              (Mt.endAnimation = function () {
                Qf(Mt.callbackAnimation),
                  n &&
                    (U
                      ? U.progress(1)
                      : n.paused()
                      ? pt || Qf(n, Mt.direction < 0, 1)
                      : Qf(n, n.reversed()));
              }),
              (Mt.labelToScroll = function (t) {
                return (
                  (n &&
                    n.labels &&
                    (l || Mt.refresh() || l) +
                      (n.labels[t] / n.duration()) * g) ||
                  0
                );
              }),
              (Mt.getTrailing = function (t) {
                var e = Lm.indexOf(Mt),
                  n =
                    Mt.direction > 0
                      ? Lm.slice(0, e).reverse()
                      : Lm.slice(e + 1);
                return (
                  Yf(t)
                    ? n.filter(function (e) {
                        return e.vars.preventOverlaps === t;
                      })
                    : n
                ).filter(function (t) {
                  return Mt.direction > 0 ? t.end <= l : t.start >= c;
                });
              }),
              (Mt.update = function (t, e, r) {
                if (!ct || r || t) {
                  var s,
                    h,
                    u,
                    p,
                    f,
                    m,
                    _,
                    T = !0 === wf ? k : Mt.scroll(),
                    M = t ? 0 : (T - l) / g,
                    A = M < 0 ? 0 : M > 1 ? 1 : M || 0,
                    L = Mt.progress;
                  if (
                    (e &&
                      ((o = a),
                      (a = ct ? Ct() : T),
                      at && ((I = D), (D = n && !pt ? n.totalProgress() : A))),
                    nt &&
                      !A &&
                      $ &&
                      !nf &&
                      !Cf &&
                      Df &&
                      l < T + ((T - o) / (Pf() - tf)) * nt &&
                      (A = 1e-4),
                    A !== L && Mt.enabled)
                  ) {
                    if (
                      ((p =
                        (f =
                          (s = Mt.isActive = !!A && A < 1) != (!!L && L < 1)) ||
                        !!A != !!L),
                      (Mt.direction = A > L ? 1 : -1),
                      (Mt.progress = A),
                      p &&
                        !nf &&
                        ((h = A && !L ? 0 : 1 === A ? 1 : 1 === L ? 2 : 3),
                        pt &&
                          ((u =
                            (!f && "none" !== yt[h + 1] && yt[h + 1]) || yt[h]),
                          (_ =
                            n &&
                            ("complete" === u || "reset" === u || u in n)))),
                      ut &&
                        (f || _) &&
                        (_ || J || !n) &&
                        (Kf(ut)
                          ? ut(Mt)
                          : Mt.getTrailing(ut).forEach(function (t) {
                              return t.endAnimation();
                            })),
                      pt ||
                        (!U || nf || Cf
                          ? n && n.totalProgress(A, !(!nf || (!At && !t)))
                          : (U._dp._time - U._start !== U._time &&
                              U.render(U._dp._time - U._start),
                            U.resetTo
                              ? U.resetTo(
                                  "totalProgress",
                                  A,
                                  n._tTime / n._tDur
                                )
                              : ((U.vars.totalProgress = A),
                                U.invalidate().restart()))),
                      $)
                    )
                      if ((t && tt && (x.style[tt + dt.os2] = w), _t)) {
                        if (p) {
                          if (
                            ((m =
                              !t && A > L && c + 1 > T && T + 1 >= jf(ft, dt)),
                            ot)
                          )
                            if (t || (!s && !m)) og($, x);
                            else {
                              var N = _m($, !0),
                                O = T - l;
                              og(
                                $,
                                Kp,
                                N.top + (dt === Np ? O : 0) + fm,
                                N.left + (dt === Np ? 0 : O) + fm
                              );
                            }
                          ng(s || m ? v : y),
                            (C && A < 1 && s) || S(b + (1 !== A || m ? 0 : E));
                        }
                      } else S(Bf(b + E * A));
                    at && !i.tween && !nf && !Cf && F.restart(!0),
                      q &&
                        (f || (st && A && (A < 1 || !bf))) &&
                        Qp(q.targets).forEach(function (t) {
                          return t.classList[s || st ? "add" : "remove"](
                            q.className
                          );
                        }),
                      j && !pt && !t && j(Mt),
                      p && !nf
                        ? (pt &&
                            (_ &&
                              ("complete" === u
                                ? n.pause().totalProgress(1)
                                : "reset" === u
                                ? n.restart(!0).pause()
                                : "restart" === u
                                ? n.restart(!0)
                                : n[u]()),
                            j && j(Mt)),
                          (!f && bf) ||
                            (K && f && $f(Mt, K),
                            vt[h] && $f(Mt, vt[h]),
                            st && (1 === A ? Mt.kill(!1, 1) : (vt[h] = 0)),
                            f || (vt[(h = 1 === A ? 1 : 3)] && $f(Mt, vt[h]))),
                          ht &&
                            !s &&
                            Math.abs(Mt.getVelocity()) > (Zf(ht) ? ht : 2500) &&
                            (Qf(Mt.callbackAnimation),
                            U
                              ? U.progress(1)
                              : Qf(n, "reverse" === u ? 1 : !A, 1)))
                        : pt && j && !nf && j(Mt);
                  }
                  if (P) {
                    var z = ct
                      ? (T / ct.duration()) * (ct._caScrollDist || 0)
                      : T;
                    R(z + (d._isFlipped ? 1 : 0)), P(z);
                  }
                  B && B((-T / ct.duration()) * (ct._caScrollDist || 0));
                }
              }),
              (Mt.enable = function (e, n) {
                Mt.enabled ||
                  ((Mt.enabled = !0),
                  Mm(ft, "resize", Om),
                  gt || Mm(ft, "scroll", Um),
                  St && Mm(t, "refreshInit", St),
                  !1 !== e && ((Mt.progress = Rt = 0), (a = o = wt = Ct())),
                  !1 !== n && Mt.refresh());
              }),
              (Mt.getTween = function (t) {
                return t && i ? i.tween : U;
              }),
              (Mt.setPositions = function (t, e, n, i) {
                if (ct) {
                  var r = ct.scrollTrigger,
                    s = ct.duration(),
                    a = r.end - r.start;
                  (t = r.start + (a * t) / s), (e = r.start + (a * e) / s);
                }
                Mt.refresh(
                  !1,
                  !1,
                  {
                    start: Nf(t, n && !!Mt._startClamp),
                    end: Nf(e, n && !!Mt._endClamp),
                  },
                  i
                ),
                  Mt.update();
              }),
              (Mt.adjustPinSpacing = function (t) {
                if (A && t) {
                  var e = A.indexOf(dt.d) + 1;
                  (A[e] = parseFloat(A[e]) + t + fm),
                    (A[1] = parseFloat(A[1]) + t + fm),
                    ng(A);
                }
              }),
              (Mt.disable = function (e, n) {
                if (
                  Mt.enabled &&
                  (!1 !== e && Mt.revert(!0, !0),
                  (Mt.enabled = Mt.isActive = !1),
                  n || (U && U.pause()),
                  (k = 0),
                  r && (r.uncache = 1),
                  St && Sm(t, "refreshInit", St),
                  F && (F.pause(), i.tween && i.tween.kill() && (i.tween = 0)),
                  !gt)
                ) {
                  for (var s = Lm.length; s--; )
                    if (Lm[s].scroller === ft && Lm[s] !== Mt) return;
                  Sm(ft, "resize", Om), gt || Sm(ft, "scroll", Um);
                }
              }),
              (Mt.kill = function (t, i) {
                Mt.disable(t, i), U && !i && U.kill(), Y && delete Dm[Y];
                var s = Lm.indexOf(Mt);
                s >= 0 && Lm.splice(s, 1),
                  s === af && Zm > 0 && af--,
                  (s = 0),
                  Lm.forEach(function (t) {
                    return t.scroller === Mt.scroller && (s = 1);
                  }),
                  s || wf || (Mt.scroll.rec = 0),
                  n &&
                    ((n.scrollTrigger = null),
                    t && n.revert({ kill: !1 }),
                    i || n.kill()),
                  h &&
                    [h, u, d, p].forEach(function (t) {
                      return t.parentNode && t.parentNode.removeChild(t);
                    }),
                  Rf === Mt && (Rf = 0),
                  $ &&
                    (r && (r.uncache = 1),
                    (s = 0),
                    Lm.forEach(function (t) {
                      return t.pin === $ && s++;
                    }),
                    s || (r.spacer = 0)),
                  e.onKill && e.onKill(Mt);
              }),
              Lm.push(Mt),
              Mt.enable(!1, !1),
              H && H(Mt),
              n && n.add && !g)
            ) {
              var It = Mt.update;
              (Mt.update = function () {
                (Mt.update = It), l || c || Mt.refresh();
              }),
                Wp.delayedCall(0.01, Mt.update),
                (g = 0.01),
                (l = c = 0);
            } else Mt.refresh();
            $ &&
              (function () {
                if (Af !== Xm) {
                  var t = (Af = Xm);
                  requestAnimationFrame(function () {
                    return t === Xm && Ym(!0);
                  });
                }
              })();
          } else this.update = this.refresh = this.kill = zf;
        }),
        (t.register = function (e) {
          return (
            Xp ||
              ((Wp = e || Gf()),
              Hf() && window.document && t.enable(),
              (Xp = If)),
            Xp
          );
        }),
        (t.defaults = function (t) {
          if (t) for (var e in t) wm[e] = t[e];
          return wm;
        }),
        (t.disable = function (t, e) {
          (If = 0),
            Lm.forEach(function (n) {
              return n[e ? "kill" : "disable"](t);
            }),
            Sm(jp, "wheel", Um),
            Sm(qp, "scroll", Um),
            clearInterval(ef),
            Sm(qp, "touchcancel", zf),
            Sm(Kp, "touchstart", zf),
            Tm(Sm, qp, "pointerdown,touchstart,mousedown", Ff),
            Tm(Sm, qp, "pointerup,touchend,mouseup", kf),
            Jp.kill(),
            qf(Sm);
          for (var n = 0; n < Mp.length; n += 3)
            bm(Sm, Mp[n], Mp[n + 1]), bm(Sm, Mp[n], Mp[n + 2]);
        }),
        (t.enable = function () {
          if (
            ((jp = window),
            (qp = document),
            (Yp = qp.documentElement),
            (Kp = qp.body),
            Wp &&
              ((Qp = Wp.utils.toArray),
              ($p = Wp.utils.clamp),
              (vf = Wp.core.context || zf),
              (uf = Wp.core.suppressOverwrites || zf),
              (yf = jp.history.scrollRestoration || "auto"),
              (Km = jp.pageYOffset),
              Wp.core.globals("ScrollTrigger", t),
              Kp))
          ) {
            (If = 1),
              ((xf = document.createElement("div")).style.height = "100vh"),
              (xf.style.position = "absolute"),
              jm(),
              Of(),
              Vp.register(Wp),
              (t.isTouch = Vp.isTouch),
              (_f =
                Vp.isTouch &&
                /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent)),
              Mm(jp, "wheel", Um),
              (Zp = [jp, qp, Yp, Kp]),
              Wp.matchMedia
                ? ((t.matchMedia = function (t) {
                    var e,
                      n = Wp.matchMedia();
                    for (e in t) n.add(e, t[e]);
                    return n;
                  }),
                  Wp.addEventListener("matchMediaInit", function () {
                    return Vm();
                  }),
                  Wp.addEventListener("matchMediaRevert", function () {
                    return Gm();
                  }),
                  Wp.addEventListener("matchMedia", function () {
                    Ym(0, 1), Bm("matchMedia");
                  }),
                  Wp.matchMedia("(orientation: portrait)", function () {
                    return Nm(), Nm;
                  }))
                : console.warn("Requires GSAP 3.11.0 or later"),
              Nm(),
              Mm(qp, "scroll", Um);
            var e,
              n,
              i = Kp.style,
              r = i.borderTopStyle,
              s = Wp.core.Animation.prototype;
            for (
              s.revert ||
                Object.defineProperty(s, "revert", {
                  value: function () {
                    return this.time(-0.01, !0);
                  },
                }),
                i.borderTopStyle = "solid",
                e = _m(Kp),
                Np.m = Math.round(e.top + Np.sc()) || 0,
                Up.m = Math.round(e.left + Up.sc()) || 0,
                r
                  ? (i.borderTopStyle = r)
                  : i.removeProperty("border-top-style"),
                ef = setInterval(Im, 250),
                Wp.delayedCall(0.5, function () {
                  return (Cf = 0);
                }),
                Mm(qp, "touchcancel", zf),
                Mm(Kp, "touchstart", zf),
                Tm(Mm, qp, "pointerdown,touchstart,mousedown", Ff),
                Tm(Mm, qp, "pointerup,touchend,mouseup", kf),
                sf = Wp.utils.checkPrefix("transform"),
                $m.push(sf),
                Xp = Pf(),
                Jp = Wp.delayedCall(0.2, Ym).pause(),
                cf = [
                  qp,
                  "visibilitychange",
                  function () {
                    var t = jp.innerWidth,
                      e = jp.innerHeight;
                    qp.hidden
                      ? ((of = t), (lf = e))
                      : (of === t && lf === e) || Om();
                  },
                  qp,
                  "DOMContentLoaded",
                  Ym,
                  jp,
                  "load",
                  Ym,
                  jp,
                  "resize",
                  Om,
                ],
                qf(Mm),
                Lm.forEach(function (t) {
                  return t.enable(0, 1);
                }),
                n = 0;
              n < Mp.length;
              n += 3
            )
              bm(Sm, Mp[n], Mp[n + 1]), bm(Sm, Mp[n], Mp[n + 2]);
          }
        }),
        (t.config = function (e) {
          "limitCallbacks" in e && (bf = !!e.limitCallbacks);
          var n = e.syncInterval;
          (n && clearInterval(ef)) || ((ef = n) && setInterval(Im, n)),
            "ignoreMobileResize" in e &&
              (ff = 1 === t.isTouch && e.ignoreMobileResize),
            "autoRefreshEvents" in e &&
              (qf(Sm) || qf(Mm, e.autoRefreshEvents || "none"),
              (df = -1 === (e.autoRefreshEvents + "").indexOf("resize")));
        }),
        (t.scrollerProxy = function (t, e) {
          var n = Op(t),
            i = Mp.indexOf(n),
            r = Vf(n);
          ~i && Mp.splice(i, r ? 6 : 2),
            e && (r ? Sp.unshift(jp, e, Kp, e, Yp, e) : Sp.unshift(n, e));
        }),
        (t.clearMatchMedia = function (t) {
          Lm.forEach(function (e) {
            return e._ctx && e._ctx.query === t && e._ctx.kill(!0, !0);
          });
        }),
        (t.isInViewport = function (t, e, n) {
          var i = (Yf(t) ? Op(t) : t).getBoundingClientRect(),
            r = i[n ? rm : sm] * e || 0;
          return n
            ? i.right - r > 0 && i.left + r < jp.innerWidth
            : i.bottom - r > 0 && i.top + r < jp.innerHeight;
        }),
        (t.positionInViewport = function (t, e, n) {
          Yf(t) && (t = Op(t));
          var i = t.getBoundingClientRect(),
            r = i[n ? rm : sm],
            s =
              null == e
                ? r / 2
                : e in Am
                ? Am[e] * r
                : ~e.indexOf("%")
                ? (parseFloat(e) * r) / 100
                : parseFloat(e) || 0;
          return n
            ? (i.left + s) / jp.innerWidth
            : (i.top + s) / jp.innerHeight;
        }),
        (t.killAll = function (t) {
          if (
            (Lm.slice(0).forEach(function (t) {
              return "ScrollSmoother" !== t.vars.id && t.kill();
            }),
            !0 !== t)
          ) {
            var e = Fm.killAll || [];
            (Fm = {}),
              e.forEach(function (t) {
                return t();
              });
          }
        }),
        t
      );
    })();
  (ug.version = "3.12.4"),
    (ug.saveStyles = function (t) {
      return t
        ? Qp(t).forEach(function (t) {
            if (t && t.style) {
              var e = Hm.indexOf(t);
              e >= 0 && Hm.splice(e, 5),
                Hm.push(
                  t,
                  t.style.cssText,
                  t.getBBox && t.getAttribute("transform"),
                  Wp.core.getCache(t),
                  vf()
                );
            }
          })
        : Hm;
    }),
    (ug.revert = function (t, e) {
      return Vm(!t, e);
    }),
    (ug.create = function (t, e) {
      return new ug(t, e);
    }),
    (ug.refresh = function (t) {
      return t ? Om() : (Xp || ug.register()) && Ym(!0);
    }),
    (ug.update = function (t) {
      return ++Mp.cache && Jm(!0 === t ? 2 : 0);
    }),
    (ug.clearScrollMemory = Wm),
    (ug.maxScroll = function (t, e) {
      return jf(t, e ? Up : Np);
    }),
    (ug.getScrollFunc = function (t, e) {
      return Fp(Op(t), e ? Up : Np);
    }),
    (ug.getById = function (t) {
      return Dm[t];
    }),
    (ug.getAll = function () {
      return Lm.filter(function (t) {
        return "ScrollSmoother" !== t.vars.id;
      });
    }),
    (ug.isScrolling = function () {
      return !!Df;
    }),
    (ug.snapDirectional = xm),
    (ug.addEventListener = function (t, e) {
      var n = Fm[t] || (Fm[t] = []);
      ~n.indexOf(e) || n.push(e);
    }),
    (ug.removeEventListener = function (t, e) {
      var n = Fm[t],
        i = n && n.indexOf(e);
      i >= 0 && n.splice(i, 1);
    }),
    (ug.batch = function (t, e) {
      var n,
        i = [],
        r = {},
        s = e.interval || 0.016,
        a = e.batchMax || 1e9,
        o = function (t, e) {
          var n = [],
            i = [],
            r = Wp.delayedCall(s, function () {
              e(n, i), (n = []), (i = []);
            }).pause();
          return function (t) {
            n.length || r.restart(!0),
              n.push(t.trigger),
              i.push(t),
              a <= n.length && r.progress(1);
          };
        };
      for (n in e)
        r[n] =
          "on" === n.substr(0, 2) && Kf(e[n]) && "onRefreshInit" !== n
            ? o(0, e[n])
            : e[n];
      return (
        Kf(a) &&
          ((a = a()),
          Mm(ug, "refresh", function () {
            return (a = e.batchMax());
          })),
        Qp(t).forEach(function (t) {
          var e = {};
          for (n in r) e[n] = r[n];
          (e.trigger = t), i.push(ug.create(e));
        }),
        i
      );
    });
  var dg,
    pg = function (t, e, n, i) {
      return (
        e > i ? t(i) : e < 0 && t(0),
        n > i ? (i - e) / (n - e) : n < 0 ? e / (e - n) : 1
      );
    },
    fg = function t(e, n) {
      !0 === n
        ? e.style.removeProperty("touch-action")
        : (e.style.touchAction =
            !0 === n
              ? "auto"
              : n
              ? "pan-" + n + (Vp.isTouch ? " pinch-zoom" : "")
              : "none"),
        e === Yp && t(Kp, n);
    },
    mg = { auto: 1, scroll: 1 },
    gg = function (t) {
      var e,
        n = t.event,
        i = t.target,
        r = t.axis,
        s = (n.changedTouches ? n.changedTouches[0] : n).target,
        a = s._gsap || Wp.core.getCache(s),
        o = Pf();
      if (!a._isScrollT || o - a._isScrollT > 2e3) {
        for (
          ;
          s &&
          s !== Kp &&
          ((s.scrollHeight <= s.clientHeight &&
            s.scrollWidth <= s.clientWidth) ||
            (!mg[(e = mm(s)).overflowY] && !mg[e.overflowX]));

        )
          s = s.parentNode;
        (a._isScroll =
          s &&
          s !== i &&
          !Vf(s) &&
          (mg[(e = mm(s)).overflowY] || mg[e.overflowX])),
          (a._isScrollT = o);
      }
      (a._isScroll || "x" === r) && (n.stopPropagation(), (n._gsapAllow = !0));
    },
    _g = function (t, e, n, i) {
      return Vp.create({
        target: t,
        capture: !0,
        debounce: !1,
        lockAxis: !0,
        type: e,
        onWheel: (i = i && gg),
        onPress: i,
        onDrag: i,
        onScroll: i,
        onEnable: function () {
          return n && Mm(qp, Vp.eventTypes[0], yg, !1, !0);
        },
        onDisable: function () {
          return Sm(qp, Vp.eventTypes[0], yg, !0);
        },
      });
    },
    vg = /(input|label|select|textarea)/i,
    yg = function (t) {
      var e = vg.test(t.target.tagName);
      (e || dg) && ((t._gsapAllow = !0), (dg = e));
    };
  (ug.sort = function (t) {
    return Lm.sort(
      t ||
        function (t, e) {
          return (
            -1e6 * (t.vars.refreshPriority || 0) +
            t.start -
            (e.start + -1e6 * (e.vars.refreshPriority || 0))
          );
        }
    );
  }),
    (ug.observe = function (t) {
      return new Vp(t);
    }),
    (ug.normalizeScroll = function (t) {
      if (void 0 === t) return pf;
      if (!0 === t && pf) return pf.enable();
      if (!1 === t) return pf && pf.kill(), void (pf = t);
      var e =
        t instanceof Vp
          ? t
          : (function (t) {
              Jf(t) || (t = {}),
                (t.preventDefault = t.isNormalizer = t.allowClicks = !0),
                t.type || (t.type = "wheel,touch"),
                (t.debounce = !!t.debounce),
                (t.id = t.id || "normalizer");
              var e,
                n,
                i,
                r,
                s,
                a,
                o,
                l,
                c = t,
                h = c.normalizeScrollX,
                u = c.momentum,
                d = c.allowNestedScroll,
                p = c.onRelease,
                f = Op(t.target) || Yp,
                m = Wp.core.globals().ScrollSmoother,
                g = m && m.get(),
                _ =
                  _f &&
                  ((t.content && Op(t.content)) ||
                    (g && !1 !== t.content && !g.smooth() && g.content())),
                v = Fp(f, Np),
                y = Fp(f, Up),
                x = 1,
                T =
                  (Vp.isTouch && jp.visualViewport
                    ? jp.visualViewport.scale * jp.visualViewport.width
                    : jp.outerWidth) / jp.innerWidth,
                M = 0,
                S = Kf(u)
                  ? function () {
                      return u(e);
                    }
                  : function () {
                      return u || 2.8;
                    },
                b = _g(f, t.type, !0, d),
                E = function () {
                  return (r = !1);
                },
                w = zf,
                A = zf,
                R = function () {
                  (n = jf(f, Np)),
                    (A = $p(_f ? 1 : 0, n)),
                    h && (w = $p(0, jf(f, Up))),
                    (i = Xm);
                },
                C = function () {
                  (_._gsap.y = Bf(parseFloat(_._gsap.y) + v.offset) + "px"),
                    (_.style.transform =
                      "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
                      parseFloat(_._gsap.y) +
                      ", 0, 1)"),
                    (v.offset = v.cacheID = 0);
                },
                P = function () {
                  R(),
                    s.isActive() &&
                      s.vars.scrollY > n &&
                      (v() > n
                        ? s.progress(1) && v(n)
                        : s.resetTo("scrollY", n));
                };
              return (
                _ && Wp.set(_, { y: "+=0" }),
                (t.ignoreCheck = function (t) {
                  return (
                    (_f &&
                      "touchmove" === t.type &&
                      (function () {
                        if (r) {
                          requestAnimationFrame(E);
                          var t = Bf(e.deltaY / 2),
                            n = A(v.v - t);
                          if (_ && n !== v.v + v.offset) {
                            v.offset = n - v.v;
                            var i = Bf(
                              (parseFloat(_ && _._gsap.y) || 0) - v.offset
                            );
                            (_.style.transform =
                              "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
                              i +
                              ", 0, 1)"),
                              (_._gsap.y = i + "px"),
                              (v.cacheID = Mp.cache),
                              Jm();
                          }
                          return !0;
                        }
                        v.offset && C(), (r = !0);
                      })()) ||
                    (x > 1.05 && "touchstart" !== t.type) ||
                    e.isGesturing ||
                    (t.touches && t.touches.length > 1)
                  );
                }),
                (t.onPress = function () {
                  r = !1;
                  var t = x;
                  (x = Bf(
                    ((jp.visualViewport && jp.visualViewport.scale) || 1) / T
                  )),
                    s.pause(),
                    t !== x && fg(f, x > 1.01 || (!h && "x")),
                    (a = y()),
                    (o = v()),
                    R(),
                    (i = Xm);
                }),
                (t.onRelease = t.onGestureStart =
                  function (t, e) {
                    if ((v.offset && C(), e)) {
                      Mp.cache++;
                      var i,
                        r,
                        a = S();
                      h &&
                        ((r = (i = y()) + (0.05 * a * -t.velocityX) / 0.227),
                        (a *= pg(y, i, r, jf(f, Up))),
                        (s.vars.scrollX = w(r))),
                        (r = (i = v()) + (0.05 * a * -t.velocityY) / 0.227),
                        (a *= pg(v, i, r, jf(f, Np))),
                        (s.vars.scrollY = A(r)),
                        s.invalidate().duration(a).play(0.01),
                        ((_f && s.vars.scrollY >= n) || i >= n - 1) &&
                          Wp.to({}, { onUpdate: P, duration: a });
                    } else l.restart(!0);
                    p && p(t);
                  }),
                (t.onWheel = function () {
                  s._ts && s.pause(), Pf() - M > 1e3 && ((i = 0), (M = Pf()));
                }),
                (t.onChange = function (t, e, n, r, s) {
                  if (
                    (Xm !== i && R(),
                    e &&
                      h &&
                      y(w(r[2] === e ? a + (t.startX - t.x) : y() + e - r[1])),
                    n)
                  ) {
                    v.offset && C();
                    var l = s[2] === n,
                      c = l ? o + t.startY - t.y : v() + n - s[1],
                      u = A(c);
                    l && c !== u && (o += u - c), v(u);
                  }
                  (n || e) && Jm();
                }),
                (t.onEnable = function () {
                  fg(f, !h && "x"),
                    ug.addEventListener("refresh", P),
                    Mm(jp, "resize", P),
                    v.smooth &&
                      ((v.target.style.scrollBehavior = "auto"),
                      (v.smooth = y.smooth = !1)),
                    b.enable();
                }),
                (t.onDisable = function () {
                  fg(f, !0),
                    Sm(jp, "resize", P),
                    ug.removeEventListener("refresh", P),
                    b.kill();
                }),
                (t.lockAxis = !1 !== t.lockAxis),
                ((e = new Vp(t)).iOS = _f),
                _f && !v() && v(1),
                _f && Wp.ticker.add(zf),
                (l = e._dc),
                (s = Wp.to(e, {
                  ease: "power4",
                  paused: !0,
                  scrollX: h ? "+=0.1" : "+=0",
                  scrollY: "+=0.1",
                  modifiers: {
                    scrollY: lg(v, v(), function () {
                      return s.pause();
                    }),
                  },
                  onUpdate: Jm,
                  onComplete: l.vars.onComplete,
                })),
                e
              );
            })(t);
      return (
        pf && pf.target === e.target && pf.kill(), Vf(e.target) && (pf = e), e
      );
    }),
    (ug.core = {
      _getVelocityProp: kp,
      _inputObserver: _g,
      _scrollers: Mp,
      _proxies: Sp,
      bridge: {
        ss: function () {
          Df || Bm("scrollStart"), (Df = Pf());
        },
        ref: function () {
          return nf;
        },
      },
    }),
    Gf() && Wp.registerPlugin(ug);
  const xg = {
    name: "CopyShader",
    uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } },
    vertexShader:
      "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader:
      "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}",
  };
  class Tg {
    constructor() {
      (this.isPass = !0),
        (this.enabled = !0),
        (this.needsSwap = !0),
        (this.clear = !1),
        (this.renderToScreen = !1);
    }
    setSize() {}
    render() {
      console.error(
        "THREE.Pass: .render() must be implemented in derived pass."
      );
    }
    dispose() {}
  }
  const Mg = new Ci(-1, 1, 1, -1, 0, 1),
    Sg = new (class extends Ln {
      constructor() {
        super(),
          this.setAttribute(
            "position",
            new Sn([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)
          ),
          this.setAttribute("uv", new Sn([0, 2, 0, 0, 2, 0], 2));
      }
    })();
  class bg {
    constructor(t) {
      this._mesh = new Kn(Sg, t);
    }
    dispose() {
      this._mesh.geometry.dispose();
    }
    render(t) {
      t.render(this._mesh, Mg);
    }
    get material() {
      return this._mesh.material;
    }
    set material(t) {
      this._mesh.material = t;
    }
  }
  class Eg extends Tg {
    constructor(t, e) {
      super(),
        (this.textureID = void 0 !== e ? e : "tDiffuse"),
        t instanceof ni
          ? ((this.uniforms = t.uniforms), (this.material = t))
          : t &&
            ((this.uniforms = ei.clone(t.uniforms)),
            (this.material = new ni({
              name: void 0 !== t.name ? t.name : "unspecified",
              defines: Object.assign({}, t.defines),
              uniforms: this.uniforms,
              vertexShader: t.vertexShader,
              fragmentShader: t.fragmentShader,
            }))),
        (this.fsQuad = new bg(this.material));
    }
    render(t, e, n) {
      this.uniforms[this.textureID] &&
        (this.uniforms[this.textureID].value = n.texture),
        (this.fsQuad.material = this.material),
        this.renderToScreen
          ? (t.setRenderTarget(null), this.fsQuad.render(t))
          : (t.setRenderTarget(e),
            this.clear &&
              t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
            this.fsQuad.render(t));
    }
    dispose() {
      this.material.dispose(), this.fsQuad.dispose();
    }
  }
  class wg extends Tg {
    constructor(t, e) {
      super(),
        (this.scene = t),
        (this.camera = e),
        (this.clear = !0),
        (this.needsSwap = !1),
        (this.inverse = !1);
    }
    render(t, e, n) {
      const i = t.getContext(),
        r = t.state;
      let s, a;
      r.buffers.color.setMask(!1),
        r.buffers.depth.setMask(!1),
        r.buffers.color.setLocked(!0),
        r.buffers.depth.setLocked(!0),
        this.inverse ? ((s = 0), (a = 1)) : ((s = 1), (a = 0)),
        r.buffers.stencil.setTest(!0),
        r.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE),
        r.buffers.stencil.setFunc(i.ALWAYS, s, 4294967295),
        r.buffers.stencil.setClear(a),
        r.buffers.stencil.setLocked(!0),
        t.setRenderTarget(n),
        this.clear && t.clear(),
        t.render(this.scene, this.camera),
        t.setRenderTarget(e),
        this.clear && t.clear(),
        t.render(this.scene, this.camera),
        r.buffers.color.setLocked(!1),
        r.buffers.depth.setLocked(!1),
        r.buffers.color.setMask(!0),
        r.buffers.depth.setMask(!0),
        r.buffers.stencil.setLocked(!1),
        r.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295),
        r.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP),
        r.buffers.stencil.setLocked(!0);
    }
  }
  class Ag extends Tg {
    constructor() {
      super(), (this.needsSwap = !1);
    }
    render(t) {
      t.state.buffers.stencil.setLocked(!1),
        t.state.buffers.stencil.setTest(!1);
    }
  }
  class Rg {
    constructor(t, e) {
      if (
        ((this.renderer = t),
        (this._pixelRatio = t.getPixelRatio()),
        void 0 === e)
      ) {
        const n = t.getSize(new xt());
        (this._width = n.width),
          (this._height = n.height),
          ((e = new Wt(
            this._width * this._pixelRatio,
            this._height * this._pixelRatio,
            { type: D }
          )).texture.name = "EffectComposer.rt1");
      } else (this._width = e.width), (this._height = e.height);
      (this.renderTarget1 = e),
        (this.renderTarget2 = e.clone()),
        (this.renderTarget2.texture.name = "EffectComposer.rt2"),
        (this.writeBuffer = this.renderTarget1),
        (this.readBuffer = this.renderTarget2),
        (this.renderToScreen = !0),
        (this.passes = []),
        (this.copyPass = new Eg(xg)),
        (this.copyPass.material.blending = 0),
        (this.clock = new ko());
    }
    swapBuffers() {
      const t = this.readBuffer;
      (this.readBuffer = this.writeBuffer), (this.writeBuffer = t);
    }
    addPass(t) {
      this.passes.push(t),
        t.setSize(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio
        );
    }
    insertPass(t, e) {
      this.passes.splice(e, 0, t),
        t.setSize(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio
        );
    }
    removePass(t) {
      const e = this.passes.indexOf(t);
      -1 !== e && this.passes.splice(e, 1);
    }
    isLastEnabledPass(t) {
      for (let e = t + 1; e < this.passes.length; e++)
        if (this.passes[e].enabled) return !1;
      return !0;
    }
    render(t) {
      void 0 === t && (t = this.clock.getDelta());
      const e = this.renderer.getRenderTarget();
      let n = !1;
      for (let e = 0, i = this.passes.length; e < i; e++) {
        const i = this.passes[e];
        if (!1 !== i.enabled) {
          if (
            ((i.renderToScreen =
              this.renderToScreen && this.isLastEnabledPass(e)),
            i.render(this.renderer, this.writeBuffer, this.readBuffer, t, n),
            i.needsSwap)
          ) {
            if (n) {
              const e = this.renderer.getContext(),
                n = this.renderer.state.buffers.stencil;
              n.setFunc(e.NOTEQUAL, 1, 4294967295),
                this.copyPass.render(
                  this.renderer,
                  this.writeBuffer,
                  this.readBuffer,
                  t
                ),
                n.setFunc(e.EQUAL, 1, 4294967295);
            }
            this.swapBuffers();
          }
          void 0 !== wg &&
            (i instanceof wg ? (n = !0) : i instanceof Ag && (n = !1));
        }
      }
      this.renderer.setRenderTarget(e);
    }
    reset(t) {
      if (void 0 === t) {
        const e = this.renderer.getSize(new xt());
        (this._pixelRatio = this.renderer.getPixelRatio()),
          (this._width = e.width),
          (this._height = e.height),
          (t = this.renderTarget1.clone()).setSize(
            this._width * this._pixelRatio,
            this._height * this._pixelRatio
          );
      }
      this.renderTarget1.dispose(),
        this.renderTarget2.dispose(),
        (this.renderTarget1 = t),
        (this.renderTarget2 = t.clone()),
        (this.writeBuffer = this.renderTarget1),
        (this.readBuffer = this.renderTarget2);
    }
    setSize(t, e) {
      (this._width = t), (this._height = e);
      const n = this._width * this._pixelRatio,
        i = this._height * this._pixelRatio;
      this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i);
      for (let t = 0; t < this.passes.length; t++) this.passes[t].setSize(n, i);
    }
    setPixelRatio(t) {
      (this._pixelRatio = t), this.setSize(this._width, this._height);
    }
    dispose() {
      this.renderTarget1.dispose(),
        this.renderTarget2.dispose(),
        this.copyPass.dispose();
    }
  }
  class Cg extends Tg {
    constructor(t, e, n = null, i = null, r = null) {
      super(),
        (this.scene = t),
        (this.camera = e),
        (this.overrideMaterial = n),
        (this.clearColor = i),
        (this.clearAlpha = r),
        (this.clear = !0),
        (this.clearDepth = !1),
        (this.needsSwap = !1),
        (this._oldClearColor = new pn());
    }
    render(t, e, n) {
      const i = t.autoClear;
      let r, s;
      (t.autoClear = !1),
        null !== this.overrideMaterial &&
          ((s = this.scene.overrideMaterial),
          (this.scene.overrideMaterial = this.overrideMaterial)),
        null !== this.clearColor &&
          (t.getClearColor(this._oldClearColor),
          t.setClearColor(this.clearColor)),
        null !== this.clearAlpha &&
          ((r = t.getClearAlpha()), t.setClearAlpha(this.clearAlpha)),
        1 == this.clearDepth && t.clearDepth(),
        t.setRenderTarget(this.renderToScreen ? null : n),
        !0 === this.clear &&
          t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
        t.render(this.scene, this.camera),
        null !== this.clearColor && t.setClearColor(this._oldClearColor),
        null !== this.clearAlpha && t.setClearAlpha(r),
        null !== this.overrideMaterial && (this.scene.overrideMaterial = s),
        (t.autoClear = i);
    }
  }
  const Pg = {
    name: "LuminosityHighPassShader",
    shaderID: "luminosityHighPass",
    uniforms: {
      tDiffuse: { value: null },
      luminosityThreshold: { value: 1 },
      smoothWidth: { value: 1 },
      defaultColor: { value: new pn(0) },
      defaultOpacity: { value: 0 },
    },
    vertexShader:
      "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader:
      "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n\t\t\tfloat v = dot( texel.xyz, luma );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}",
  };
  class Lg extends Tg {
    constructor(t, e, n, i) {
      super(),
        (this.strength = void 0 !== e ? e : 1),
        (this.radius = n),
        (this.threshold = i),
        (this.resolution = void 0 !== t ? new xt(t.x, t.y) : new xt(256, 256)),
        (this.clearColor = new pn(0, 0, 0)),
        (this.renderTargetsHorizontal = []),
        (this.renderTargetsVertical = []),
        (this.nMips = 5);
      let r = Math.round(this.resolution.x / 2),
        s = Math.round(this.resolution.y / 2);
      (this.renderTargetBright = new Wt(r, s, { type: D })),
        (this.renderTargetBright.texture.name = "UnrealBloomPass.bright"),
        (this.renderTargetBright.texture.generateMipmaps = !1);
      for (let t = 0; t < this.nMips; t++) {
        const e = new Wt(r, s, { type: D });
        (e.texture.name = "UnrealBloomPass.h" + t),
          (e.texture.generateMipmaps = !1),
          this.renderTargetsHorizontal.push(e);
        const n = new Wt(r, s, { type: D });
        (n.texture.name = "UnrealBloomPass.v" + t),
          (n.texture.generateMipmaps = !1),
          this.renderTargetsVertical.push(n),
          (r = Math.round(r / 2)),
          (s = Math.round(s / 2));
      }
      const a = Pg;
      (this.highPassUniforms = ei.clone(a.uniforms)),
        (this.highPassUniforms.luminosityThreshold.value = i),
        (this.highPassUniforms.smoothWidth.value = 0.01),
        (this.materialHighPassFilter = new ni({
          uniforms: this.highPassUniforms,
          vertexShader: a.vertexShader,
          fragmentShader: a.fragmentShader,
        })),
        (this.separableBlurMaterials = []);
      const o = [3, 5, 7, 9, 11];
      (r = Math.round(this.resolution.x / 2)),
        (s = Math.round(this.resolution.y / 2));
      for (let t = 0; t < this.nMips; t++)
        this.separableBlurMaterials.push(this.getSeperableBlurMaterial(o[t])),
          (this.separableBlurMaterials[t].uniforms.invSize.value = new xt(
            1 / r,
            1 / s
          )),
          (r = Math.round(r / 2)),
          (s = Math.round(s / 2));
      (this.compositeMaterial = this.getCompositeMaterial(this.nMips)),
        (this.compositeMaterial.uniforms.blurTexture1.value =
          this.renderTargetsVertical[0].texture),
        (this.compositeMaterial.uniforms.blurTexture2.value =
          this.renderTargetsVertical[1].texture),
        (this.compositeMaterial.uniforms.blurTexture3.value =
          this.renderTargetsVertical[2].texture),
        (this.compositeMaterial.uniforms.blurTexture4.value =
          this.renderTargetsVertical[3].texture),
        (this.compositeMaterial.uniforms.blurTexture5.value =
          this.renderTargetsVertical[4].texture),
        (this.compositeMaterial.uniforms.bloomStrength.value = e),
        (this.compositeMaterial.uniforms.bloomRadius.value = 0.1),
        (this.compositeMaterial.uniforms.bloomFactors.value = [
          1, 0.8, 0.6, 0.4, 0.2,
        ]),
        (this.bloomTintColors = [
          new Yt(1, 1, 1),
          new Yt(1, 1, 1),
          new Yt(1, 1, 1),
          new Yt(1, 1, 1),
          new Yt(1, 1, 1),
        ]),
        (this.compositeMaterial.uniforms.bloomTintColors.value =
          this.bloomTintColors);
      const l = xg;
      (this.copyUniforms = ei.clone(l.uniforms)),
        (this.blendMaterial = new ni({
          uniforms: this.copyUniforms,
          vertexShader: l.vertexShader,
          fragmentShader: l.fragmentShader,
          blending: 2,
          depthTest: !1,
          depthWrite: !1,
          transparent: !0,
        })),
        (this.enabled = !0),
        (this.needsSwap = !1),
        (this._oldClearColor = new pn()),
        (this.oldClearAlpha = 1),
        (this.basic = new _n()),
        (this.fsQuad = new bg(null));
    }
    dispose() {
      for (let t = 0; t < this.renderTargetsHorizontal.length; t++)
        this.renderTargetsHorizontal[t].dispose();
      for (let t = 0; t < this.renderTargetsVertical.length; t++)
        this.renderTargetsVertical[t].dispose();
      this.renderTargetBright.dispose();
      for (let t = 0; t < this.separableBlurMaterials.length; t++)
        this.separableBlurMaterials[t].dispose();
      this.compositeMaterial.dispose(),
        this.blendMaterial.dispose(),
        this.basic.dispose(),
        this.fsQuad.dispose();
    }
    setSize(t, e) {
      let n = Math.round(t / 2),
        i = Math.round(e / 2);
      this.renderTargetBright.setSize(n, i);
      for (let t = 0; t < this.nMips; t++)
        this.renderTargetsHorizontal[t].setSize(n, i),
          this.renderTargetsVertical[t].setSize(n, i),
          (this.separableBlurMaterials[t].uniforms.invSize.value = new xt(
            1 / n,
            1 / i
          )),
          (n = Math.round(n / 2)),
          (i = Math.round(i / 2));
    }
    render(t, e, n, i, r) {
      t.getClearColor(this._oldClearColor),
        (this.oldClearAlpha = t.getClearAlpha());
      const s = t.autoClear;
      (t.autoClear = !1),
        t.setClearColor(this.clearColor, 0),
        r && t.state.buffers.stencil.setTest(!1),
        this.renderToScreen &&
          ((this.fsQuad.material = this.basic),
          (this.basic.map = n.texture),
          t.setRenderTarget(null),
          t.clear(),
          this.fsQuad.render(t)),
        (this.highPassUniforms.tDiffuse.value = n.texture),
        (this.highPassUniforms.luminosityThreshold.value = this.threshold),
        (this.fsQuad.material = this.materialHighPassFilter),
        t.setRenderTarget(this.renderTargetBright),
        t.clear(),
        this.fsQuad.render(t);
      let a = this.renderTargetBright;
      for (let e = 0; e < this.nMips; e++)
        (this.fsQuad.material = this.separableBlurMaterials[e]),
          (this.separableBlurMaterials[e].uniforms.colorTexture.value =
            a.texture),
          (this.separableBlurMaterials[e].uniforms.direction.value =
            Lg.BlurDirectionX),
          t.setRenderTarget(this.renderTargetsHorizontal[e]),
          t.clear(),
          this.fsQuad.render(t),
          (this.separableBlurMaterials[e].uniforms.colorTexture.value =
            this.renderTargetsHorizontal[e].texture),
          (this.separableBlurMaterials[e].uniforms.direction.value =
            Lg.BlurDirectionY),
          t.setRenderTarget(this.renderTargetsVertical[e]),
          t.clear(),
          this.fsQuad.render(t),
          (a = this.renderTargetsVertical[e]);
      (this.fsQuad.material = this.compositeMaterial),
        (this.compositeMaterial.uniforms.bloomStrength.value = this.strength),
        (this.compositeMaterial.uniforms.bloomRadius.value = this.radius),
        (this.compositeMaterial.uniforms.bloomTintColors.value =
          this.bloomTintColors),
        t.setRenderTarget(this.renderTargetsHorizontal[0]),
        t.clear(),
        this.fsQuad.render(t),
        (this.fsQuad.material = this.blendMaterial),
        (this.copyUniforms.tDiffuse.value =
          this.renderTargetsHorizontal[0].texture),
        r && t.state.buffers.stencil.setTest(!0),
        this.renderToScreen
          ? (t.setRenderTarget(null), this.fsQuad.render(t))
          : (t.setRenderTarget(n), this.fsQuad.render(t)),
        t.setClearColor(this._oldClearColor, this.oldClearAlpha),
        (t.autoClear = s);
    }
    getSeperableBlurMaterial(t) {
      const e = [];
      for (let n = 0; n < t; n++)
        e.push((0.39894 * Math.exp((-0.5 * n * n) / (t * t))) / t);
      return new ni({
        defines: { KERNEL_RADIUS: t },
        uniforms: {
          colorTexture: { value: null },
          invSize: { value: new xt(0.5, 0.5) },
          direction: { value: new xt(0.5, 0.5) },
          gaussianCoefficients: { value: e },
        },
        vertexShader:
          "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
        fragmentShader:
          "#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 invSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float gaussianCoefficients[KERNEL_RADIUS];\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat weightSum = gaussianCoefficients[0];\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianCoefficients[i];\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}",
      });
    }
    getCompositeMaterial(t) {
      return new ni({
        defines: { NUM_MIPS: t },
        uniforms: {
          blurTexture1: { value: null },
          blurTexture2: { value: null },
          blurTexture3: { value: null },
          blurTexture4: { value: null },
          blurTexture5: { value: null },
          bloomStrength: { value: 1 },
          bloomFactors: { value: null },
          bloomTintColors: { value: null },
          bloomRadius: { value: 0 },
        },
        vertexShader:
          "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
        fragmentShader:
          "varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}",
      });
    }
  }
  function Dg(t, e) {
    if (0 === e)
      return (
        console.warn(
          "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
        ),
        t
      );
    if (2 === e || 1 === e) {
      let n = t.getIndex();
      if (null === n) {
        const e = [],
          i = t.getAttribute("position");
        if (void 0 === i)
          return (
            console.error(
              "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
            ),
            t
          );
        for (let t = 0; t < i.count; t++) e.push(t);
        t.setIndex(e), (n = t.getIndex());
      }
      const i = n.count - 2,
        r = [];
      if (2 === e)
        for (let t = 1; t <= i; t++)
          r.push(n.getX(0)), r.push(n.getX(t)), r.push(n.getX(t + 1));
      else
        for (let t = 0; t < i; t++)
          t % 2 == 0
            ? (r.push(n.getX(t)), r.push(n.getX(t + 1)), r.push(n.getX(t + 2)))
            : (r.push(n.getX(t + 2)), r.push(n.getX(t + 1)), r.push(n.getX(t)));
      r.length / 3 !== i &&
        console.error(
          "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
        );
      const s = t.clone();
      return s.setIndex(r), s.clearGroups(), s;
    }
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        e
      ),
      t
    );
  }
  (Lg.BlurDirectionX = new xt(1, 0)), (Lg.BlurDirectionY = new xt(0, 1));
  class Ig extends mo {
    constructor(t) {
      super(t),
        (this.dracoLoader = null),
        (this.ktx2Loader = null),
        (this.meshoptDecoder = null),
        (this.pluginCallbacks = []),
        this.register(function (t) {
          return new zg(t);
        }),
        this.register(function (t) {
          return new Yg(t);
        }),
        this.register(function (t) {
          return new Kg(t);
        }),
        this.register(function (t) {
          return new Zg(t);
        }),
        this.register(function (t) {
          return new Hg(t);
        }),
        this.register(function (t) {
          return new Gg(t);
        }),
        this.register(function (t) {
          return new Vg(t);
        }),
        this.register(function (t) {
          return new Wg(t);
        }),
        this.register(function (t) {
          return new kg(t);
        }),
        this.register(function (t) {
          return new Xg(t);
        }),
        this.register(function (t) {
          return new Bg(t);
        }),
        this.register(function (t) {
          return new qg(t);
        }),
        this.register(function (t) {
          return new jg(t);
        }),
        this.register(function (t) {
          return new Og(t);
        }),
        this.register(function (t) {
          return new Jg(t);
        }),
        this.register(function (t) {
          return new Qg(t);
        });
    }
    load(t, e, n, i) {
      const r = this;
      let s;
      if ("" !== this.resourcePath) s = this.resourcePath;
      else if ("" !== this.path) {
        const e = Oo.extractUrlBase(t);
        s = Oo.resolveURL(e, this.path);
      } else s = Oo.extractUrlBase(t);
      this.manager.itemStart(t);
      const a = function (e) {
          i ? i(e) : console.error(e),
            r.manager.itemError(t),
            r.manager.itemEnd(t);
        },
        o = new vo(this.manager);
      o.setPath(this.path),
        o.setResponseType("arraybuffer"),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(
          t,
          function (n) {
            try {
              r.parse(
                n,
                s,
                function (n) {
                  e(n), r.manager.itemEnd(t);
                },
                a
              );
            } catch (t) {
              a(t);
            }
          },
          n,
          a
        );
    }
    setDRACOLoader(t) {
      return (this.dracoLoader = t), this;
    }
    setDDSLoader() {
      throw new Error(
        'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
      );
    }
    setKTX2Loader(t) {
      return (this.ktx2Loader = t), this;
    }
    setMeshoptDecoder(t) {
      return (this.meshoptDecoder = t), this;
    }
    register(t) {
      return (
        -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t),
        this
      );
    }
    unregister(t) {
      return (
        -1 !== this.pluginCallbacks.indexOf(t) &&
          this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
        this
      );
    }
    parse(t, e, n, i) {
      let r;
      const s = {},
        a = {},
        o = new TextDecoder();
      if ("string" == typeof t) r = JSON.parse(t);
      else if (t instanceof ArrayBuffer)
        if (o.decode(new Uint8Array(t, 0, 4)) === $g) {
          try {
            s[Ng.KHR_BINARY_GLTF] = new t_(t);
          } catch (t) {
            return void (i && i(t));
          }
          r = JSON.parse(s[Ng.KHR_BINARY_GLTF].content);
        } else r = JSON.parse(o.decode(t));
      else r = t;
      if (void 0 === r.asset || r.asset.version[0] < 2)
        return void (
          i &&
          i(
            new Error(
              "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
            )
          )
        );
      const l = new M_(r, {
        path: e || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        requestHeader: this.requestHeader,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder,
      });
      l.fileLoader.setRequestHeader(this.requestHeader);
      for (let t = 0; t < this.pluginCallbacks.length; t++) {
        const e = this.pluginCallbacks[t](l);
        e.name ||
          console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
          (a[e.name] = e),
          (s[e.name] = !0);
      }
      if (r.extensionsUsed)
        for (let t = 0; t < r.extensionsUsed.length; ++t) {
          const e = r.extensionsUsed[t],
            n = r.extensionsRequired || [];
          switch (e) {
            case Ng.KHR_MATERIALS_UNLIT:
              s[e] = new Fg();
              break;
            case Ng.KHR_DRACO_MESH_COMPRESSION:
              s[e] = new e_(r, this.dracoLoader);
              break;
            case Ng.KHR_TEXTURE_TRANSFORM:
              s[e] = new n_();
              break;
            case Ng.KHR_MESH_QUANTIZATION:
              s[e] = new i_();
              break;
            default:
              n.indexOf(e) >= 0 &&
                void 0 === a[e] &&
                console.warn(
                  'THREE.GLTFLoader: Unknown extension "' + e + '".'
                );
          }
        }
      l.setExtensions(s), l.setPlugins(a), l.parse(n, i);
    }
    parseAsync(t, e) {
      const n = this;
      return new Promise(function (i, r) {
        n.parse(t, e, i, r);
      });
    }
  }
  function Ug() {
    let t = {};
    return {
      get: function (e) {
        return t[e];
      },
      add: function (e, n) {
        t[e] = n;
      },
      remove: function (e) {
        delete t[e];
      },
      removeAll: function () {
        t = {};
      },
    };
  }
  const Ng = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_MATERIALS_BUMP: "EXT_materials_bump",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
  };
  class Og {
    constructor(t) {
      (this.parser = t),
        (this.name = Ng.KHR_LIGHTS_PUNCTUAL),
        (this.cache = { refs: {}, uses: {} });
    }
    _markDefs() {
      const t = this.parser,
        e = this.parser.json.nodes || [];
      for (let n = 0, i = e.length; n < i; n++) {
        const i = e[n];
        i.extensions &&
          i.extensions[this.name] &&
          void 0 !== i.extensions[this.name].light &&
          t._addNodeRef(this.cache, i.extensions[this.name].light);
      }
    }
    _loadLight(t) {
      const e = this.parser,
        n = "light:" + t;
      let i = e.cache.get(n);
      if (i) return i;
      const r = e.json,
        s = (((r.extensions && r.extensions[this.name]) || {}).lights || [])[t];
      let a;
      const o = new pn(16777215);
      void 0 !== s.color && o.setRGB(s.color[0], s.color[1], s.color[2], Y);
      const l = void 0 !== s.range ? s.range : 0;
      switch (s.type) {
        case "directional":
          (a = new Uo(o)), a.target.position.set(0, 0, -1), a.add(a.target);
          break;
        case "point":
          (a = new Do(o)), (a.distance = l);
          break;
        case "spot":
          (a = new Ao(o)),
            (a.distance = l),
            (s.spot = s.spot || {}),
            (s.spot.innerConeAngle =
              void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0),
            (s.spot.outerConeAngle =
              void 0 !== s.spot.outerConeAngle
                ? s.spot.outerConeAngle
                : Math.PI / 4),
            (a.angle = s.spot.outerConeAngle),
            (a.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle),
            a.target.position.set(0, 0, -1),
            a.add(a.target);
          break;
        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type);
      }
      return (
        a.position.set(0, 0, 0),
        (a.decay = 2),
        g_(a, s),
        void 0 !== s.intensity && (a.intensity = s.intensity),
        (a.name = e.createUniqueName(s.name || "light_" + t)),
        (i = Promise.resolve(a)),
        e.cache.add(n, i),
        i
      );
    }
    getDependency(t, e) {
      if ("light" === t) return this._loadLight(e);
    }
    createNodeAttachment(t) {
      const e = this,
        n = this.parser,
        i = n.json.nodes[t],
        r = ((i.extensions && i.extensions[this.name]) || {}).light;
      return void 0 === r
        ? null
        : this._loadLight(r).then(function (t) {
            return n._getNodeRef(e.cache, r, t);
          });
    }
  }
  class Fg {
    constructor() {
      this.name = Ng.KHR_MATERIALS_UNLIT;
    }
    getMaterialType() {
      return _n;
    }
    extendParams(t, e, n) {
      const i = [];
      (t.color = new pn(1, 1, 1)), (t.opacity = 1);
      const r = e.pbrMetallicRoughness;
      if (r) {
        if (Array.isArray(r.baseColorFactor)) {
          const e = r.baseColorFactor;
          t.color.setRGB(e[0], e[1], e[2], Y), (t.opacity = e[3]);
        }
        void 0 !== r.baseColorTexture &&
          i.push(n.assignTexture(t, "map", r.baseColorTexture, q));
      }
      return Promise.all(i);
    }
  }
  class kg {
    constructor(t) {
      (this.parser = t), (this.name = Ng.KHR_MATERIALS_EMISSIVE_STRENGTH);
    }
    extendMaterialParams(t, e) {
      const n = this.parser.json.materials[t];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const i = n.extensions[this.name].emissiveStrength;
      return void 0 !== i && (e.emissiveIntensity = i), Promise.resolve();
    }
  }
  class zg {
    constructor(t) {
      (this.parser = t), (this.name = Ng.KHR_MATERIALS_CLEARCOAT);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? ja : null;
    }
    extendMaterialParams(t, e) {
      const n = this.parser,
        i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [],
        s = i.extensions[this.name];
      if (
        (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor),
        void 0 !== s.clearcoatTexture &&
          r.push(n.assignTexture(e, "clearcoatMap", s.clearcoatTexture)),
        void 0 !== s.clearcoatRoughnessFactor &&
          (e.clearcoatRoughness = s.clearcoatRoughnessFactor),
        void 0 !== s.clearcoatRoughnessTexture &&
          r.push(
            n.assignTexture(
              e,
              "clearcoatRoughnessMap",
              s.clearcoatRoughnessTexture
            )
          ),
        void 0 !== s.clearcoatNormalTexture &&
          (r.push(
            n.assignTexture(e, "clearcoatNormalMap", s.clearcoatNormalTexture)
          ),
          void 0 !== s.clearcoatNormalTexture.scale))
      ) {
        const t = s.clearcoatNormalTexture.scale;
        e.clearcoatNormalScale = new xt(t, t);
      }
      return Promise.all(r);
    }
  }
  class Bg {
    constructor(t) {
      (this.parser = t), (this.name = Ng.KHR_MATERIALS_IRIDESCENCE);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? ja : null;
    }
    extendMaterialParams(t, e) {
      const n = this.parser,
        i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [],
        s = i.extensions[this.name];
      return (
        void 0 !== s.iridescenceFactor && (e.iridescence = s.iridescenceFactor),
        void 0 !== s.iridescenceTexture &&
          r.push(n.assignTexture(e, "iridescenceMap", s.iridescenceTexture)),
        void 0 !== s.iridescenceIor && (e.iridescenceIOR = s.iridescenceIor),
        void 0 === e.iridescenceThicknessRange &&
          (e.iridescenceThicknessRange = [100, 400]),
        void 0 !== s.iridescenceThicknessMinimum &&
          (e.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum),
        void 0 !== s.iridescenceThicknessMaximum &&
          (e.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum),
        void 0 !== s.iridescenceThicknessTexture &&
          r.push(
            n.assignTexture(
              e,
              "iridescenceThicknessMap",
              s.iridescenceThicknessTexture
            )
          ),
        Promise.all(r)
      );
    }
  }
  class Hg {
    constructor(t) {
      (this.parser = t), (this.name = Ng.KHR_MATERIALS_SHEEN);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? ja : null;
    }
    extendMaterialParams(t, e) {
      const n = this.parser,
        i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [];
      (e.sheenColor = new pn(0, 0, 0)), (e.sheenRoughness = 0), (e.sheen = 1);
      const s = i.extensions[this.name];
      if (void 0 !== s.sheenColorFactor) {
        const t = s.sheenColorFactor;
        e.sheenColor.setRGB(t[0], t[1], t[2], Y);
      }
      return (
        void 0 !== s.sheenRoughnessFactor &&
          (e.sheenRoughness = s.sheenRoughnessFactor),
        void 0 !== s.sheenColorTexture &&
          r.push(n.assignTexture(e, "sheenColorMap", s.sheenColorTexture, q)),
        void 0 !== s.sheenRoughnessTexture &&
          r.push(
            n.assignTexture(e, "sheenRoughnessMap", s.sheenRoughnessTexture)
          ),
        Promise.all(r)
      );
    }
  }
  class Gg {
    constructor(t) {
      (this.parser = t), (this.name = Ng.KHR_MATERIALS_TRANSMISSION);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? ja : null;
    }
    extendMaterialParams(t, e) {
      const n = this.parser,
        i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [],
        s = i.extensions[this.name];
      return (
        void 0 !== s.transmissionFactor &&
          (e.transmission = s.transmissionFactor),
        void 0 !== s.transmissionTexture &&
          r.push(n.assignTexture(e, "transmissionMap", s.transmissionTexture)),
        Promise.all(r)
      );
    }
  }
  class Vg {
    constructor(t) {
      (this.parser = t), (this.name = Ng.KHR_MATERIALS_VOLUME);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? ja : null;
    }
    extendMaterialParams(t, e) {
      const n = this.parser,
        i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [],
        s = i.extensions[this.name];
      (e.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0),
        void 0 !== s.thicknessTexture &&
          r.push(n.assignTexture(e, "thicknessMap", s.thicknessTexture)),
        (e.attenuationDistance = s.attenuationDistance || 1 / 0);
      const a = s.attenuationColor || [1, 1, 1];
      return (
        (e.attenuationColor = new pn().setRGB(a[0], a[1], a[2], Y)),
        Promise.all(r)
      );
    }
  }
  class Wg {
    constructor(t) {
      (this.parser = t), (this.name = Ng.KHR_MATERIALS_IOR);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? ja : null;
    }
    extendMaterialParams(t, e) {
      const n = this.parser.json.materials[t];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const i = n.extensions[this.name];
      return (e.ior = void 0 !== i.ior ? i.ior : 1.5), Promise.resolve();
    }
  }
  class Xg {
    constructor(t) {
      (this.parser = t), (this.name = Ng.KHR_MATERIALS_SPECULAR);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? ja : null;
    }
    extendMaterialParams(t, e) {
      const n = this.parser,
        i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [],
        s = i.extensions[this.name];
      (e.specularIntensity =
        void 0 !== s.specularFactor ? s.specularFactor : 1),
        void 0 !== s.specularTexture &&
          r.push(n.assignTexture(e, "specularIntensityMap", s.specularTexture));
      const a = s.specularColorFactor || [1, 1, 1];
      return (
        (e.specularColor = new pn().setRGB(a[0], a[1], a[2], Y)),
        void 0 !== s.specularColorTexture &&
          r.push(
            n.assignTexture(e, "specularColorMap", s.specularColorTexture, q)
          ),
        Promise.all(r)
      );
    }
  }
  class jg {
    constructor(t) {
      (this.parser = t), (this.name = Ng.EXT_MATERIALS_BUMP);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? ja : null;
    }
    extendMaterialParams(t, e) {
      const n = this.parser,
        i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [],
        s = i.extensions[this.name];
      return (
        (e.bumpScale = void 0 !== s.bumpFactor ? s.bumpFactor : 1),
        void 0 !== s.bumpTexture &&
          r.push(n.assignTexture(e, "bumpMap", s.bumpTexture)),
        Promise.all(r)
      );
    }
  }
  class qg {
    constructor(t) {
      (this.parser = t), (this.name = Ng.KHR_MATERIALS_ANISOTROPY);
    }
    getMaterialType(t) {
      const e = this.parser.json.materials[t];
      return e.extensions && e.extensions[this.name] ? ja : null;
    }
    extendMaterialParams(t, e) {
      const n = this.parser,
        i = n.json.materials[t];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [],
        s = i.extensions[this.name];
      return (
        void 0 !== s.anisotropyStrength &&
          (e.anisotropy = s.anisotropyStrength),
        void 0 !== s.anisotropyRotation &&
          (e.anisotropyRotation = s.anisotropyRotation),
        void 0 !== s.anisotropyTexture &&
          r.push(n.assignTexture(e, "anisotropyMap", s.anisotropyTexture)),
        Promise.all(r)
      );
    }
  }
  class Yg {
    constructor(t) {
      (this.parser = t), (this.name = Ng.KHR_TEXTURE_BASISU);
    }
    loadTexture(t) {
      const e = this.parser,
        n = e.json,
        i = n.textures[t];
      if (!i.extensions || !i.extensions[this.name]) return null;
      const r = i.extensions[this.name],
        s = e.options.ktx2Loader;
      if (!s) {
        if (
          n.extensionsRequired &&
          n.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
          );
        return null;
      }
      return e.loadTextureImage(t, r.source, s);
    }
  }
  class Kg {
    constructor(t) {
      (this.parser = t),
        (this.name = Ng.EXT_TEXTURE_WEBP),
        (this.isSupported = null);
    }
    loadTexture(t) {
      const e = this.name,
        n = this.parser,
        i = n.json,
        r = i.textures[t];
      if (!r.extensions || !r.extensions[e]) return null;
      const s = r.extensions[e],
        a = i.images[s.source];
      let o = n.textureLoader;
      if (a.uri) {
        const t = n.options.manager.getHandler(a.uri);
        null !== t && (o = t);
      }
      return this.detectSupport().then(function (r) {
        if (r) return n.loadTextureImage(t, s.source, o);
        if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
          throw new Error(
            "THREE.GLTFLoader: WebP required by asset but unsupported."
          );
        return n.loadTexture(t);
      });
    }
    detectSupport() {
      return (
        this.isSupported ||
          (this.isSupported = new Promise(function (t) {
            const e = new Image();
            (e.src =
              "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
              (e.onload = e.onerror =
                function () {
                  t(1 === e.height);
                });
          })),
        this.isSupported
      );
    }
  }
  class Zg {
    constructor(t) {
      (this.parser = t),
        (this.name = Ng.EXT_TEXTURE_AVIF),
        (this.isSupported = null);
    }
    loadTexture(t) {
      const e = this.name,
        n = this.parser,
        i = n.json,
        r = i.textures[t];
      if (!r.extensions || !r.extensions[e]) return null;
      const s = r.extensions[e],
        a = i.images[s.source];
      let o = n.textureLoader;
      if (a.uri) {
        const t = n.options.manager.getHandler(a.uri);
        null !== t && (o = t);
      }
      return this.detectSupport().then(function (r) {
        if (r) return n.loadTextureImage(t, s.source, o);
        if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
          throw new Error(
            "THREE.GLTFLoader: AVIF required by asset but unsupported."
          );
        return n.loadTexture(t);
      });
    }
    detectSupport() {
      return (
        this.isSupported ||
          (this.isSupported = new Promise(function (t) {
            const e = new Image();
            (e.src =
              "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
              (e.onload = e.onerror =
                function () {
                  t(1 === e.height);
                });
          })),
        this.isSupported
      );
    }
  }
  class Jg {
    constructor(t) {
      (this.name = Ng.EXT_MESHOPT_COMPRESSION), (this.parser = t);
    }
    loadBufferView(t) {
      const e = this.parser.json,
        n = e.bufferViews[t];
      if (n.extensions && n.extensions[this.name]) {
        const t = n.extensions[this.name],
          i = this.parser.getDependency("buffer", t.buffer),
          r = this.parser.options.meshoptDecoder;
        if (!r || !r.supported) {
          if (
            e.extensionsRequired &&
            e.extensionsRequired.indexOf(this.name) >= 0
          )
            throw new Error(
              "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
            );
          return null;
        }
        return i.then(function (e) {
          const n = t.byteOffset || 0,
            i = t.byteLength || 0,
            s = t.count,
            a = t.byteStride,
            o = new Uint8Array(e, n, i);
          return r.decodeGltfBufferAsync
            ? r
                .decodeGltfBufferAsync(s, a, o, t.mode, t.filter)
                .then(function (t) {
                  return t.buffer;
                })
            : r.ready.then(function () {
                const e = new ArrayBuffer(s * a);
                return (
                  r.decodeGltfBuffer(
                    new Uint8Array(e),
                    s,
                    a,
                    o,
                    t.mode,
                    t.filter
                  ),
                  e
                );
              });
        });
      }
      return null;
    }
  }
  class Qg {
    constructor(t) {
      (this.name = Ng.EXT_MESH_GPU_INSTANCING), (this.parser = t);
    }
    createNodeMesh(t) {
      const e = this.parser.json,
        n = e.nodes[t];
      if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh)
        return null;
      const i = e.meshes[n.mesh];
      for (const t of i.primitives)
        if (
          t.mode !== o_.TRIANGLES &&
          t.mode !== o_.TRIANGLE_STRIP &&
          t.mode !== o_.TRIANGLE_FAN &&
          void 0 !== t.mode
        )
          return null;
      const r = n.extensions[this.name].attributes,
        s = [],
        a = {};
      for (const t in r)
        s.push(
          this.parser
            .getDependency("accessor", r[t])
            .then((e) => ((a[t] = e), a[t]))
        );
      return s.length < 1
        ? null
        : (s.push(this.parser.createNodeMesh(t)),
          Promise.all(s).then((t) => {
            const e = t.pop(),
              n = e.isGroup ? e.children : [e],
              i = t[0].count,
              r = [];
            for (const t of n) {
              const e = new be(),
                n = new Yt(),
                s = new qt(),
                o = new Yt(1, 1, 1),
                l = new Ea(t.geometry, t.material, i);
              for (let t = 0; t < i; t++)
                a.TRANSLATION && n.fromBufferAttribute(a.TRANSLATION, t),
                  a.ROTATION && s.fromBufferAttribute(a.ROTATION, t),
                  a.SCALE && o.fromBufferAttribute(a.SCALE, t),
                  l.setMatrixAt(t, e.compose(n, s, o));
              for (const e in a)
                if ("_COLOR_0" === e) {
                  const t = a[e];
                  l.instanceColor = new _a(t.array, t.itemSize, t.normalized);
                } else
                  "TRANSLATION" !== e &&
                    "ROTATION" !== e &&
                    "SCALE" !== e &&
                    t.geometry.setAttribute(e, a[e]);
              Ke.prototype.copy.call(l, t),
                this.parser.assignFinalMaterial(l),
                r.push(l);
            }
            return e.isGroup ? (e.clear(), e.add(...r), e) : r[0];
          }));
    }
  }
  const $g = "glTF";
  class t_ {
    constructor(t) {
      (this.name = Ng.KHR_BINARY_GLTF),
        (this.content = null),
        (this.body = null);
      const e = new DataView(t, 0, 12),
        n = new TextDecoder();
      if (
        ((this.header = {
          magic: n.decode(new Uint8Array(t.slice(0, 4))),
          version: e.getUint32(4, !0),
          length: e.getUint32(8, !0),
        }),
        this.header.magic !== $g)
      )
        throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      if (this.header.version < 2)
        throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      const i = this.header.length - 12,
        r = new DataView(t, 12);
      let s = 0;
      for (; s < i; ) {
        const e = r.getUint32(s, !0);
        s += 4;
        const i = r.getUint32(s, !0);
        if (((s += 4), 1313821514 === i)) {
          const i = new Uint8Array(t, 12 + s, e);
          this.content = n.decode(i);
        } else if (5130562 === i) {
          const n = 12 + s;
          this.body = t.slice(n, n + e);
        }
        s += e;
      }
      if (null === this.content)
        throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
  class e_ {
    constructor(t, e) {
      if (!e)
        throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      (this.name = Ng.KHR_DRACO_MESH_COMPRESSION),
        (this.json = t),
        (this.dracoLoader = e),
        this.dracoLoader.preload();
    }
    decodePrimitive(t, e) {
      const n = this.json,
        i = this.dracoLoader,
        r = t.extensions[this.name].bufferView,
        s = t.extensions[this.name].attributes,
        a = {},
        o = {},
        l = {};
      for (const t in s) {
        const e = d_[t] || t.toLowerCase();
        a[e] = s[t];
      }
      for (const e in t.attributes) {
        const i = d_[e] || e.toLowerCase();
        if (void 0 !== s[e]) {
          const r = n.accessors[t.attributes[e]],
            s = l_[r.componentType];
          (l[i] = s.name), (o[i] = !0 === r.normalized);
        }
      }
      return e.getDependency("bufferView", r).then(function (t) {
        return new Promise(function (e, n) {
          i.decodeDracoFile(
            t,
            function (t) {
              for (const e in t.attributes) {
                const n = t.attributes[e],
                  i = o[e];
                void 0 !== i && (n.normalized = i);
              }
              e(t);
            },
            a,
            l,
            Y,
            n
          );
        });
      });
    }
  }
  class n_ {
    constructor() {
      this.name = Ng.KHR_TEXTURE_TRANSFORM;
    }
    extendTexture(t, e) {
      return (void 0 !== e.texCoord && e.texCoord !== t.channel) ||
        void 0 !== e.offset ||
        void 0 !== e.rotation ||
        void 0 !== e.scale
        ? ((t = t.clone()),
          void 0 !== e.texCoord && (t.channel = e.texCoord),
          void 0 !== e.offset && t.offset.fromArray(e.offset),
          void 0 !== e.rotation && (t.rotation = e.rotation),
          void 0 !== e.scale && t.repeat.fromArray(e.scale),
          (t.needsUpdate = !0),
          t)
        : t;
    }
  }
  class i_ {
    constructor() {
      this.name = Ng.KHR_MESH_QUANTIZATION;
    }
  }
  class r_ extends Ja {
    constructor(t, e, n, i) {
      super(t, e, n, i);
    }
    copySampleValue_(t) {
      const e = this.resultBuffer,
        n = this.sampleValues,
        i = this.valueSize,
        r = t * i * 3 + i;
      for (let t = 0; t !== i; t++) e[t] = n[r + t];
      return e;
    }
    interpolate_(t, e, n, i) {
      const r = this.resultBuffer,
        s = this.sampleValues,
        a = this.valueSize,
        o = 2 * a,
        l = 3 * a,
        c = i - e,
        h = (n - e) / c,
        u = h * h,
        d = u * h,
        p = t * l,
        f = p - l,
        m = -2 * d + 3 * u,
        g = d - u,
        _ = 1 - m,
        v = g - u + h;
      for (let t = 0; t !== a; t++) {
        const e = s[f + t + a],
          n = s[f + t + o] * c,
          i = s[p + t + a],
          l = s[p + t] * c;
        r[t] = _ * e + v * n + m * i + g * l;
      }
      return r;
    }
  }
  const s_ = new qt();
  class a_ extends r_ {
    interpolate_(t, e, n, i) {
      const r = super.interpolate_(t, e, n, i);
      return s_.fromArray(r).normalize().toArray(r), r;
    }
  }
  const o_ = {
      FLOAT: 5126,
      FLOAT_MAT3: 35675,
      FLOAT_MAT4: 35676,
      FLOAT_VEC2: 35664,
      FLOAT_VEC3: 35665,
      FLOAT_VEC4: 35666,
      LINEAR: 9729,
      REPEAT: 10497,
      SAMPLER_2D: 35678,
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6,
      UNSIGNED_BYTE: 5121,
      UNSIGNED_SHORT: 5123,
    },
    l_ = {
      5120: Int8Array,
      5121: Uint8Array,
      5122: Int16Array,
      5123: Uint16Array,
      5125: Uint32Array,
      5126: Float32Array,
    },
    c_ = { 9728: S, 9729: w, 9984: b, 9985: 1007, 9986: E, 9987: A },
    h_ = { 33071: T, 33648: M, 10497: x },
    u_ = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
    d_ = {
      POSITION: "position",
      NORMAL: "normal",
      TANGENT: "tangent",
      TEXCOORD_0: "uv",
      TEXCOORD_1: "uv1",
      TEXCOORD_2: "uv2",
      TEXCOORD_3: "uv3",
      COLOR_0: "color",
      WEIGHTS_0: "skinWeight",
      JOINTS_0: "skinIndex",
    },
    p_ = {
      scale: "scale",
      translation: "position",
      rotation: "quaternion",
      weights: "morphTargetInfluences",
    },
    f_ = { CUBICSPLINE: void 0, LINEAR: V, STEP: G };
  function m_(t, e, n) {
    for (const i in n.extensions)
      void 0 === t[i] &&
        ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
        (e.userData.gltfExtensions[i] = n.extensions[i]));
  }
  function g_(t, e) {
    void 0 !== e.extras &&
      ("object" == typeof e.extras
        ? Object.assign(t.userData, e.extras)
        : console.warn(
            "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
          ));
  }
  function __(t, e) {
    if ((t.updateMorphTargets(), void 0 !== e.weights))
      for (let n = 0, i = e.weights.length; n < i; n++)
        t.morphTargetInfluences[n] = e.weights[n];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
      const n = e.extras.targetNames;
      if (t.morphTargetInfluences.length === n.length) {
        t.morphTargetDictionary = {};
        for (let e = 0, i = n.length; e < i; e++)
          t.morphTargetDictionary[n[e]] = e;
      } else
        console.warn(
          "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
        );
    }
  }
  function v_(t) {
    let e;
    const n = t.extensions && t.extensions[Ng.KHR_DRACO_MESH_COMPRESSION];
    if (
      ((e = n
        ? "draco:" + n.bufferView + ":" + n.indices + ":" + y_(n.attributes)
        : t.indices + ":" + y_(t.attributes) + ":" + t.mode),
      void 0 !== t.targets)
    )
      for (let n = 0, i = t.targets.length; n < i; n++)
        e += ":" + y_(t.targets[n]);
    return e;
  }
  function y_(t) {
    let e = "";
    const n = Object.keys(t).sort();
    for (let i = 0, r = n.length; i < r; i++) e += n[i] + ":" + t[n[i]] + ";";
    return e;
  }
  function x_(t) {
    switch (t) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error(
          "THREE.GLTFLoader: Unsupported normalized accessor component type."
        );
    }
  }
  const T_ = new be();
  class M_ {
    constructor(t = {}, e = {}) {
      (this.json = t),
        (this.extensions = {}),
        (this.plugins = {}),
        (this.options = e),
        (this.cache = new Ug()),
        (this.associations = new Map()),
        (this.primitiveCache = {}),
        (this.nodeCache = {}),
        (this.meshCache = { refs: {}, uses: {} }),
        (this.cameraCache = { refs: {}, uses: {} }),
        (this.lightCache = { refs: {}, uses: {} }),
        (this.sourceCache = {}),
        (this.textureCache = {}),
        (this.nodeNamesUsed = {});
      let n = !1,
        i = !1,
        r = -1;
      "undefined" != typeof navigator &&
        ((n =
          !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent)),
        (i = navigator.userAgent.indexOf("Firefox") > -1),
        (r = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
        "undefined" == typeof createImageBitmap || n || (i && r < 98)
          ? (this.textureLoader = new xo(this.options.manager))
          : (this.textureLoader = new Fo(this.options.manager)),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        (this.fileLoader = new vo(this.options.manager)),
        this.fileLoader.setResponseType("arraybuffer"),
        "use-credentials" === this.options.crossOrigin &&
          this.fileLoader.setWithCredentials(!0);
    }
    setExtensions(t) {
      this.extensions = t;
    }
    setPlugins(t) {
      this.plugins = t;
    }
    parse(t, e) {
      const n = this,
        i = this.json,
        r = this.extensions;
      this.cache.removeAll(),
        (this.nodeCache = {}),
        this._invokeAll(function (t) {
          return t._markDefs && t._markDefs();
        }),
        Promise.all(
          this._invokeAll(function (t) {
            return t.beforeRoot && t.beforeRoot();
          })
        )
          .then(function () {
            return Promise.all([
              n.getDependencies("scene"),
              n.getDependencies("animation"),
              n.getDependencies("camera"),
            ]);
          })
          .then(function (e) {
            const s = {
              scene: e[0][i.scene || 0],
              scenes: e[0],
              animations: e[1],
              cameras: e[2],
              asset: i.asset,
              parser: n,
              userData: {},
            };
            return (
              m_(r, s, i),
              g_(s, i),
              Promise.all(
                n._invokeAll(function (t) {
                  return t.afterRoot && t.afterRoot(s);
                })
              ).then(function () {
                t(s);
              })
            );
          })
          .catch(e);
    }
    _markDefs() {
      const t = this.json.nodes || [],
        e = this.json.skins || [],
        n = this.json.meshes || [];
      for (let n = 0, i = e.length; n < i; n++) {
        const i = e[n].joints;
        for (let e = 0, n = i.length; e < n; e++) t[i[e]].isBone = !0;
      }
      for (let e = 0, i = t.length; e < i; e++) {
        const i = t[e];
        void 0 !== i.mesh &&
          (this._addNodeRef(this.meshCache, i.mesh),
          void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
          void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera);
      }
    }
    _addNodeRef(t, e) {
      void 0 !== e &&
        (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++);
    }
    _getNodeRef(t, e, n) {
      if (t.refs[e] <= 1) return n;
      const i = n.clone(),
        r = (t, e) => {
          const n = this.associations.get(t);
          null != n && this.associations.set(e, n);
          for (const [n, i] of t.children.entries()) r(i, e.children[n]);
        };
      return r(n, i), (i.name += "_instance_" + t.uses[e]++), i;
    }
    _invokeOne(t) {
      const e = Object.values(this.plugins);
      e.push(this);
      for (let n = 0; n < e.length; n++) {
        const i = t(e[n]);
        if (i) return i;
      }
      return null;
    }
    _invokeAll(t) {
      const e = Object.values(this.plugins);
      e.unshift(this);
      const n = [];
      for (let i = 0; i < e.length; i++) {
        const r = t(e[i]);
        r && n.push(r);
      }
      return n;
    }
    getDependency(t, e) {
      const n = t + ":" + e;
      let i = this.cache.get(n);
      if (!i) {
        switch (t) {
          case "scene":
            i = this.loadScene(e);
            break;
          case "node":
            i = this._invokeOne(function (t) {
              return t.loadNode && t.loadNode(e);
            });
            break;
          case "mesh":
            i = this._invokeOne(function (t) {
              return t.loadMesh && t.loadMesh(e);
            });
            break;
          case "accessor":
            i = this.loadAccessor(e);
            break;
          case "bufferView":
            i = this._invokeOne(function (t) {
              return t.loadBufferView && t.loadBufferView(e);
            });
            break;
          case "buffer":
            i = this.loadBuffer(e);
            break;
          case "material":
            i = this._invokeOne(function (t) {
              return t.loadMaterial && t.loadMaterial(e);
            });
            break;
          case "texture":
            i = this._invokeOne(function (t) {
              return t.loadTexture && t.loadTexture(e);
            });
            break;
          case "skin":
            i = this.loadSkin(e);
            break;
          case "animation":
            i = this._invokeOne(function (t) {
              return t.loadAnimation && t.loadAnimation(e);
            });
            break;
          case "camera":
            i = this.loadCamera(e);
            break;
          default:
            if (
              ((i = this._invokeOne(function (n) {
                return n != this && n.getDependency && n.getDependency(t, e);
              })),
              !i)
            )
              throw new Error("Unknown type: " + t);
        }
        this.cache.add(n, i);
      }
      return i;
    }
    getDependencies(t) {
      let e = this.cache.get(t);
      if (!e) {
        const n = this,
          i = this.json[t + ("mesh" === t ? "es" : "s")] || [];
        (e = Promise.all(
          i.map(function (e, i) {
            return n.getDependency(t, i);
          })
        )),
          this.cache.add(t, e);
      }
      return e;
    }
    loadBuffer(t) {
      const e = this.json.buffers[t],
        n = this.fileLoader;
      if (e.type && "arraybuffer" !== e.type)
        throw new Error(
          "THREE.GLTFLoader: " + e.type + " buffer type is not supported."
        );
      if (void 0 === e.uri && 0 === t)
        return Promise.resolve(this.extensions[Ng.KHR_BINARY_GLTF].body);
      const i = this.options;
      return new Promise(function (t, r) {
        n.load(Oo.resolveURL(e.uri, i.path), t, void 0, function () {
          r(
            new Error(
              'THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'
            )
          );
        });
      });
    }
    loadBufferView(t) {
      const e = this.json.bufferViews[t];
      return this.getDependency("buffer", e.buffer).then(function (t) {
        const n = e.byteLength || 0,
          i = e.byteOffset || 0;
        return t.slice(i, i + n);
      });
    }
    loadAccessor(t) {
      const e = this,
        n = this.json,
        i = this.json.accessors[t];
      if (void 0 === i.bufferView && void 0 === i.sparse) {
        const t = u_[i.type],
          e = l_[i.componentType],
          n = !0 === i.normalized,
          r = new e(i.count * t);
        return Promise.resolve(new xn(r, t, n));
      }
      const r = [];
      return (
        void 0 !== i.bufferView
          ? r.push(this.getDependency("bufferView", i.bufferView))
          : r.push(null),
        void 0 !== i.sparse &&
          (r.push(
            this.getDependency("bufferView", i.sparse.indices.bufferView)
          ),
          r.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
        Promise.all(r).then(function (t) {
          const r = t[0],
            s = u_[i.type],
            a = l_[i.componentType],
            o = a.BYTES_PER_ELEMENT,
            l = o * s,
            c = i.byteOffset || 0,
            h =
              void 0 !== i.bufferView
                ? n.bufferViews[i.bufferView].byteStride
                : void 0,
            u = !0 === i.normalized;
          let d, p;
          if (h && h !== l) {
            const t = Math.floor(c / h),
              n =
                "InterleavedBuffer:" +
                i.bufferView +
                ":" +
                i.componentType +
                ":" +
                t +
                ":" +
                i.count;
            let l = e.cache.get(n);
            l ||
              ((d = new a(r, t * h, (i.count * h) / o)),
              (l = new $s(d, h / o)),
              e.cache.add(n, l)),
              (p = new ea(l, s, (c % h) / o, u));
          } else (d = null === r ? new a(i.count * s) : new a(r, c, i.count * s)), (p = new xn(d, s, u));
          if (void 0 !== i.sparse) {
            const e = u_.SCALAR,
              n = l_[i.sparse.indices.componentType],
              o = i.sparse.indices.byteOffset || 0,
              l = i.sparse.values.byteOffset || 0,
              c = new n(t[1], o, i.sparse.count * e),
              h = new a(t[2], l, i.sparse.count * s);
            null !== r &&
              (p = new xn(p.array.slice(), p.itemSize, p.normalized));
            for (let t = 0, e = c.length; t < e; t++) {
              const e = c[t];
              if (
                (p.setX(e, h[t * s]),
                s >= 2 && p.setY(e, h[t * s + 1]),
                s >= 3 && p.setZ(e, h[t * s + 2]),
                s >= 4 && p.setW(e, h[t * s + 3]),
                s >= 5)
              )
                throw new Error(
                  "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                );
            }
          }
          return p;
        })
      );
    }
    loadTexture(t) {
      const e = this.json,
        n = this.options,
        i = e.textures[t].source,
        r = e.images[i];
      let s = this.textureLoader;
      if (r.uri) {
        const t = n.manager.getHandler(r.uri);
        null !== t && (s = t);
      }
      return this.loadTextureImage(t, i, s);
    }
    loadTextureImage(t, e, n) {
      const i = this,
        r = this.json,
        s = r.textures[t],
        a = r.images[e],
        o = (a.uri || a.bufferView) + ":" + s.sampler;
      if (this.textureCache[o]) return this.textureCache[o];
      const l = this.loadImageSource(e, n)
        .then(function (e) {
          (e.flipY = !1),
            (e.name = s.name || a.name || ""),
            "" === e.name &&
              "string" == typeof a.uri &&
              !1 === a.uri.startsWith("data:image/") &&
              (e.name = a.uri);
          const n = (r.samplers || {})[s.sampler] || {};
          return (
            (e.magFilter = c_[n.magFilter] || w),
            (e.minFilter = c_[n.minFilter] || A),
            (e.wrapS = h_[n.wrapS] || x),
            (e.wrapT = h_[n.wrapT] || x),
            i.associations.set(e, { textures: t }),
            e
          );
        })
        .catch(function () {
          return null;
        });
      return (this.textureCache[o] = l), l;
    }
    loadImageSource(t, e) {
      const n = this.json,
        i = this.options;
      if (void 0 !== this.sourceCache[t])
        return this.sourceCache[t].then((t) => t.clone());
      const r = n.images[t],
        s = self.URL || self.webkitURL;
      let a = r.uri || "",
        o = !1;
      if (void 0 !== r.bufferView)
        a = this.getDependency("bufferView", r.bufferView).then(function (t) {
          o = !0;
          const e = new Blob([t], { type: r.mimeType });
          return (a = s.createObjectURL(e)), a;
        });
      else if (void 0 === r.uri)
        throw new Error(
          "THREE.GLTFLoader: Image " + t + " is missing URI and bufferView"
        );
      const l = Promise.resolve(a)
        .then(function (t) {
          return new Promise(function (n, r) {
            let s = n;
            !0 === e.isImageBitmapLoader &&
              (s = function (t) {
                const e = new Ht(t);
                (e.needsUpdate = !0), n(e);
              }),
              e.load(Oo.resolveURL(t, i.path), s, void 0, r);
          });
        })
        .then(function (t) {
          var e;
          return (
            !0 === o && s.revokeObjectURL(a),
            (t.userData.mimeType =
              r.mimeType ||
              ((e = r.uri).search(/\.jpe?g($|\?)/i) > 0 ||
              0 === e.search(/^data\:image\/jpeg/)
                ? "image/jpeg"
                : e.search(/\.webp($|\?)/i) > 0 ||
                  0 === e.search(/^data\:image\/webp/)
                ? "image/webp"
                : "image/png")),
            t
          );
        })
        .catch(function (t) {
          throw (
            (console.error("THREE.GLTFLoader: Couldn't load texture", a), t)
          );
        });
      return (this.sourceCache[t] = l), l;
    }
    assignTexture(t, e, n, i) {
      const r = this;
      return this.getDependency("texture", n.index).then(function (s) {
        if (!s) return null;
        if (
          (void 0 !== n.texCoord &&
            n.texCoord > 0 &&
            ((s = s.clone()).channel = n.texCoord),
          r.extensions[Ng.KHR_TEXTURE_TRANSFORM])
        ) {
          const t =
            void 0 !== n.extensions
              ? n.extensions[Ng.KHR_TEXTURE_TRANSFORM]
              : void 0;
          if (t) {
            const e = r.associations.get(s);
            (s = r.extensions[Ng.KHR_TEXTURE_TRANSFORM].extendTexture(s, t)),
              r.associations.set(s, e);
          }
        }
        return void 0 !== i && (s.colorSpace = i), (t[e] = s), s;
      });
    }
    assignFinalMaterial(t) {
      const e = t.geometry;
      let n = t.material;
      const i = void 0 === e.attributes.tangent,
        r = void 0 !== e.attributes.color,
        s = void 0 === e.attributes.normal;
      if (t.isPoints) {
        const t = "PointsMaterial:" + n.uuid;
        let e = this.cache.get(t);
        e ||
          ((e = new Fa()),
          gn.prototype.copy.call(e, n),
          e.color.copy(n.color),
          (e.map = n.map),
          (e.sizeAttenuation = !1),
          this.cache.add(t, e)),
          (n = e);
      } else if (t.isLine) {
        const t = "LineBasicMaterial:" + n.uuid;
        let e = this.cache.get(t);
        e ||
          ((e = new wa()),
          gn.prototype.copy.call(e, n),
          e.color.copy(n.color),
          (e.map = n.map),
          this.cache.add(t, e)),
          (n = e);
      }
      if (i || r || s) {
        let t = "ClonedMaterial:" + n.uuid + ":";
        i && (t += "derivative-tangents:"),
          r && (t += "vertex-colors:"),
          s && (t += "flat-shading:");
        let e = this.cache.get(t);
        e ||
          ((e = n.clone()),
          r && (e.vertexColors = !0),
          s && (e.flatShading = !0),
          i &&
            (e.normalScale && (e.normalScale.y *= -1),
            e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)),
          this.cache.add(t, e),
          this.associations.set(e, this.associations.get(n))),
          (n = e);
      }
      t.material = n;
    }
    getMaterialType() {
      return Xa;
    }
    loadMaterial(t) {
      const e = this,
        n = this.json,
        i = this.extensions,
        r = n.materials[t];
      let s;
      const a = {},
        o = [];
      if ((r.extensions || {})[Ng.KHR_MATERIALS_UNLIT]) {
        const t = i[Ng.KHR_MATERIALS_UNLIT];
        (s = t.getMaterialType()), o.push(t.extendParams(a, r, e));
      } else {
        const n = r.pbrMetallicRoughness || {};
        if (
          ((a.color = new pn(1, 1, 1)),
          (a.opacity = 1),
          Array.isArray(n.baseColorFactor))
        ) {
          const t = n.baseColorFactor;
          a.color.setRGB(t[0], t[1], t[2], Y), (a.opacity = t[3]);
        }
        void 0 !== n.baseColorTexture &&
          o.push(e.assignTexture(a, "map", n.baseColorTexture, q)),
          (a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1),
          (a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1),
          void 0 !== n.metallicRoughnessTexture &&
            (o.push(
              e.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)
            ),
            o.push(
              e.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture)
            )),
          (s = this._invokeOne(function (e) {
            return e.getMaterialType && e.getMaterialType(t);
          })),
          o.push(
            Promise.all(
              this._invokeAll(function (e) {
                return e.extendMaterialParams && e.extendMaterialParams(t, a);
              })
            )
          );
      }
      !0 === r.doubleSided && (a.side = 2);
      const l = r.alphaMode || "OPAQUE";
      if (
        ("BLEND" === l
          ? ((a.transparent = !0), (a.depthWrite = !1))
          : ((a.transparent = !1),
            "MASK" === l &&
              (a.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : 0.5)),
        void 0 !== r.normalTexture &&
          s !== _n &&
          (o.push(e.assignTexture(a, "normalMap", r.normalTexture)),
          (a.normalScale = new xt(1, 1)),
          void 0 !== r.normalTexture.scale))
      ) {
        const t = r.normalTexture.scale;
        a.normalScale.set(t, t);
      }
      if (
        (void 0 !== r.occlusionTexture &&
          s !== _n &&
          (o.push(e.assignTexture(a, "aoMap", r.occlusionTexture)),
          void 0 !== r.occlusionTexture.strength &&
            (a.aoMapIntensity = r.occlusionTexture.strength)),
        void 0 !== r.emissiveFactor && s !== _n)
      ) {
        const t = r.emissiveFactor;
        a.emissive = new pn().setRGB(t[0], t[1], t[2], Y);
      }
      return (
        void 0 !== r.emissiveTexture &&
          s !== _n &&
          o.push(e.assignTexture(a, "emissiveMap", r.emissiveTexture, q)),
        Promise.all(o).then(function () {
          const n = new s(a);
          return (
            r.name && (n.name = r.name),
            g_(n, r),
            e.associations.set(n, { materials: t }),
            r.extensions && m_(i, n, r),
            n
          );
        })
      );
    }
    createUniqueName(t) {
      const e = jo.sanitizeNodeName(t || "");
      return e in this.nodeNamesUsed
        ? e + "_" + ++this.nodeNamesUsed[e]
        : ((this.nodeNamesUsed[e] = 0), e);
    }
    loadGeometries(t) {
      const e = this,
        n = this.extensions,
        i = this.primitiveCache;
      function r(t) {
        return n[Ng.KHR_DRACO_MESH_COMPRESSION]
          .decodePrimitive(t, e)
          .then(function (n) {
            return S_(n, t, e);
          });
      }
      const s = [];
      for (let n = 0, a = t.length; n < a; n++) {
        const a = t[n],
          o = v_(a),
          l = i[o];
        if (l) s.push(l.promise);
        else {
          let t;
          (t =
            a.extensions && a.extensions[Ng.KHR_DRACO_MESH_COMPRESSION]
              ? r(a)
              : S_(new Ln(), a, e)),
            (i[o] = { primitive: a, promise: t }),
            s.push(t);
        }
      }
      return Promise.all(s);
    }
    loadMesh(t) {
      const e = this,
        n = this.json,
        i = this.extensions,
        r = n.meshes[t],
        s = r.primitives,
        a = [];
      for (let t = 0, e = s.length; t < e; t++) {
        const e =
          void 0 === s[t].material
            ? (void 0 === (o = this.cache).DefaultMaterial &&
                (o.DefaultMaterial = new Xa({
                  color: 16777215,
                  emissive: 0,
                  metalness: 1,
                  roughness: 1,
                  transparent: !1,
                  depthTest: !0,
                  side: 0,
                })),
              o.DefaultMaterial)
            : this.getDependency("material", s[t].material);
        a.push(e);
      }
      var o;
      return (
        a.push(e.loadGeometries(s)),
        Promise.all(a).then(function (n) {
          const a = n.slice(0, n.length - 1),
            o = n[n.length - 1],
            l = [];
          for (let n = 0, c = o.length; n < c; n++) {
            const c = o[n],
              h = s[n];
            let u;
            const d = a[n];
            if (
              h.mode === o_.TRIANGLES ||
              h.mode === o_.TRIANGLE_STRIP ||
              h.mode === o_.TRIANGLE_FAN ||
              void 0 === h.mode
            )
              (u = !0 === r.isSkinnedMesh ? new ua(c, d) : new Kn(c, d)),
                !0 === u.isSkinnedMesh && u.normalizeSkinWeights(),
                h.mode === o_.TRIANGLE_STRIP
                  ? (u.geometry = Dg(u.geometry, 1))
                  : h.mode === o_.TRIANGLE_FAN &&
                    (u.geometry = Dg(u.geometry, 2));
            else if (h.mode === o_.LINES) u = new Na(c, d);
            else if (h.mode === o_.LINE_STRIP) u = new Da(c, d);
            else if (h.mode === o_.LINE_LOOP) u = new Oa(c, d);
            else {
              if (h.mode !== o_.POINTS)
                throw new Error(
                  "THREE.GLTFLoader: Primitive mode unsupported: " + h.mode
                );
              u = new Ga(c, d);
            }
            Object.keys(u.geometry.morphAttributes).length > 0 && __(u, r),
              (u.name = e.createUniqueName(r.name || "mesh_" + t)),
              g_(u, r),
              h.extensions && m_(i, u, h),
              e.assignFinalMaterial(u),
              l.push(u);
          }
          for (let n = 0, i = l.length; n < i; n++)
            e.associations.set(l[n], { meshes: t, primitives: n });
          if (1 === l.length) return r.extensions && m_(i, l[0], r), l[0];
          const c = new Xs();
          r.extensions && m_(i, c, r), e.associations.set(c, { meshes: t });
          for (let t = 0, e = l.length; t < e; t++) c.add(l[t]);
          return c;
        })
      );
    }
    loadCamera(t) {
      let e;
      const n = this.json.cameras[t],
        i = n[n.type];
      if (i)
        return (
          "perspective" === n.type
            ? (e = new ri(
                yt(i.yfov),
                i.aspectRatio || 1,
                i.znear || 1,
                i.zfar || 2e6
              ))
            : "orthographic" === n.type &&
              (e = new Ci(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
          n.name && (e.name = this.createUniqueName(n.name)),
          g_(e, n),
          Promise.resolve(e)
        );
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
    }
    loadSkin(t) {
      const e = this.json.skins[t],
        n = [];
      for (let t = 0, i = e.joints.length; t < i; t++)
        n.push(this._loadNodeShallow(e.joints[t]));
      return (
        void 0 !== e.inverseBindMatrices
          ? n.push(this.getDependency("accessor", e.inverseBindMatrices))
          : n.push(null),
        Promise.all(n).then(function (t) {
          const n = t.pop(),
            i = t,
            r = [],
            s = [];
          for (let t = 0, a = i.length; t < a; t++) {
            const a = i[t];
            if (a) {
              r.push(a);
              const e = new be();
              null !== n && e.fromArray(n.array, 16 * t), s.push(e);
            } else
              console.warn(
                'THREE.GLTFLoader: Joint "%s" could not be found.',
                e.joints[t]
              );
          }
          return new ga(r, s);
        })
      );
    }
    loadAnimation(t) {
      const e = this.json,
        n = this,
        i = e.animations[t],
        r = i.name ? i.name : "animation_" + t,
        s = [],
        a = [],
        o = [],
        l = [],
        c = [];
      for (let t = 0, e = i.channels.length; t < e; t++) {
        const e = i.channels[t],
          n = i.samplers[e.sampler],
          r = e.target,
          h = r.node,
          u = void 0 !== i.parameters ? i.parameters[n.input] : n.input,
          d = void 0 !== i.parameters ? i.parameters[n.output] : n.output;
        void 0 !== r.node &&
          (s.push(this.getDependency("node", h)),
          a.push(this.getDependency("accessor", u)),
          o.push(this.getDependency("accessor", d)),
          l.push(n),
          c.push(r));
      }
      return Promise.all([
        Promise.all(s),
        Promise.all(a),
        Promise.all(o),
        Promise.all(l),
        Promise.all(c),
      ]).then(function (t) {
        const e = t[0],
          i = t[1],
          s = t[2],
          a = t[3],
          o = t[4],
          l = [];
        for (let t = 0, r = e.length; t < r; t++) {
          const r = e[t],
            c = i[t],
            h = s[t],
            u = a[t],
            d = o[t];
          if (void 0 === r) continue;
          r.updateMatrix && r.updateMatrix();
          const p = n._createAnimationTracks(r, c, h, u, d);
          if (p) for (let t = 0; t < p.length; t++) l.push(p[t]);
        }
        return new co(r, void 0, l);
      });
    }
    createNodeMesh(t) {
      const e = this.json,
        n = this,
        i = e.nodes[t];
      return void 0 === i.mesh
        ? null
        : n.getDependency("mesh", i.mesh).then(function (t) {
            const e = n._getNodeRef(n.meshCache, i.mesh, t);
            return (
              void 0 !== i.weights &&
                e.traverse(function (t) {
                  if (t.isMesh)
                    for (let e = 0, n = i.weights.length; e < n; e++)
                      t.morphTargetInfluences[e] = i.weights[e];
                }),
              e
            );
          });
    }
    loadNode(t) {
      const e = this,
        n = this.json.nodes[t],
        i = e._loadNodeShallow(t),
        r = [],
        s = n.children || [];
      for (let t = 0, n = s.length; t < n; t++)
        r.push(e.getDependency("node", s[t]));
      const a =
        void 0 === n.skin
          ? Promise.resolve(null)
          : e.getDependency("skin", n.skin);
      return Promise.all([i, Promise.all(r), a]).then(function (t) {
        const e = t[0],
          n = t[1],
          i = t[2];
        null !== i &&
          e.traverse(function (t) {
            t.isSkinnedMesh && t.bind(i, T_);
          });
        for (let t = 0, i = n.length; t < i; t++) e.add(n[t]);
        return e;
      });
    }
    _loadNodeShallow(t) {
      const e = this.json,
        n = this.extensions,
        i = this;
      if (void 0 !== this.nodeCache[t]) return this.nodeCache[t];
      const r = e.nodes[t],
        s = r.name ? i.createUniqueName(r.name) : "",
        a = [],
        o = i._invokeOne(function (e) {
          return e.createNodeMesh && e.createNodeMesh(t);
        });
      return (
        o && a.push(o),
        void 0 !== r.camera &&
          a.push(
            i.getDependency("camera", r.camera).then(function (t) {
              return i._getNodeRef(i.cameraCache, r.camera, t);
            })
          ),
        i
          ._invokeAll(function (e) {
            return e.createNodeAttachment && e.createNodeAttachment(t);
          })
          .forEach(function (t) {
            a.push(t);
          }),
        (this.nodeCache[t] = Promise.all(a).then(function (e) {
          let a;
          if (
            ((a =
              !0 === r.isBone
                ? new da()
                : e.length > 1
                ? new Xs()
                : 1 === e.length
                ? e[0]
                : new Ke()),
            a !== e[0])
          )
            for (let t = 0, n = e.length; t < n; t++) a.add(e[t]);
          if (
            (r.name && ((a.userData.name = r.name), (a.name = s)),
            g_(a, r),
            r.extensions && m_(n, a, r),
            void 0 !== r.matrix)
          ) {
            const t = new be();
            t.fromArray(r.matrix), a.applyMatrix4(t);
          } else void 0 !== r.translation && a.position.fromArray(r.translation), void 0 !== r.rotation && a.quaternion.fromArray(r.rotation), void 0 !== r.scale && a.scale.fromArray(r.scale);
          return (
            i.associations.has(a) || i.associations.set(a, {}),
            (i.associations.get(a).nodes = t),
            a
          );
        })),
        this.nodeCache[t]
      );
    }
    loadScene(t) {
      const e = this.extensions,
        n = this.json.scenes[t],
        i = this,
        r = new Xs();
      n.name && (r.name = i.createUniqueName(n.name)),
        g_(r, n),
        n.extensions && m_(e, r, n);
      const s = n.nodes || [],
        a = [];
      for (let t = 0, e = s.length; t < e; t++)
        a.push(i.getDependency("node", s[t]));
      return Promise.all(a).then(function (t) {
        for (let e = 0, n = t.length; e < n; e++) r.add(t[e]);
        return (
          (i.associations = ((t) => {
            const e = new Map();
            for (const [t, n] of i.associations)
              (t instanceof gn || t instanceof Ht) && e.set(t, n);
            return (
              t.traverse((t) => {
                const n = i.associations.get(t);
                null != n && e.set(t, n);
              }),
              e
            );
          })(r)),
          r
        );
      });
    }
    _createAnimationTracks(t, e, n, i, r) {
      const s = [],
        a = t.name ? t.name : t.uuid,
        o = [];
      let l;
      switch (
        (p_[r.path] === p_.weights
          ? t.traverse(function (t) {
              t.morphTargetInfluences && o.push(t.name ? t.name : t.uuid);
            })
          : o.push(a),
        p_[r.path])
      ) {
        case p_.weights:
          l = ro;
          break;
        case p_.rotation:
          l = ao;
          break;
        case p_.position:
        case p_.scale:
          l = lo;
          break;
        default:
          l = 1 === n.itemSize ? ro : lo;
      }
      const c = void 0 !== i.interpolation ? f_[i.interpolation] : V,
        h = this._getArrayFromAccessor(n);
      for (let t = 0, n = o.length; t < n; t++) {
        const n = new l(o[t] + "." + p_[r.path], e.array, h, c);
        "CUBICSPLINE" === i.interpolation &&
          this._createCubicSplineTrackInterpolant(n),
          s.push(n);
      }
      return s;
    }
    _getArrayFromAccessor(t) {
      let e = t.array;
      if (t.normalized) {
        const t = x_(e.constructor),
          n = new Float32Array(e.length);
        for (let i = 0, r = e.length; i < r; i++) n[i] = e[i] * t;
        e = n;
      }
      return e;
    }
    _createCubicSplineTrackInterpolant(t) {
      (t.createInterpolant = function (t) {
        return new (this instanceof ao ? a_ : r_)(
          this.times,
          this.values,
          this.getValueSize() / 3,
          t
        );
      }),
        (t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0);
    }
  }
  function S_(t, e, n) {
    const i = e.attributes,
      r = [];
    function s(e, i) {
      return n.getDependency("accessor", e).then(function (e) {
        t.setAttribute(i, e);
      });
    }
    for (const e in i) {
      const n = d_[e] || e.toLowerCase();
      n in t.attributes || r.push(s(i[e], n));
    }
    if (void 0 !== e.indices && !t.index) {
      const i = n.getDependency("accessor", e.indices).then(function (e) {
        t.setIndex(e);
      });
      r.push(i);
    }
    return (
      Dt.workingColorSpace !== Y &&
        "COLOR_0" in i &&
        console.warn(
          `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Dt.workingColorSpace}" not supported.`
        ),
      g_(t, e),
      (function (t, e, n) {
        const i = e.attributes,
          r = new Jt();
        if (void 0 === i.POSITION) return;
        {
          const t = n.json.accessors[i.POSITION],
            e = t.min,
            s = t.max;
          if (void 0 === e || void 0 === s)
            return void console.warn(
              "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
            );
          if (
            (r.set(new Yt(e[0], e[1], e[2]), new Yt(s[0], s[1], s[2])),
            t.normalized)
          ) {
            const e = x_(l_[t.componentType]);
            r.min.multiplyScalar(e), r.max.multiplyScalar(e);
          }
        }
        const s = e.targets;
        if (void 0 !== s) {
          const t = new Yt(),
            e = new Yt();
          for (let i = 0, r = s.length; i < r; i++) {
            const r = s[i];
            if (void 0 !== r.POSITION) {
              const i = n.json.accessors[r.POSITION],
                s = i.min,
                a = i.max;
              if (void 0 !== s && void 0 !== a) {
                if (
                  (e.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))),
                  e.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))),
                  e.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))),
                  i.normalized)
                ) {
                  const t = x_(l_[i.componentType]);
                  e.multiplyScalar(t);
                }
                t.max(e);
              } else
                console.warn(
                  "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                );
            }
          }
          r.expandByVector(t);
        }
        t.boundingBox = r;
        const a = new me();
        r.getCenter(a.center),
          (a.radius = r.min.distanceTo(r.max) / 2),
          (t.boundingSphere = a);
      })(t, e, n),
      Promise.all(r).then(function () {
        return void 0 !== e.targets
          ? (function (t, e, n) {
              let i = !1,
                r = !1,
                s = !1;
              for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t];
                if (
                  (void 0 !== n.POSITION && (i = !0),
                  void 0 !== n.NORMAL && (r = !0),
                  void 0 !== n.COLOR_0 && (s = !0),
                  i && r && s)
                )
                  break;
              }
              if (!i && !r && !s) return Promise.resolve(t);
              const a = [],
                o = [],
                l = [];
              for (let c = 0, h = e.length; c < h; c++) {
                const h = e[c];
                if (i) {
                  const e =
                    void 0 !== h.POSITION
                      ? n.getDependency("accessor", h.POSITION)
                      : t.attributes.position;
                  a.push(e);
                }
                if (r) {
                  const e =
                    void 0 !== h.NORMAL
                      ? n.getDependency("accessor", h.NORMAL)
                      : t.attributes.normal;
                  o.push(e);
                }
                if (s) {
                  const e =
                    void 0 !== h.COLOR_0
                      ? n.getDependency("accessor", h.COLOR_0)
                      : t.attributes.color;
                  l.push(e);
                }
              }
              return Promise.all([
                Promise.all(a),
                Promise.all(o),
                Promise.all(l),
              ]).then(function (e) {
                const n = e[0],
                  a = e[1],
                  o = e[2];
                return (
                  i && (t.morphAttributes.position = n),
                  r && (t.morphAttributes.normal = a),
                  s && (t.morphAttributes.color = o),
                  (t.morphTargetsRelative = !0),
                  t
                );
              });
            })(t, e.targets, n)
          : t;
      })
    );
  }
  function b_(t) {
    t &&
      E_(t).forEach(function (t) {
        for (var e = t.nodeValue, n = "", i = 0; i < e.length; i++)
          " " === e[i]
            ? (n += " ")
            : (n += '<span class="animateNav">' + e[i] + "</span>");
        var r = document.createElement("span");
        (r.innerHTML = n), t.parentNode.replaceChild(r, t);
      });
  }
  function E_(t) {
    var e = [];
    if (t.nodeType === Node.TEXT_NODE) e.push(t);
    else
      for (var n = t.childNodes, i = 0; i < n.length; i++)
        e = e.concat(E_(n[i]));
    return e;
  }
  b_(document.querySelector(".navHeading"));
  let w_ = 0;
  const A_ = new Audio(
    "https://ik.imagekit.io/sheryians/re-imagine/notification_3QcqOe1rhQ.mp3?updatedAt=1710334752635"
  );
  A_.preload = !0;
  const R_ = new Audio(
    "https://ik.imagekit.io/sheryians/re-imagine/imessage_send_xNzi_HqeQf.mp3?updatedAt=1710334824849"
  );
  function C_(t) {
    t
      ? (t.scrollTop = t.scrollHeight)
      : console.error("Element with ID '" + elementId + "' not found.");
  }
  function P_() {
    w_++;
    const t = D_[w_];
    !(function (e, n, i) {
      var r = document.createElement("div");
      r.classList.add("userSelections");
      var s = document.createElement("h4");
      s.classList.add("heading"),
        (s.textContent = "Your turn to reply."),
        r.appendChild(s);
      var a = document.createElement("div");
      a.classList.add("options"),
        e.forEach(function (e) {
          var n = document.createElement("div");
          n.classList.add("option"),
            (n.textContent = e),
            n.addEventListener("click", function () {
              var n;
              r.remove(),
                (n = e),
                (t.message = n),
                I_(),
                C_(document.querySelector(".messages"));
            }),
            a.appendChild(n);
        }),
        r.appendChild(a),
        n.appendChild(r),
        C_(document.querySelector(".messages"));
    })(t.options, document.querySelector(".conversation"));
  }
  function L_(t, e) {
    return Math.random() * (e - t) + t;
  }
  R_.preload = !0;
  const D_ = [
    {
      user: "Shristi",
      message: "arey ek news hai ",
      type: "receive",
      delay: 0.5,
      typingDelay: 0.1,
      seens: [
        {
          user: "https://images.pexels.com/photos/16160800/pexels-photo-16160800/free-photo-of-a-young-teenager-smiling.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0,
        },
        {
          user: "https://images.pexels.com/photos/1520760/pexels-photo-1520760.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0.7,
        },
        {
          user: "https://images.pexels.com/photos/16173670/pexels-photo-16173670/free-photo-of-gabrielguisso.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0.9,
        },
      ],
    },
    {
      user: "Ananya",
      message: "kya hua ",
      type: "receive",
      typingDelay: L_(0.4, 1.5),
      delay: L_(3, 4.5),
      seens: [
        {
          user: "https://images.pexels.com/photos/16160800/pexels-photo-16160800/free-photo-of-a-young-teenager-smiling.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0,
        },
        {
          user: "https://images.pexels.com/photos/1520760/pexels-photo-1520760.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0.7,
        },
        {
          user: "https://images.pexels.com/photos/16173670/pexels-photo-16173670/free-photo-of-gabrielguisso.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0.9,
        },
      ],
    },
    {
      user: "Shristi",
      message: "sheryians ka hackathon aya hai ",
      type: "receive",
      typingDelay: L_(0.4, 1.5),
      delay: L_(3, 4.5),
      seens: [
        {
          user: "https://images.pexels.com/photos/16160800/pexels-photo-16160800/free-photo-of-a-young-teenager-smiling.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0,
        },
        {
          user: "https://images.pexels.com/photos/1520760/pexels-photo-1520760.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0.7,
        },
        {
          user: "https://images.pexels.com/photos/16173670/pexels-photo-16173670/free-photo-of-gabrielguisso.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0.9,
        },
      ],
    },
    {
      user: "Arjun",
      message: "website gajab ki hai ",
      type: "receive",
      typingDelay: L_(0.4, 1.5),
      delay: L_(3, 4.5),
      seens: [
        {
          user: "https://images.pexels.com/photos/16160800/pexels-photo-16160800/free-photo-of-a-young-teenager-smiling.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0,
        },
        {
          user: "https://images.pexels.com/photos/1520760/pexels-photo-1520760.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0.7,
        },
        {
          user: "https://images.pexels.com/photos/16173670/pexels-photo-16173670/free-photo-of-gabrielguisso.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0.9,
        },
      ],
    },
    {
      user: "you",
      message: "",
      type: "send",
      typingDelay: 0.3,
      options: ["chalo dekhte hai", "kya khaas kiya hai ?"],
      delay: 0.5,
      seens: [
        {
          user: "https://images.pexels.com/photos/16160800/pexels-photo-16160800/free-photo-of-a-young-teenager-smiling.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0,
        },
        {
          user: "https://images.pexels.com/photos/1520760/pexels-photo-1520760.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0.7,
        },
        {
          user: "https://images.pexels.com/photos/16173670/pexels-photo-16173670/free-photo-of-gabrielguisso.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0.9,
        },
      ],
    },
    {
      user: "Arjun",
      message: "arey dekho to",
      type: "receive",
      typingDelay: L_(0.4, 2),
      delay: L_(3, 4.5),
      seens: [
        {
          user: "https://images.pexels.com/photos/16160800/pexels-photo-16160800/free-photo-of-a-young-teenager-smiling.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0,
        },
        {
          user: "https://images.pexels.com/photos/1520760/pexels-photo-1520760.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0.7,
        },
        {
          user: "https://images.pexels.com/photos/16173670/pexels-photo-16173670/free-photo-of-gabrielguisso.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0.9,
        },
      ],
    },
    {
      user: "you",
      message: "",
      type: "send",
      typingDelay: 0.2,
      options: ["chalo dekhte hai"],
      delay: 0.4,
      seens: [
        {
          user: "https://images.pexels.com/photos/16160800/pexels-photo-16160800/free-photo-of-a-young-teenager-smiling.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0,
        },
        {
          user: "https://images.pexels.com/photos/1520760/pexels-photo-1520760.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0.7,
        },
        {
          user: "https://images.pexels.com/photos/16173670/pexels-photo-16173670/free-photo-of-gabrielguisso.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
          delay: 0.9,
        },
      ],
    },
  ];
  function I_() {
    const t = document.querySelector(".messages");
    if (!D_[w_]) return;
    const e = D_[w_],
      n = document.createElement("div");
    n.classList.add("typing", "receive"),
      "send" == e.type && n.classList.add("outgoing");
    for (let t = 0; t < 3; t++) {
      const t = document.createElement("div");
      t.classList.add("indicator"), n.appendChild(t);
    }
    setTimeout(() => {
      t.appendChild(n), C_(document.querySelector(".messages"));
    }, 1e3 * e.typingDelay),
      setTimeout(async () => {
        t.removeChild(n);
        const i = document.createElement("div");
        i.classList.add("message"),
          "send" == e.type && i.classList.add("outgoing");
        const r = document.createElement("p");
        r.classList.add("user"), (r.textContent = e.user);
        const s = document.createElement("p");
        s.classList.add("data"), (s.textContent = e.message);
        const a = document.createElement("div");
        a.classList.add("seens"),
          e.seens.forEach((t) => {
            const e = document.createElement("div");
            e.classList.add("seen");
            const n = document.createElement("img");
            (n.src = t.user),
              (n.alt = ""),
              e.appendChild(n),
              setTimeout(() => {
                a.appendChild(e),
                  C_(document.querySelector(".messages")),
                  (R_.currentTime = 0),
                  (R_.volume = 0.05),
                  (R_.playsInline = !0),
                  R_.play().catch((t) => {});
              }, 1e3 * L_(0.2, 4.5));
          }),
          i.appendChild(r),
          i.appendChild(s),
          i.appendChild(a),
          t.appendChild(i),
          C_(t),
          (A_.currentTime = 0),
          (A_.playsInline = !0),
          A_.play().catch((t) => {}),
          "chalo dekhte hai" != e.message
            ? D_[w_ + 1] && "receive" == D_[w_ + 1].type
              ? (w_++, I_())
              : D_[w_ + 1] && P_()
            : setTimeout(async () => {
                (A_.volume = 0),
                  (R_.volume = 0),
                  await new Promise((t) => {
                    kd.to(".conversation", {
                      opacity: 0,
                      onComplete: () => {
                        (document.querySelector(".messages").style.display =
                          "none"),
                          t();
                      },
                    });
                  }),
                  YT(),
                  (document.querySelector(".startingAction").style.display =
                    "flex");
              }, 1e3);
      }, 1e3 * e.delay);
  }
  const U_ = new WeakMap();
  class N_ extends mo {
    constructor(t) {
      super(t),
        (this.decoderPath = ""),
        (this.decoderConfig = {}),
        (this.decoderBinary = null),
        (this.decoderPending = null),
        (this.workerLimit = 4),
        (this.workerPool = []),
        (this.workerNextTaskID = 1),
        (this.workerSourceURL = ""),
        (this.defaultAttributeIDs = {
          position: "POSITION",
          normal: "NORMAL",
          color: "COLOR",
          uv: "TEX_COORD",
        }),
        (this.defaultAttributeTypes = {
          position: "Float32Array",
          normal: "Float32Array",
          color: "Float32Array",
          uv: "Float32Array",
        });
    }
    setDecoderPath(t) {
      return (this.decoderPath = t), this;
    }
    setDecoderConfig(t) {
      return (this.decoderConfig = t), this;
    }
    setWorkerLimit(t) {
      return (this.workerLimit = t), this;
    }
    load(t, e, n, i) {
      const r = new vo(this.manager);
      r.setPath(this.path),
        r.setResponseType("arraybuffer"),
        r.setRequestHeader(this.requestHeader),
        r.setWithCredentials(this.withCredentials),
        r.load(
          t,
          (t) => {
            this.parse(t, e, i);
          },
          n,
          i
        );
    }
    parse(t, e, n = () => {}) {
      this.decodeDracoFile(t, e, null, null, q).catch(n);
    }
    decodeDracoFile(t, e, n, i, r = Y, s = () => {}) {
      const a = {
        attributeIDs: n || this.defaultAttributeIDs,
        attributeTypes: i || this.defaultAttributeTypes,
        useUniqueIDs: !!n,
        vertexColorSpace: r,
      };
      return this.decodeGeometry(t, a).then(e).catch(s);
    }
    decodeGeometry(t, e) {
      const n = JSON.stringify(e);
      if (U_.has(t)) {
        const e = U_.get(t);
        if (e.key === n) return e.promise;
        if (0 === t.byteLength)
          throw new Error(
            "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
          );
      }
      let i;
      const r = this.workerNextTaskID++,
        s = t.byteLength,
        a = this._getWorker(r, s)
          .then(
            (n) => (
              (i = n),
              new Promise((n, s) => {
                (i._callbacks[r] = { resolve: n, reject: s }),
                  i.postMessage(
                    { type: "decode", id: r, taskConfig: e, buffer: t },
                    [t]
                  );
              })
            )
          )
          .then((t) => this._createGeometry(t.geometry));
      return (
        a
          .catch(() => !0)
          .then(() => {
            i && r && this._releaseTask(i, r);
          }),
        U_.set(t, { key: n, promise: a }),
        a
      );
    }
    _createGeometry(t) {
      const e = new Ln();
      t.index && e.setIndex(new xn(t.index.array, 1));
      for (let n = 0; n < t.attributes.length; n++) {
        const i = t.attributes[n],
          r = i.name,
          s = i.array,
          a = i.itemSize,
          o = new xn(s, a);
        "color" === r &&
          (this._assignVertexColorSpace(o, i.vertexColorSpace),
          (o.normalized = s instanceof Float32Array == 0)),
          e.setAttribute(r, o);
      }
      return e;
    }
    _assignVertexColorSpace(t, e) {
      if (e !== q) return;
      const n = new pn();
      for (let e = 0, i = t.count; e < i; e++)
        n.fromBufferAttribute(t, e).convertSRGBToLinear(),
          t.setXYZ(e, n.r, n.g, n.b);
    }
    _loadLibrary(t, e) {
      const n = new vo(this.manager);
      return (
        n.setPath(this.decoderPath),
        n.setResponseType(e),
        n.setWithCredentials(this.withCredentials),
        new Promise((e, i) => {
          n.load(t, e, void 0, i);
        })
      );
    }
    preload() {
      return this._initDecoder(), this;
    }
    _initDecoder() {
      if (this.decoderPending) return this.decoderPending;
      const t =
          "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
        e = [];
      return (
        t
          ? e.push(this._loadLibrary("draco_decoder.js", "text"))
          : (e.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
            e.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
        (this.decoderPending = Promise.all(e).then((e) => {
          const n = e[0];
          t || (this.decoderConfig.wasmBinary = e[1]);
          const i = O_.toString(),
            r = [
              "/* draco decoder */",
              n,
              "",
              "/* worker */",
              i.substring(i.indexOf("{") + 1, i.lastIndexOf("}")),
            ].join("\n");
          this.workerSourceURL = URL.createObjectURL(new Blob([r]));
        })),
        this.decoderPending
      );
    }
    _getWorker(t, e) {
      return this._initDecoder().then(() => {
        if (this.workerPool.length < this.workerLimit) {
          const t = new Worker(this.workerSourceURL);
          (t._callbacks = {}),
            (t._taskCosts = {}),
            (t._taskLoad = 0),
            t.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
            (t.onmessage = function (e) {
              const n = e.data;
              switch (n.type) {
                case "decode":
                  t._callbacks[n.id].resolve(n);
                  break;
                case "error":
                  t._callbacks[n.id].reject(n);
                  break;
                default:
                  console.error(
                    'THREE.DRACOLoader: Unexpected message, "' + n.type + '"'
                  );
              }
            }),
            this.workerPool.push(t);
        } else
          this.workerPool.sort(function (t, e) {
            return t._taskLoad > e._taskLoad ? -1 : 1;
          });
        const n = this.workerPool[this.workerPool.length - 1];
        return (n._taskCosts[t] = e), (n._taskLoad += e), n;
      });
    }
    _releaseTask(t, e) {
      (t._taskLoad -= t._taskCosts[e]),
        delete t._callbacks[e],
        delete t._taskCosts[e];
    }
    debug() {
      console.log(
        "Task load: ",
        this.workerPool.map((t) => t._taskLoad)
      );
    }
    dispose() {
      for (let t = 0; t < this.workerPool.length; ++t)
        this.workerPool[t].terminate();
      return (
        (this.workerPool.length = 0),
        "" !== this.workerSourceURL &&
          URL.revokeObjectURL(this.workerSourceURL),
        this
      );
    }
  }
  function O_() {
    let t, e;
    function n(t, e, n, i, r, s) {
      const a = s.num_components(),
        o = n.num_points() * a,
        l = o * r.BYTES_PER_ELEMENT,
        c = (function (t, e) {
          switch (e) {
            case Float32Array:
              return t.DT_FLOAT32;
            case Int8Array:
              return t.DT_INT8;
            case Int16Array:
              return t.DT_INT16;
            case Int32Array:
              return t.DT_INT32;
            case Uint8Array:
              return t.DT_UINT8;
            case Uint16Array:
              return t.DT_UINT16;
            case Uint32Array:
              return t.DT_UINT32;
          }
        })(t, r),
        h = t._malloc(l);
      e.GetAttributeDataArrayForAllPoints(n, s, c, l, h);
      const u = new r(t.HEAPF32.buffer, h, o).slice();
      return t._free(h), { name: i, array: u, itemSize: a };
    }
    onmessage = function (i) {
      const r = i.data;
      switch (r.type) {
        case "init":
          (t = r.decoderConfig),
            (e = new Promise(function (e) {
              (t.onModuleLoaded = function (t) {
                e({ draco: t });
              }),
                DracoDecoderModule(t);
            }));
          break;
        case "decode":
          const i = r.buffer,
            s = r.taskConfig;
          e.then((t) => {
            const e = t.draco,
              a = new e.Decoder();
            try {
              const t = (function (t, e, i, r) {
                  const s = r.attributeIDs,
                    a = r.attributeTypes;
                  let o, l;
                  const c = e.GetEncodedGeometryType(i);
                  if (c === t.TRIANGULAR_MESH)
                    (o = new t.Mesh()),
                      (l = e.DecodeArrayToMesh(i, i.byteLength, o));
                  else {
                    if (c !== t.POINT_CLOUD)
                      throw new Error(
                        "THREE.DRACOLoader: Unexpected geometry type."
                      );
                    (o = new t.PointCloud()),
                      (l = e.DecodeArrayToPointCloud(i, i.byteLength, o));
                  }
                  if (!l.ok() || 0 === o.ptr)
                    throw new Error(
                      "THREE.DRACOLoader: Decoding failed: " + l.error_msg()
                    );
                  const h = { index: null, attributes: [] };
                  for (const i in s) {
                    const l = self[a[i]];
                    let c, u;
                    if (r.useUniqueIDs)
                      (u = s[i]), (c = e.GetAttributeByUniqueId(o, u));
                    else {
                      if (((u = e.GetAttributeId(o, t[s[i]])), -1 === u))
                        continue;
                      c = e.GetAttribute(o, u);
                    }
                    const d = n(t, e, o, i, l, c);
                    "color" === i && (d.vertexColorSpace = r.vertexColorSpace),
                      h.attributes.push(d);
                  }
                  return (
                    c === t.TRIANGULAR_MESH &&
                      (h.index = (function (t, e, n) {
                        const i = 3 * n.num_faces(),
                          r = 4 * i,
                          s = t._malloc(r);
                        e.GetTrianglesUInt32Array(n, r, s);
                        const a = new Uint32Array(
                          t.HEAPF32.buffer,
                          s,
                          i
                        ).slice();
                        return t._free(s), { array: a, itemSize: 1 };
                      })(t, e, o)),
                    t.destroy(o),
                    h
                  );
                })(e, a, new Int8Array(i), s),
                o = t.attributes.map((t) => t.array.buffer);
              t.index && o.push(t.index.array.buffer),
                self.postMessage({ type: "decode", id: r.id, geometry: t }, o);
            } catch (t) {
              console.error(t),
                self.postMessage({ type: "error", id: r.id, error: t.message });
            } finally {
              e.destroy(a);
            }
          });
      }
    };
  }
  async function F_() {
    DeviceMotionEvent &&
      "function" == typeof DeviceMotionEvent.requestPermission &&
      DeviceMotionEvent.requestPermission();
  }
  function k_() {
    const t = navigator.userAgent.toLowerCase();
    return (
      /iphone|ipod|ipad/i.test(t) ||
      (t.includes("crios") && "applewebkit" in navigator) ||
      /android/i.test(t)
    );
  }
  function z_(t, e = 0.1) {
    var n,
      i = 0.5,
      r = 0.5,
      s = 0,
      a = 0,
      o = 0.5,
      l = 0.5;
    if (k_())
      return (
        window.DeviceMotionEvent
          ? (async function (
              t,
              e = { strength: 0.02, damping: 1, threshold: 0.15 }
            ) {
              if ((await F_(), window.DeviceMotionEvent)) {
                const n = new Gt(0);
                let i = 0,
                  r = 0;
                function s(t) {
                  (i = t.accelerationIncludingGravity.x),
                    (r = t.accelerationIncludingGravity.y);
                }
                /iPad|iPhone|iPod/.test(navigator.userAgent) && window.MSStream,
                  window.addEventListener("devicemotion", s);
                let a = 0,
                  o = 60;
                function l(e) {
                  a || (a = e),
                    e - a > 1e3 / o &&
                      ((a = e),
                      (n.x = kd.utils.interpolate(n.x, i - n.z, 0.05)),
                      (n.y = kd.utils.interpolate(n.y, r - n.w, 0.05)),
                      (n.z = i),
                      (n.w = r),
                      t(-n.x, n.y)),
                    requestAnimationFrame(l);
                }
                return (
                  requestAnimationFrame(l),
                  function () {
                    window.removeEventListener("devicemotion", s),
                      kd.ticker.remove();
                  }
                );
              }
              console.warn("Device motion not supported on this device.");
            })(t)
          : t(0, 0),
        function () {}
      );
    function c(t) {
      var e = window.innerWidth,
        n = window.innerHeight;
      (o = t.clientX / e), (l = t.clientY / n);
    }
    let h = 0;
    return (
      (n = requestAnimationFrame(function c(u) {
        h || (h = u),
          u - h > 1e3 / 60 &&
            ((h = u),
            (s = kd.utils.interpolate(s, o - i, e)),
            (a = kd.utils.interpolate(a, l - r, e)),
            (i = kd.utils.interpolate(i, o, e)),
            (r = kd.utils.interpolate(r, l, e)),
            t(s, a)),
          (n = requestAnimationFrame(c));
      })),
      document.addEventListener("mousemove", c),
      function () {
        document.removeEventListener("mousemove", c), cancelAnimationFrame(n);
      }
    );
  }
  document
    .querySelector(".videoContainer .videoWrapper")
    .addEventListener("click", (t) => {
      if (
        document
          .querySelector(".videoContainer .videoWrapper")
          .classList.contains("playing")
      )
        document
          .querySelector(".videoContainer .videoWrapper")
          .querySelector("video")
          .pause(),
          document
            .querySelector(".videoContainer .videoWrapper")
            .classList.toggle("playing");
      else
        try {
          document
            .querySelector(".videoContainer .videoWrapper")
            .querySelector("video")
            .play(),
            document
              .querySelector(".videoContainer .videoWrapper")
              .classList.toggle("playing");
        } catch (t) {}
    });
  const B_ = new po(),
    H_ = new xo(B_),
    G_ = new Ig(B_),
    V_ = new N_();
  V_.setDecoderConfig({ type: "js" }),
    V_.setDecoderPath("https://www.gstatic.com/draco/v1/decoders/"),
    G_.setDRACOLoader(V_);
  const W_ = async (t, e, n = 0, i = !1) => {
    const r = [];
    let s;
    const a = [];
    await Promise.all(
      t.map(
        (t) =>
          new Promise((n) => {
            G_.load(
              t.path,
              (i) => {
                const s = i.scene;
                s.position.copy(t.initialState.position),
                  s.scale.copy(t.initialState.scale),
                  s.traverse((e) => {
                    e.isMesh &&
                      ((e.material.transparent = !0),
                      (e.material.opacity = t.initialState.opacity),
                      t.texture &&
                        H_.load(t.texture, (t) => {
                          (e.material.map = t), (e.material.needsUpdate = !0);
                        }));
                  }),
                  e.add(s);
                const o = {
                  model: s,
                  positionTween: kd.to(s.position, {
                    duration: 1,
                    x: t.finalState.position.x,
                    z: t.finalState.position.z,
                    y: t.finalState.position.y,
                    paused: !0,
                    ease: "power3.out",
                  }),
                  scaleTween: kd.to(s.scale, {
                    duration: 1,
                    x: t.finalState.scale.x,
                    y: t.finalState.scale.y,
                    z: t.finalState.scale.z,
                    paused: !0,
                  }),
                  continuousAnimation: t.modelAnimation,
                };
                t.finalState.rotation &&
                  (o.rotationTween = kd.to(s.rotation, {
                    duration: 1,
                    x: t.finalState.rotation.x,
                    y: t.finalState.rotation.y,
                    z: t.finalState.rotation.z,
                    paused: !0,
                  })),
                  s.traverse((e) => {
                    e.isMesh &&
                      (o.opacityTween = kd.to(e.material, {
                        duration: 1,
                        opacity: t.finalState.opacity,
                        paused: !0,
                      }));
                  }),
                  r.push(o),
                  a.push(o.model),
                  n();
              },
              void 0,
              (t) => {
                console.error("Error loading GLTF model:", t);
              }
            );
          })
      )
    );
    const o = () => {
      const t = performance.now() / 1e3;
      r.forEach((e) => {
        const n = 0.001 * Math.sin(t);
        e.continuousAnimation.positionRaf &&
          (e.model.position[e.continuousAnimation.positionRaf] +=
            n * e.continuousAnimation.amplitude),
          e.continuousAnimation.rotationRaf &&
            (e.model.rotation[e.continuousAnimation.rotationRaf] +=
              n * e.continuousAnimation.amplitude);
      }),
        (s = requestAnimationFrame(o));
    };
    return function () {
      return (
        o(),
        setTimeout(() => {
          r.forEach((t) => {
            t.positionTween.play(),
              t.scaleTween.play(),
              t.rotationTween && t.rotationTween.play(),
              t.opacityTween && t.opacityTween.play();
          });
        }, 1e3 * n),
        {
          models: a,
          cleanupMiniModels: () => {
            if (i)
              return new Promise((t) => {
                r.forEach((e) => {
                  e.positionTween.reverse(),
                    e.scaleTween.reverse(),
                    e.rotationTween && e.rotationTween.reverse(),
                    e.opacityTween && e.opacityTween.reverse(),
                    kd.to(
                      {},
                      {
                        duration: 1.5,
                        onComplete: () => {
                          e.model.traverse((t) => {
                            kd.to(t.material, { opacity: 0, duration: 1.5 });
                          }),
                            t();
                        },
                      }
                    );
                });
              });
            cancelAnimationFrame(s),
              a.forEach((t) => {
                t.traverse((t) => {
                  kd.to(t.material, { opacity: 0, duration: 1.5 });
                });
              });
          },
        }
      );
    };
  };
  async function X_() {
    return (
      document.querySelector(".actions").remove(),
      document.querySelector("canvas").remove(),
      Date.now(),
      document.querySelector("#readed").addEventListener("click", j_),
      new Promise((t) => {
        const e = document.querySelector(".teamForm");
        (e.style.display = "flex"),
          kd.fromTo(e, { opacity: 0 }, { opacity: 1, ease: "power1.inOut" });
      })
    );
  }
  async function j_() {
    if (document.querySelector("#checkbox").checked)
      return (
        document.querySelector(".checkbox").classList.remove("error"),
        new Promise((t) => {
          kd.to(".teamForm .readTerms", {
            opacity: 0,
            duration: 0.6,
            onComplete: () => {
              (document.querySelector(".teamForm .readTerms").style.display =
                "none"),
                (document.querySelector(".teamForm form").style.display =
                  "flex");
              const t = document.querySelector(".teamForm form");
              (t.style.display = "flex"),
                kd.fromTo(
                  t,
                  { opacity: 0 },
                  { opacity: 1, ease: "power1.inOut" }
                );
            },
          });
        })
      );
    document.querySelector(".checkbox").classList.add("error");
  }
  (window.showPaymentSuccess = async function (t = "web-wizards") {
    return (
      (document.querySelector("#teamNameToShow").textContent = t),
      (document.querySelector(".afterPayment").style.display = "flex"),
      new Promise((t, e) => {
        kd.to(".afterPayment", {
          opacity: 1,
          ease: "power3.inOut",
          onComplete: () => {
            t();
          },
        });
      })
    );
  }),
    (window.paymentProcessing = async function () {
      return (
        (document.querySelector(".paymentProcessing").style.display = "flex"),
        new Promise((t, e) => {
          kd.fromTo(
            ".paymentProcessing",
            { opacity: 0 },
            {
              opacity: 1,
              ease: "power3.inOut",
              onComplete: () => {
                t();
              },
            }
          );
        })
      );
    }),
    (window.hidePaymentProcessing = async function () {
      return (
        (document.querySelector(".paymentProcessing").style.display = "flex"),
        new Promise((t, e) => {
          kd.fromTo(
            ".paymentProcessing",
            { opacity: 1 },
            {
              opacity: 0,
              ease: "power3.inOut",
              onComplete: () => {
                (document.querySelector(".paymentProcessing").style.display =
                  "none"),
                  t();
              },
            }
          );
        })
      );
    });
  const q_ = { x: 0 };
  function Y_(t, e, n = 0.001, i = 2.5, r = 1) {
    const s = new ni({
        uniforms: {
          uTexture: { value: null },
          uContrast: { value: n },
          uSaturation: { value: i },
          uOpacity: { value: 0 },
          uWhiteThreshold: { value: 0.01 },
          uWhiteLimit: { value: 0.001 },
          uBrightness: { value: r },
        },
        side: 2,
        vertexShader:
          "\n      varying vec2 vUv;\n      void main() {\n        vUv = uv; // Pass texture coordinates to fragment shader\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n      }\n    ",
        fragmentShader:
          "\n    \n    uniform sampler2D uTexture;\n    uniform bool uIsColor;\n    uniform vec3 uColor; // Add a uniform for color\n    varying vec2 vUv;\n    uniform float uContrast; // Add a uniform for contrast\n    uniform float uSaturation; // Add a uniform for saturation\n    uniform float uOpacity; // Add a uniform for opacity\n    uniform float uWhiteThreshold; // Add a uniform for white threshold\n    uniform float uWhiteLimit; // Add a uniform for limiting white and bright spots\n    uniform float uBrightness; // Add a uniform for limiting white and bright spots\n\n    void main() {\n      vec4 frag_Color = texture2D(uTexture, vUv);\n\n      // Apply contrast adjustment with a threshold for bright areas\n      float brightness = (frag_Color.r + frag_Color.g + frag_Color.b) / 3.0;\n      float threshold = uWhiteThreshold; // Adjust this threshold as needed for whiter spots\n      float contrastFactor = smoothstep(threshold, uWhiteLimit, brightness) * uContrast;\n      frag_Color.rgb = mix(frag_Color.rgb * 0.5, frag_Color.rgb, contrastFactor);\n      \n      // Set opacity\n      frag_Color.a = uOpacity;\n      frag_Color.rgb *= uBrightness;\n      // Apply saturation adjustment\n      float average = (frag_Color.r + frag_Color.g + frag_Color.b) / 3.0;\n      frag_Color.rgb = mix(vec3(average) * 1.1, frag_Color.rgb, uSaturation);\n      gl_FragColor = frag_Color;\n    }\n    ",
      }),
      a = new Kn(t, s);
    return (
      e &&
        H_.load(e, (t) => {
          (t.generateMipmaps = !1), (s.uniforms.uTexture.value = t);
        }),
      a
    );
  }
  kd.registerPlugin(ug);
  let K_,
    Z_,
    J_,
    Q_,
    $_,
    tv,
    ev,
    nv,
    iv,
    rv,
    sv,
    av = {
      autoSleep: 120,
      force3D: "auto",
      nullTargetWarn: 1,
      units: { lineHeight: "" },
    },
    ov = { duration: 0.5, overwrite: !1, delay: 0 },
    lv = 1e8,
    cv = 1e-8,
    hv = 2 * Math.PI,
    uv = hv / 4,
    dv = 0,
    pv = Math.sqrt,
    fv = Math.cos,
    mv = Math.sin,
    gv = (t) => "string" == typeof t,
    _v = (t) => "function" == typeof t,
    vv = (t) => "number" == typeof t,
    yv = (t) => void 0 === t,
    xv = (t) => "object" == typeof t,
    Tv = (t) => !1 !== t,
    Mv = () => "undefined" != typeof window,
    Sv = (t) => _v(t) || gv(t),
    bv =
      ("function" == typeof ArrayBuffer && ArrayBuffer.isView) ||
      function () {},
    Ev = Array.isArray,
    wv = /(?:-?\.?\d|\.)+/gi,
    Av = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    Rv = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    Cv = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    Pv = /[+-]=-?[.\d]+/,
    Lv = /[^,'"\[\]\s]+/gi,
    Dv = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
    Iv = {},
    Uv = {},
    Nv = (t) => (Uv = hy(t, Iv)) && dT,
    Ov = (t, e) =>
      console.warn(
        "Invalid property",
        t,
        "set to",
        e,
        "Missing plugin? gsap.registerPlugin()"
      ),
    Fv = (t, e) => !e && console.warn(t),
    kv = (t, e) => (t && (Iv[t] = e) && Uv && (Uv[t] = e)) || Iv,
    zv = () => 0,
    Bv = { suppressEvents: !0, isStart: !0, kill: !1 },
    Hv = { suppressEvents: !0, kill: !1 },
    Gv = { suppressEvents: !0 },
    Vv = {},
    Wv = [],
    Xv = {},
    jv = {},
    qv = {},
    Yv = 30,
    Kv = [],
    Zv = "",
    Jv = (t) => {
      let e,
        n,
        i = t[0];
      if ((xv(i) || _v(i) || (t = [t]), !(e = (i._gsap || {}).harness))) {
        for (n = Kv.length; n-- && !Kv[n].targetTest(i); );
        e = Kv[n];
      }
      for (n = t.length; n--; )
        (t[n] && (t[n]._gsap || (t[n]._gsap = new wx(t[n], e)))) ||
          t.splice(n, 1);
      return t;
    },
    Qv = (t) => t._gsap || Jv(Hy(t))[0]._gsap,
    $v = (t, e, n) =>
      (n = t[e]) && _v(n)
        ? t[e]()
        : (yv(n) && t.getAttribute && t.getAttribute(e)) || n,
    ty = (t, e) => (t = t.split(",")).forEach(e) || t,
    ey = (t) => Math.round(1e5 * t) / 1e5 || 0,
    ny = (t) => Math.round(1e7 * t) / 1e7 || 0,
    iy = (t, e) => {
      let n = e.charAt(0),
        i = parseFloat(e.substr(2));
      return (
        (t = parseFloat(t)),
        "+" === n ? t + i : "-" === n ? t - i : "*" === n ? t * i : t / i
      );
    },
    ry = (t, e) => {
      let n = e.length,
        i = 0;
      for (; t.indexOf(e[i]) < 0 && ++i < n; );
      return i < n;
    },
    sy = () => {
      let t,
        e,
        n = Wv.length,
        i = Wv.slice(0);
      for (Xv = {}, Wv.length = 0, t = 0; t < n; t++)
        (e = i[t]),
          e && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0);
    },
    ay = (t, e, n, i) => {
      Wv.length && !Z_ && sy(),
        t.render(e, n, i || (Z_ && e < 0 && (t._initted || t._startAt))),
        Wv.length && !Z_ && sy();
    },
    oy = (t) => {
      let e = parseFloat(t);
      return (e || 0 === e) && (t + "").match(Lv).length < 2
        ? e
        : gv(t)
        ? t.trim()
        : t;
    },
    ly = (t) => t,
    cy = (t, e) => {
      for (let n in e) n in t || (t[n] = e[n]);
      return t;
    },
    hy = (t, e) => {
      for (let n in e) t[n] = e[n];
      return t;
    },
    uy = (t, e) => {
      for (let n in e)
        "__proto__" !== n &&
          "constructor" !== n &&
          "prototype" !== n &&
          (t[n] = xv(e[n]) ? uy(t[n] || (t[n] = {}), e[n]) : e[n]);
      return t;
    },
    dy = (t, e) => {
      let n,
        i = {};
      for (n in t) n in e || (i[n] = t[n]);
      return i;
    },
    py = (t) => {
      let e = t.parent || Q_,
        n = t.keyframes
          ? ((i = Ev(t.keyframes)),
            (t, e) => {
              for (let n in e)
                n in t ||
                  ("duration" === n && i) ||
                  "ease" === n ||
                  (t[n] = e[n]);
            })
          : cy;
      var i;
      if (Tv(t.inherit))
        for (; e; ) n(t, e.vars.defaults), (e = e.parent || e._dp);
      return t;
    },
    fy = (t, e, n = "_first", i = "_last", r) => {
      let s,
        a = t[i];
      if (r) for (s = e[r]; a && a[r] > s; ) a = a._prev;
      return (
        a
          ? ((e._next = a._next), (a._next = e))
          : ((e._next = t[n]), (t[n] = e)),
        e._next ? (e._next._prev = e) : (t[i] = e),
        (e._prev = a),
        (e.parent = e._dp = t),
        e
      );
    },
    my = (t, e, n = "_first", i = "_last") => {
      let r = e._prev,
        s = e._next;
      r ? (r._next = s) : t[n] === e && (t[n] = s),
        s ? (s._prev = r) : t[i] === e && (t[i] = r),
        (e._next = e._prev = e.parent = null);
    },
    gy = (t, e) => {
      t.parent &&
        (!e || t.parent.autoRemoveChildren) &&
        t.parent.remove &&
        t.parent.remove(t),
        (t._act = 0);
    },
    _y = (t, e) => {
      if (t && (!e || e._end > t._dur || e._start < 0)) {
        let e = t;
        for (; e; ) (e._dirty = 1), (e = e.parent);
      }
      return t;
    },
    vy = (t, e, n, i) =>
      t._startAt &&
      (Z_
        ? t._startAt.revert(Hv)
        : (t.vars.immediateRender && !t.vars.autoRevert) ||
          t._startAt.render(e, !0, i)),
    yy = (t) => !t || (t._ts && yy(t.parent)),
    xy = (t) =>
      t._repeat ? Ty(t._tTime, (t = t.duration() + t._rDelay)) * t : 0,
    Ty = (t, e) => {
      let n = Math.floor((t /= e));
      return t && n === t ? n - 1 : n;
    },
    My = (t, e) =>
      (t - e._start) * e._ts +
      (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur),
    Sy = (t) =>
      (t._end = ny(
        t._start + (t._tDur / Math.abs(t._ts || t._rts || cv) || 0)
      )),
    by = (t, e) => {
      let n = t._dp;
      return (
        n &&
          n.smoothChildTiming &&
          t._ts &&
          ((t._start = ny(
            n._time -
              (t._ts > 0
                ? e / t._ts
                : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)
          )),
          Sy(t),
          n._dirty || _y(n, t)),
        t
      );
    },
    Ey = (t, e) => {
      let n;
      if (
        ((e._time ||
          (!e._dur && e._initted) ||
          (e._start < t._time && (e._dur || !e.add))) &&
          ((n = My(t.rawTime(), e)),
          (!e._dur || Fy(0, e.totalDuration(), n) - e._tTime > cv) &&
            e.render(n, !0)),
        _y(t, e)._dp && t._initted && t._time >= t._dur && t._ts)
      ) {
        if (t._dur < t.duration())
          for (n = t; n._dp; )
            n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
        t._zTime = -1e-8;
      }
    },
    wy = (t, e, n, i) => (
      e.parent && gy(e),
      (e._start = ny(
        (vv(n) ? n : n || t !== Q_ ? Uy(t, n, e) : t._time) + e._delay
      )),
      (e._end = ny(
        e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)
      )),
      fy(t, e, "_first", "_last", t._sort ? "_start" : 0),
      Py(e) || (t._recent = e),
      i || Ey(t, e),
      t._ts < 0 && by(t, t._tTime),
      t
    ),
    Ay = (t, e) =>
      (Iv.ScrollTrigger || Ov("scrollTrigger", e)) &&
      Iv.ScrollTrigger.create(e, t),
    Ry = (t, e, n, i, r) => (
      Ux(t, e, r),
      t._initted
        ? !n &&
          t._pt &&
          !Z_ &&
          ((t._dur && !1 !== t.vars.lazy) || (!t._dur && t.vars.lazy)) &&
          iv !== px.frame
          ? (Wv.push(t), (t._lazy = [r, i]), 1)
          : void 0
        : 1
    ),
    Cy = ({ parent: t }) =>
      t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || Cy(t)),
    Py = ({ data: t }) => "isFromStart" === t || "isStart" === t,
    Ly = (t, e, n, i) => {
      let r = t._repeat,
        s = ny(e) || 0,
        a = t._tTime / t._tDur;
      return (
        a && !i && (t._time *= s / t._dur),
        (t._dur = s),
        (t._tDur = r ? (r < 0 ? 1e10 : ny(s * (r + 1) + t._rDelay * r)) : s),
        a > 0 && !i && by(t, (t._tTime = t._tDur * a)),
        t.parent && Sy(t),
        n || _y(t.parent, t),
        t
      );
    },
    Dy = (t) => (t instanceof Rx ? _y(t) : Ly(t, t._dur)),
    Iy = { _start: 0, endTime: zv, totalDuration: zv },
    Uy = (t, e, n) => {
      let i,
        r,
        s,
        a = t.labels,
        o = t._recent || Iy,
        l = t.duration() >= lv ? o.endTime(!1) : t._dur;
      return gv(e) && (isNaN(e) || e in a)
        ? ((r = e.charAt(0)),
          (s = "%" === e.substr(-1)),
          (i = e.indexOf("=")),
          "<" === r || ">" === r
            ? (i >= 0 && (e = e.replace(/=/, "")),
              ("<" === r ? o._start : o.endTime(o._repeat >= 0)) +
                (parseFloat(e.substr(1)) || 0) *
                  (s ? (i < 0 ? o : n).totalDuration() / 100 : 1))
            : i < 0
            ? (e in a || (a[e] = l), a[e])
            : ((r = parseFloat(e.charAt(i - 1) + e.substr(i + 1))),
              s && n && (r = (r / 100) * (Ev(n) ? n[0] : n).totalDuration()),
              i > 1 ? Uy(t, e.substr(0, i - 1), n) + r : l + r))
        : null == e
        ? l
        : +e;
    },
    Ny = (t, e, n) => {
      let i,
        r,
        s = vv(e[1]),
        a = (s ? 2 : 1) + (t < 2 ? 0 : 1),
        o = e[a];
      if ((s && (o.duration = e[1]), (o.parent = n), t)) {
        for (i = o, r = n; r && !("immediateRender" in i); )
          (i = r.vars.defaults || {}), (r = Tv(r.vars.inherit) && r.parent);
        (o.immediateRender = Tv(i.immediateRender)),
          t < 2 ? (o.runBackwards = 1) : (o.startAt = e[a - 1]);
      }
      return new zx(e[0], o, e[a + 1]);
    },
    Oy = (t, e) => (t || 0 === t ? e(t) : e),
    Fy = (t, e, n) => (n < t ? t : n > e ? e : n),
    ky = (t, e) => (gv(t) && (e = Dv.exec(t)) ? e[1] : ""),
    zy = [].slice,
    By = (t, e) =>
      t &&
      xv(t) &&
      "length" in t &&
      ((!e && !t.length) || (t.length - 1 in t && xv(t[0]))) &&
      !t.nodeType &&
      t !== $_,
    Hy = (t, e, n) =>
      J_ && !e && J_.selector
        ? J_.selector(t)
        : !gv(t) || n || (!tv && fx())
        ? Ev(t)
          ? ((t, e, n = []) =>
              t.forEach((t) =>
                (gv(t) && !e) || By(t, 1) ? n.push(...Hy(t)) : n.push(t)
              ) || n)(t, n)
          : By(t)
          ? zy.call(t, 0)
          : t
          ? [t]
          : []
        : zy.call((e || ev).querySelectorAll(t), 0),
    Gy = (t) => (
      (t = Hy(t)[0] || Fv("Invalid scope") || {}),
      (e) => {
        let n = t.current || t.nativeElement || t;
        return Hy(
          e,
          n.querySelectorAll
            ? n
            : n === t
            ? Fv("Invalid scope") || ev.createElement("div")
            : t
        );
      }
    ),
    Vy = (t) => t.sort(() => 0.5 - Math.random()),
    Wy = (t) => {
      if (_v(t)) return t;
      let e = xv(t) ? t : { each: t },
        n = Tx(e.ease),
        i = e.from || 0,
        r = parseFloat(e.base) || 0,
        s = {},
        a = i > 0 && i < 1,
        o = isNaN(i) || a,
        l = e.axis,
        c = i,
        h = i;
      return (
        gv(i)
          ? (c = h = { center: 0.5, edges: 0.5, end: 1 }[i] || 0)
          : !a && o && ((c = i[0]), (h = i[1])),
        (t, a, u) => {
          let d,
            p,
            f,
            m,
            g,
            _,
            v,
            y,
            x,
            T = (u || e).length,
            M = s[T];
          if (!M) {
            if (((x = "auto" === e.grid ? 0 : (e.grid || [1, lv])[1]), !x)) {
              for (
                v = -1e8;
                v < (v = u[x++].getBoundingClientRect().left) && x < T;

              );
              x < T && x--;
            }
            for (
              M = s[T] = [],
                d = o ? Math.min(x, T) * c - 0.5 : i % x,
                p = x === lv ? 0 : o ? (T * h) / x - 0.5 : (i / x) | 0,
                v = 0,
                y = lv,
                _ = 0;
              _ < T;
              _++
            )
              (f = (_ % x) - d),
                (m = p - ((_ / x) | 0)),
                (M[_] = g =
                  l ? Math.abs("y" === l ? m : f) : pv(f * f + m * m)),
                g > v && (v = g),
                g < y && (y = g);
            "random" === i && Vy(M),
              (M.max = v - y),
              (M.min = y),
              (M.v = T =
                (parseFloat(e.amount) ||
                  parseFloat(e.each) *
                    (x > T
                      ? T - 1
                      : l
                      ? "y" === l
                        ? T / x
                        : x
                      : Math.max(x, T / x)) ||
                  0) * ("edges" === i ? -1 : 1)),
              (M.b = T < 0 ? r - T : r),
              (M.u = ky(e.amount || e.each) || 0),
              (n = n && T < 0 ? yx(n) : n);
          }
          return (
            (T = (M[t] - M.min) / M.max || 0),
            ny(M.b + (n ? n(T) : T) * M.v) + M.u
          );
        }
      );
    },
    Xy = (t) => {
      let e = Math.pow(10, ((t + "").split(".")[1] || "").length);
      return (n) => {
        let i = ny(Math.round(parseFloat(n) / t) * t * e);
        return (i - (i % 1)) / e + (vv(n) ? 0 : ky(n));
      };
    },
    jy = (t, e) => {
      let n,
        i,
        r = Ev(t);
      return (
        !r &&
          xv(t) &&
          ((n = r = t.radius || lv),
          t.values
            ? ((t = Hy(t.values)), (i = !vv(t[0])) && (n *= n))
            : (t = Xy(t.increment))),
        Oy(
          e,
          r
            ? _v(t)
              ? (e) => ((i = t(e)), Math.abs(i - e) <= n ? i : e)
              : (e) => {
                  let r,
                    s,
                    a = parseFloat(i ? e.x : e),
                    o = parseFloat(i ? e.y : 0),
                    l = lv,
                    c = 0,
                    h = t.length;
                  for (; h--; )
                    i
                      ? ((r = t[h].x - a),
                        (s = t[h].y - o),
                        (r = r * r + s * s))
                      : (r = Math.abs(t[h] - a)),
                      r < l && ((l = r), (c = h));
                  return (
                    (c = !n || l <= n ? t[c] : e),
                    i || c === e || vv(e) ? c : c + ky(e)
                  );
                }
            : Xy(t)
        )
      );
    },
    qy = (t, e, n, i) =>
      Oy(Ev(t) ? !e : !0 === n ? !!(n = 0) : !i, () =>
        Ev(t)
          ? t[~~(Math.random() * t.length)]
          : (n = n || 1e-5) &&
            (i = n < 1 ? 10 ** ((n + "").length - 2) : 1) &&
            Math.floor(
              Math.round((t - n / 2 + Math.random() * (e - t + 0.99 * n)) / n) *
                n *
                i
            ) / i
      ),
    Yy = (t, e, n) => Oy(n, (n) => t[~~e(n)]),
    Ky = function (t, e, n) {
      let i = e - t;
      return Ev(t)
        ? Yy(t, Ky(0, t.length), e)
        : Oy(n, (e) => ((i + ((e - t) % i)) % i) + t);
    },
    Zy = (t, e, n) => {
      let i = e - t,
        r = 2 * i;
      return Ev(t)
        ? Yy(t, Zy(0, t.length - 1), e)
        : Oy(
            n,
            (e) => t + ((e = (r + ((e - t) % r)) % r || 0) > i ? r - e : e)
          );
    },
    Jy = (t) => {
      let e,
        n,
        i,
        r,
        s = 0,
        a = "";
      for (; ~(e = t.indexOf("random(", s)); )
        (i = t.indexOf(")", e)),
          (r = "[" === t.charAt(e + 7)),
          (n = t.substr(e + 7, i - e - 7).match(r ? Lv : wv)),
          (a +=
            t.substr(s, e - s) +
            qy(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5)),
          (s = i + 1);
      return a + t.substr(s, t.length - s);
    },
    Qy = (t, e, n, i, r) => {
      let s = e - t,
        a = i - n;
      return Oy(r, (e) => n + (((e - t) / s) * a || 0));
    },
    $y = (t, e, n, i) => {
      let r = isNaN(t + e) ? 0 : (n) => (1 - n) * t + n * e;
      if (!r) {
        let s,
          a,
          o,
          l,
          c,
          h = gv(t),
          u = {};
        if ((!0 === n && (i = 1) && (n = null), h))
          (t = { p: t }), (e = { p: e });
        else if (Ev(t) && !Ev(e)) {
          for (o = [], l = t.length, c = l - 2, a = 1; a < l; a++)
            o.push($y(t[a - 1], t[a]));
          l--,
            (r = (t) => {
              t *= l;
              let e = Math.min(c, ~~t);
              return o[e](t - e);
            }),
            (n = e);
        } else i || (t = hy(Ev(t) ? [] : {}, t));
        if (!o) {
          for (s in e) Dx.call(u, t, s, "get", e[s]);
          r = (e) => Yx(e, u) || (h ? t.p : t);
        }
      }
      return Oy(n, r);
    },
    tx = (t, e, n) => {
      let i,
        r,
        s,
        a = t.labels,
        o = lv;
      for (i in a)
        (r = a[i] - e),
          r < 0 == !!n && r && o > (r = Math.abs(r)) && ((s = i), (o = r));
      return s;
    },
    ex = (t, e, n) => {
      let i,
        r,
        s,
        a = t.vars,
        o = a[e],
        l = J_,
        c = t._ctx;
      if (o)
        return (
          (i = a[e + "Params"]),
          (r = a.callbackScope || t),
          n && Wv.length && sy(),
          c && (J_ = c),
          (s = i ? o.apply(r, i) : o.call(r)),
          (J_ = l),
          s
        );
    },
    nx = (t) => (
      gy(t),
      t.scrollTrigger && t.scrollTrigger.kill(!!Z_),
      t.progress() < 1 && ex(t, "onInterrupt"),
      t
    ),
    ix = [],
    rx = (t) => {
      if (Mv() && t) {
        let e = (t = (!t.name && t.default) || t).name,
          n = _v(t),
          i =
            e && !n && t.init
              ? function () {
                  this._props = [];
                }
              : t,
          r = {
            init: zv,
            render: Yx,
            add: Dx,
            kill: Zx,
            modifier: Kx,
            rawVars: 0,
          },
          s = {
            targetTest: 0,
            get: 0,
            getSetter: Wx,
            aliases: {},
            register: 0,
          };
        if ((fx(), t !== i)) {
          if (jv[e]) return;
          cy(i, cy(dy(t, r), s)),
            hy(i.prototype, hy(r, dy(t, s))),
            (jv[(i.prop = e)] = i),
            t.targetTest && (Kv.push(i), (Vv[e] = 1)),
            (e =
              ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) +
              "Plugin");
        }
        kv(e, i), t.register && t.register(dT, i, $x);
      } else t && ix.push(t);
    },
    sx = 255,
    ax = {
      aqua: [0, sx, sx],
      lime: [0, sx, 0],
      silver: [192, 192, 192],
      black: [0, 0, 0],
      maroon: [128, 0, 0],
      teal: [0, 128, 128],
      blue: [0, 0, sx],
      navy: [0, 0, 128],
      white: [sx, sx, sx],
      olive: [128, 128, 0],
      yellow: [sx, sx, 0],
      orange: [sx, 165, 0],
      gray: [128, 128, 128],
      purple: [128, 0, 128],
      green: [0, 128, 0],
      red: [sx, 0, 0],
      pink: [sx, 192, 203],
      cyan: [0, sx, sx],
      transparent: [sx, sx, sx, 0],
    },
    ox = (t, e, n) =>
      ((6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1
        ? e + (n - e) * t * 6
        : t < 0.5
        ? n
        : 3 * t < 2
        ? e + (n - e) * (2 / 3 - t) * 6
        : e) *
        sx +
        0.5) |
      0,
    lx = (t, e, n) => {
      let i,
        r,
        s,
        a,
        o,
        l,
        c,
        h,
        u,
        d,
        p = t ? (vv(t) ? [t >> 16, (t >> 8) & sx, t & sx] : 0) : ax.black;
      if (!p) {
        if (("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), ax[t]))
          p = ax[t];
        else if ("#" === t.charAt(0)) {
          if (
            (t.length < 6 &&
              ((i = t.charAt(1)),
              (r = t.charAt(2)),
              (s = t.charAt(3)),
              (t =
                "#" +
                i +
                i +
                r +
                r +
                s +
                s +
                (5 === t.length ? t.charAt(4) + t.charAt(4) : ""))),
            9 === t.length)
          )
            return (
              (p = parseInt(t.substr(1, 6), 16)),
              [p >> 16, (p >> 8) & sx, p & sx, parseInt(t.substr(7), 16) / 255]
            );
          p = [(t = parseInt(t.substr(1), 16)) >> 16, (t >> 8) & sx, t & sx];
        } else if ("hsl" === t.substr(0, 3))
          if (((p = d = t.match(wv)), e)) {
            if (~t.indexOf("="))
              return (p = t.match(Av)), n && p.length < 4 && (p[3] = 1), p;
          } else
            (a = (+p[0] % 360) / 360),
              (o = +p[1] / 100),
              (l = +p[2] / 100),
              (r = l <= 0.5 ? l * (o + 1) : l + o - l * o),
              (i = 2 * l - r),
              p.length > 3 && (p[3] *= 1),
              (p[0] = ox(a + 1 / 3, i, r)),
              (p[1] = ox(a, i, r)),
              (p[2] = ox(a - 1 / 3, i, r));
        else p = t.match(wv) || ax.transparent;
        p = p.map(Number);
      }
      return (
        e &&
          !d &&
          ((i = p[0] / sx),
          (r = p[1] / sx),
          (s = p[2] / sx),
          (c = Math.max(i, r, s)),
          (h = Math.min(i, r, s)),
          (l = (c + h) / 2),
          c === h
            ? (a = o = 0)
            : ((u = c - h),
              (o = l > 0.5 ? u / (2 - c - h) : u / (c + h)),
              (a =
                c === i
                  ? (r - s) / u + (r < s ? 6 : 0)
                  : c === r
                  ? (s - i) / u + 2
                  : (i - r) / u + 4),
              (a *= 60)),
          (p[0] = ~~(a + 0.5)),
          (p[1] = ~~(100 * o + 0.5)),
          (p[2] = ~~(100 * l + 0.5))),
        n && p.length < 4 && (p[3] = 1),
        p
      );
    },
    cx = (t) => {
      let e = [],
        n = [],
        i = -1;
      return (
        t.split(ux).forEach((t) => {
          let r = t.match(Rv) || [];
          e.push(...r), n.push((i += r.length + 1));
        }),
        (e.c = n),
        e
      );
    },
    hx = (t, e, n) => {
      let i,
        r,
        s,
        a,
        o = "",
        l = (t + o).match(ux),
        c = e ? "hsla(" : "rgba(",
        h = 0;
      if (!l) return t;
      if (
        ((l = l.map(
          (t) =>
            (t = lx(t, e, 1)) &&
            c +
              (e
                ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3]
                : t.join(",")) +
              ")"
        )),
        n && ((s = cx(t)), (i = n.c), i.join(o) !== s.c.join(o)))
      )
        for (r = t.replace(ux, "1").split(Rv), a = r.length - 1; h < a; h++)
          o +=
            r[h] +
            (~i.indexOf(h)
              ? l.shift() || c + "0,0,0,0)"
              : (s.length ? s : l.length ? l : n).shift());
      if (!r)
        for (r = t.split(ux), a = r.length - 1; h < a; h++) o += r[h] + l[h];
      return o + r[a];
    },
    ux = (function () {
      let t,
        e =
          "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
      for (t in ax) e += "|" + t + "\\b";
      return new RegExp(e + ")", "gi");
    })(),
    dx = /hsl[a]?\(/,
    px = (function () {
      let t,
        e,
        n,
        i,
        r,
        s,
        a = Date.now,
        o = 500,
        l = 33,
        c = a(),
        h = c,
        u = 1e3 / 240,
        d = u,
        p = [],
        f = (n) => {
          let m,
            g,
            _,
            v,
            y = a() - h,
            x = !0 === n;
          if (
            (y > o && (c += y - l),
            (h += y),
            (_ = h - c),
            (m = _ - d),
            (m > 0 || x) &&
              ((v = ++i.frame),
              (r = _ - 1e3 * i.time),
              (i.time = _ /= 1e3),
              (d += m + (m >= u ? 4 : u - m)),
              (g = 1)),
            x || (t = e(f)),
            g)
          )
            for (s = 0; s < p.length; s++) p[s](_, r, v, n);
        };
      return (
        (i = {
          time: 0,
          frame: 0,
          tick() {
            f(!0);
          },
          deltaRatio: (t) => r / (1e3 / (t || 60)),
          wake() {
            nv &&
              (!tv &&
                Mv() &&
                (($_ = tv = window),
                (ev = $_.document || {}),
                (Iv.gsap = dT),
                ($_.gsapVersions || ($_.gsapVersions = [])).push(dT.version),
                Nv(Uv || $_.GreenSockGlobals || (!$_.gsap && $_) || {}),
                (n = $_.requestAnimationFrame),
                ix.forEach(rx)),
              t && i.sleep(),
              (e = n || ((t) => setTimeout(t, (d - 1e3 * i.time + 1) | 0))),
              (sv = 1),
              f(2));
          },
          sleep() {
            (n ? $_.cancelAnimationFrame : clearTimeout)(t), (sv = 0), (e = zv);
          },
          lagSmoothing(t, e) {
            (o = t || 1 / 0), (l = Math.min(e || 33, o));
          },
          fps(t) {
            (u = 1e3 / (t || 240)), (d = 1e3 * i.time + u);
          },
          add(t, e, n) {
            let r = e
              ? (e, n, s, a) => {
                  t(e, n, s, a), i.remove(r);
                }
              : t;
            return i.remove(t), p[n ? "unshift" : "push"](r), fx(), r;
          },
          remove(t, e) {
            ~(e = p.indexOf(t)) && p.splice(e, 1) && s >= e && s--;
          },
          _listeners: p,
        }),
        i
      );
    })(),
    fx = () => !sv && px.wake(),
    mx = {},
    gx = /^[\d.\-M][\d.\-,\s]/,
    _x = /["']/g,
    vx = (t) => {
      let e,
        n,
        i,
        r = {},
        s = t.substr(1, t.length - 3).split(":"),
        a = s[0],
        o = 1,
        l = s.length;
      for (; o < l; o++)
        (n = s[o]),
          (e = o !== l - 1 ? n.lastIndexOf(",") : n.length),
          (i = n.substr(0, e)),
          (r[a] = isNaN(i) ? i.replace(_x, "").trim() : +i),
          (a = n.substr(e + 1).trim());
      return r;
    },
    yx = (t) => (e) => 1 - t(1 - e),
    xx = (t, e) => {
      let n,
        i = t._first;
      for (; i; )
        i instanceof Rx
          ? xx(i, e)
          : !i.vars.yoyoEase ||
            (i._yoyo && i._repeat) ||
            i._yoyo === e ||
            (i.timeline
              ? xx(i.timeline, e)
              : ((n = i._ease),
                (i._ease = i._yEase),
                (i._yEase = n),
                (i._yoyo = e))),
          (i = i._next);
    },
    Tx = (t, e) =>
      (t &&
        (_v(t)
          ? t
          : mx[t] ||
            ((t) => {
              let e = (t + "").split("("),
                n = mx[e[0]];
              return n && e.length > 1 && n.config
                ? n.config.apply(
                    null,
                    ~t.indexOf("{")
                      ? [vx(e[1])]
                      : ((t) => {
                          let e = t.indexOf("(") + 1,
                            n = t.indexOf(")"),
                            i = t.indexOf("(", e);
                          return t.substring(
                            e,
                            ~i && i < n ? t.indexOf(")", n + 1) : n
                          );
                        })(t)
                          .split(",")
                          .map(oy)
                  )
                : mx._CE && gx.test(t)
                ? mx._CE("", t)
                : n;
            })(t))) ||
      e,
    Mx = (
      t,
      e,
      n = (t) => 1 - e(1 - t),
      i = (t) => (t < 0.5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2)
    ) => {
      let r,
        s = { easeIn: e, easeOut: n, easeInOut: i };
      return (
        ty(t, (t) => {
          (mx[t] = Iv[t] = s), (mx[(r = t.toLowerCase())] = n);
          for (let e in s)
            mx[
              r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")
            ] = mx[t + "." + e] = s[e];
        }),
        s
      );
    },
    Sx = (t) => (e) =>
      e < 0.5 ? (1 - t(1 - 2 * e)) / 2 : 0.5 + t(2 * (e - 0.5)) / 2,
    bx = (t, e, n) => {
      let i = e >= 1 ? e : 1,
        r = (n || (t ? 0.3 : 0.45)) / (e < 1 ? e : 1),
        s = (r / hv) * (Math.asin(1 / i) || 0),
        a = (t) => (1 === t ? 1 : i * 2 ** (-10 * t) * mv((t - s) * r) + 1),
        o = "out" === t ? a : "in" === t ? (t) => 1 - a(1 - t) : Sx(a);
      return (r = hv / r), (o.config = (e, n) => bx(t, e, n)), o;
    },
    Ex = (t, e = 1.70158) => {
      let n = (t) => (t ? --t * t * ((e + 1) * t + e) + 1 : 0),
        i = "out" === t ? n : "in" === t ? (t) => 1 - n(1 - t) : Sx(n);
      return (i.config = (e) => Ex(t, e)), i;
    };
  ty("Linear,Quad,Cubic,Quart,Quint,Strong", (t, e) => {
    let n = e < 5 ? e + 1 : e;
    Mx(
      t + ",Power" + (n - 1),
      e ? (t) => t ** n : (t) => t,
      (t) => 1 - (1 - t) ** n,
      (t) => (t < 0.5 ? (2 * t) ** n / 2 : 1 - (2 * (1 - t)) ** n / 2)
    );
  }),
    (mx.Linear.easeNone = mx.none = mx.Linear.easeIn),
    Mx("Elastic", bx("in"), bx("out"), bx()),
    ((t, e) => {
      let n = (n) =>
        n < 0.36363636363636365
          ? t * n * n
          : n < 0.7272727272727273
          ? t * (n - 1.5 / e) ** 2 + 0.75
          : n < 0.9090909090909092
          ? t * (n -= 2.25 / e) * n + 0.9375
          : t * (n - 2.625 / e) ** 2 + 0.984375;
      Mx("Bounce", (t) => 1 - n(1 - t), n);
    })(7.5625, 2.75),
    Mx("Expo", (t) => (t ? 2 ** (10 * (t - 1)) : 0)),
    Mx("Circ", (t) => -(pv(1 - t * t) - 1)),
    Mx("Sine", (t) => (1 === t ? 1 : 1 - fv(t * uv))),
    Mx("Back", Ex("in"), Ex("out"), Ex()),
    (mx.SteppedEase =
      mx.steps =
      Iv.SteppedEase =
        {
          config(t = 1, e) {
            let n = 1 / t,
              i = t + (e ? 0 : 1),
              r = e ? 1 : 0;
            return (t) => (((i * Fy(0, 0.99999999, t)) | 0) + r) * n;
          },
        }),
    (ov.ease = mx["quad.out"]),
    ty(
      "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
      (t) => (Zv += t + "," + t + "Params,")
    );
  class wx {
    constructor(t, e) {
      (this.id = dv++),
        (t._gsap = this),
        (this.target = t),
        (this.harness = e),
        (this.get = e ? e.get : $v),
        (this.set = e ? e.getSetter : Wx);
    }
  }
  class Ax {
    constructor(t) {
      (this.vars = t),
        (this._delay = +t.delay || 0),
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
          ((this._rDelay = t.repeatDelay || 0),
          (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
        (this._ts = 1),
        Ly(this, +t.duration, 1, 1),
        (this.data = t.data),
        J_ && ((this._ctx = J_), J_.data.push(this)),
        sv || px.wake();
    }
    delay(t) {
      return t || 0 === t
        ? (this.parent &&
            this.parent.smoothChildTiming &&
            this.startTime(this._start + t - this._delay),
          (this._delay = t),
          this)
        : this._delay;
    }
    duration(t) {
      return arguments.length
        ? this.totalDuration(
            this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t
          )
        : this.totalDuration() && this._dur;
    }
    totalDuration(t) {
      return arguments.length
        ? ((this._dirty = 0),
          Ly(
            this,
            this._repeat < 0
              ? t
              : (t - this._repeat * this._rDelay) / (this._repeat + 1)
          ))
        : this._tDur;
    }
    totalTime(t, e) {
      if ((fx(), !arguments.length)) return this._tTime;
      let n = this._dp;
      if (n && n.smoothChildTiming && this._ts) {
        for (by(this, t), !n._dp || n.parent || Ey(n, this); n && n.parent; )
          n.parent._time !==
            n._start +
              (n._ts >= 0
                ? n._tTime / n._ts
                : (n.totalDuration() - n._tTime) / -n._ts) &&
            n.totalTime(n._tTime, !0),
            (n = n.parent);
        !this.parent &&
          this._dp.autoRemoveChildren &&
          ((this._ts > 0 && t < this._tDur) ||
            (this._ts < 0 && t > 0) ||
            (!this._tDur && !t)) &&
          wy(this._dp, this, this._start - this._delay);
      }
      return (
        (this._tTime !== t ||
          (!this._dur && !e) ||
          (this._initted && Math.abs(this._zTime) === cv) ||
          (!t && !this._initted && (this.add || this._ptLookup))) &&
          (this._ts || (this._pTime = t), ay(this, t, e)),
        this
      );
    }
    time(t, e) {
      return arguments.length
        ? this.totalTime(
            Math.min(this.totalDuration(), t + xy(this)) %
              (this._dur + this._rDelay) || (t ? this._dur : 0),
            e
          )
        : this._time;
    }
    totalProgress(t, e) {
      return arguments.length
        ? this.totalTime(this.totalDuration() * t, e)
        : this.totalDuration()
        ? Math.min(1, this._tTime / this._tDur)
        : this.rawTime() > 0
        ? 1
        : 0;
    }
    progress(t, e) {
      return arguments.length
        ? this.totalTime(
            this.duration() *
              (!this._yoyo || 1 & this.iteration() ? t : 1 - t) +
              xy(this),
            e
          )
        : this.duration()
        ? Math.min(1, this._time / this._dur)
        : this.rawTime() > 0
        ? 1
        : 0;
    }
    iteration(t, e) {
      let n = this.duration() + this._rDelay;
      return arguments.length
        ? this.totalTime(this._time + (t - 1) * n, e)
        : this._repeat
        ? Ty(this._tTime, n) + 1
        : 1;
    }
    timeScale(t, e) {
      if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
      if (this._rts === t) return this;
      let n =
        this.parent && this._ts ? My(this.parent._time, this) : this._tTime;
      return (
        (this._rts = +t || 0),
        (this._ts = this._ps || -1e-8 === t ? 0 : this._rts),
        this.totalTime(Fy(-Math.abs(this._delay), this._tDur, n), !1 !== e),
        Sy(this),
        ((t) => {
          let e = t.parent;
          for (; e && e.parent; )
            (e._dirty = 1), e.totalDuration(), (e = e.parent);
          return t;
        })(this)
      );
    }
    paused(t) {
      return arguments.length
        ? (this._ps !== t &&
            ((this._ps = t),
            t
              ? ((this._pTime =
                  this._tTime || Math.max(-this._delay, this.rawTime())),
                (this._ts = this._act = 0))
              : (fx(),
                (this._ts = this._rts),
                this.totalTime(
                  this.parent && !this.parent.smoothChildTiming
                    ? this.rawTime()
                    : this._tTime || this._pTime,
                  1 === this.progress() &&
                    Math.abs(this._zTime) !== cv &&
                    (this._tTime -= cv)
                ))),
          this)
        : this._ps;
    }
    startTime(t) {
      if (arguments.length) {
        this._start = t;
        let e = this.parent || this._dp;
        return (
          e && (e._sort || !this.parent) && wy(e, this, t - this._delay), this
        );
      }
      return this._start;
    }
    endTime(t) {
      return (
        this._start +
        (Tv(t) ? this.totalDuration() : this.duration()) /
          Math.abs(this._ts || 1)
      );
    }
    rawTime(t) {
      let e = this.parent || this._dp;
      return e
        ? t &&
          (!this._ts ||
            (this._repeat && this._time && this.totalProgress() < 1))
          ? this._tTime % (this._dur + this._rDelay)
          : this._ts
          ? My(e.rawTime(t), this)
          : this._tTime
        : this._tTime;
    }
    revert(t = Gv) {
      let e = Z_;
      return (
        (Z_ = t),
        (this._initted || this._startAt) &&
          (this.timeline && this.timeline.revert(t),
          this.totalTime(-0.01, t.suppressEvents)),
        "nested" !== this.data && !1 !== t.kill && this.kill(),
        (Z_ = e),
        this
      );
    }
    globalTime(t) {
      let e = this,
        n = arguments.length ? t : e.rawTime();
      for (; e; ) (n = e._start + n / (Math.abs(e._ts) || 1)), (e = e._dp);
      return !this.parent && this._sat ? this._sat.globalTime(t) : n;
    }
    repeat(t) {
      return arguments.length
        ? ((this._repeat = t === 1 / 0 ? -2 : t), Dy(this))
        : -2 === this._repeat
        ? 1 / 0
        : this._repeat;
    }
    repeatDelay(t) {
      if (arguments.length) {
        let e = this._time;
        return (this._rDelay = t), Dy(this), e ? this.time(e) : this;
      }
      return this._rDelay;
    }
    yoyo(t) {
      return arguments.length ? ((this._yoyo = t), this) : this._yoyo;
    }
    seek(t, e) {
      return this.totalTime(Uy(this, t), Tv(e));
    }
    restart(t, e) {
      return this.play().totalTime(t ? -this._delay : 0, Tv(e));
    }
    play(t, e) {
      return null != t && this.seek(t, e), this.reversed(!1).paused(!1);
    }
    reverse(t, e) {
      return (
        null != t && this.seek(t || this.totalDuration(), e),
        this.reversed(!0).paused(!1)
      );
    }
    pause(t, e) {
      return null != t && this.seek(t, e), this.paused(!0);
    }
    resume() {
      return this.paused(!1);
    }
    reversed(t) {
      return arguments.length
        ? (!!t !== this.reversed() &&
            this.timeScale(-this._rts || (t ? -1e-8 : 0)),
          this)
        : this._rts < 0;
    }
    invalidate() {
      return (this._initted = this._act = 0), (this._zTime = -1e-8), this;
    }
    isActive() {
      let t,
        e = this.parent || this._dp,
        n = this._start;
      return !(
        e &&
        !(
          this._ts &&
          this._initted &&
          e.isActive() &&
          (t = e.rawTime(!0)) >= n &&
          t < this.endTime(!0) - cv
        )
      );
    }
    eventCallback(t, e, n) {
      let i = this.vars;
      return arguments.length > 1
        ? (e
            ? ((i[t] = e),
              n && (i[t + "Params"] = n),
              "onUpdate" === t && (this._onUpdate = e))
            : delete i[t],
          this)
        : i[t];
    }
    then(t) {
      let e = this;
      return new Promise((n) => {
        let i = _v(t) ? t : ly,
          r = () => {
            let t = e.then;
            (e.then = null),
              _v(i) && (i = i(e)) && (i.then || i === e) && (e.then = t),
              n(i),
              (e.then = t);
          };
        (e._initted && 1 === e.totalProgress() && e._ts >= 0) ||
        (!e._tTime && e._ts < 0)
          ? r()
          : (e._prom = r);
      });
    }
    kill() {
      nx(this);
    }
  }
  cy(Ax.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -1e-8,
    _prom: 0,
    _ps: !1,
    _rts: 1,
  });
  class Rx extends Ax {
    constructor(t = {}, e) {
      super(t),
        (this.labels = {}),
        (this.smoothChildTiming = !!t.smoothChildTiming),
        (this.autoRemoveChildren = !!t.autoRemoveChildren),
        (this._sort = Tv(t.sortChildren)),
        Q_ && wy(t.parent || Q_, this, e),
        t.reversed && this.reverse(),
        t.paused && this.paused(!0),
        t.scrollTrigger && Ay(this, t.scrollTrigger);
    }
    to(t, e, n) {
      return Ny(0, arguments, this), this;
    }
    from(t, e, n) {
      return Ny(1, arguments, this), this;
    }
    fromTo(t, e, n, i) {
      return Ny(2, arguments, this), this;
    }
    set(t, e, n) {
      return (
        (e.duration = 0),
        (e.parent = this),
        py(e).repeatDelay || (e.repeat = 0),
        (e.immediateRender = !!e.immediateRender),
        new zx(t, e, Uy(this, n), 1),
        this
      );
    }
    call(t, e, n) {
      return wy(this, zx.delayedCall(0, t, e), n);
    }
    staggerTo(t, e, n, i, r, s, a) {
      return (
        (n.duration = e),
        (n.stagger = n.stagger || i),
        (n.onComplete = s),
        (n.onCompleteParams = a),
        (n.parent = this),
        new zx(t, n, Uy(this, r)),
        this
      );
    }
    staggerFrom(t, e, n, i, r, s, a) {
      return (
        (n.runBackwards = 1),
        (py(n).immediateRender = Tv(n.immediateRender)),
        this.staggerTo(t, e, n, i, r, s, a)
      );
    }
    staggerFromTo(t, e, n, i, r, s, a, o) {
      return (
        (i.startAt = n),
        (py(i).immediateRender = Tv(i.immediateRender)),
        this.staggerTo(t, e, i, r, s, a, o)
      );
    }
    render(t, e, n) {
      let i,
        r,
        s,
        a,
        o,
        l,
        c,
        h,
        u,
        d,
        p,
        f,
        m = this._time,
        g = this._dirty ? this.totalDuration() : this._tDur,
        _ = this._dur,
        v = t <= 0 ? 0 : ny(t),
        y = this._zTime < 0 != t < 0 && (this._initted || !_);
      if (
        (this !== Q_ && v > g && t >= 0 && (v = g), v !== this._tTime || n || y)
      ) {
        if (
          (m !== this._time &&
            _ &&
            ((v += this._time - m), (t += this._time - m)),
          (i = v),
          (u = this._start),
          (h = this._ts),
          (l = !h),
          y && (_ || (m = this._zTime), (t || !e) && (this._zTime = t)),
          this._repeat)
        ) {
          if (
            ((p = this._yoyo),
            (o = _ + this._rDelay),
            this._repeat < -1 && t < 0)
          )
            return this.totalTime(100 * o + t, e, n);
          if (
            ((i = ny(v % o)),
            v === g
              ? ((a = this._repeat), (i = _))
              : ((a = ~~(v / o)),
                a && a === v / o && ((i = _), a--),
                i > _ && (i = _)),
            (d = Ty(this._tTime, o)),
            !m &&
              this._tTime &&
              d !== a &&
              this._tTime - d * o - this._dur <= 0 &&
              (d = a),
            p && 1 & a && ((i = _ - i), (f = 1)),
            a !== d && !this._lock)
          ) {
            let t = p && 1 & d,
              n = t === (p && 1 & a);
            if (
              (a < d && (t = !t),
              (m = t ? 0 : v % _ ? _ : v),
              (this._lock = 1),
              (this.render(m || (f ? 0 : ny(a * o)), e, !_)._lock = 0),
              (this._tTime = v),
              !e && this.parent && ex(this, "onRepeat"),
              this.vars.repeatRefresh && !f && (this.invalidate()._lock = 1),
              (m && m !== this._time) ||
                l !== !this._ts ||
                (this.vars.onRepeat && !this.parent && !this._act))
            )
              return this;
            if (
              ((_ = this._dur),
              (g = this._tDur),
              n &&
                ((this._lock = 2),
                (m = t ? _ : -1e-4),
                this.render(m, !0),
                this.vars.repeatRefresh && !f && this.invalidate()),
              (this._lock = 0),
              !this._ts && !l)
            )
              return this;
            xx(this, f);
          }
        }
        if (
          (this._hasPause &&
            !this._forcing &&
            this._lock < 2 &&
            ((c = ((t, e, n) => {
              let i;
              if (n > e)
                for (i = t._first; i && i._start <= n; ) {
                  if ("isPause" === i.data && i._start > e) return i;
                  i = i._next;
                }
              else
                for (i = t._last; i && i._start >= n; ) {
                  if ("isPause" === i.data && i._start < e) return i;
                  i = i._prev;
                }
            })(this, ny(m), ny(i))),
            c && (v -= i - (i = c._start))),
          (this._tTime = v),
          (this._time = i),
          (this._act = !h),
          this._initted ||
            ((this._onUpdate = this.vars.onUpdate),
            (this._initted = 1),
            (this._zTime = t),
            (m = 0)),
          !m && i && !e && !a && (ex(this, "onStart"), this._tTime !== v))
        )
          return this;
        if (i >= m && t >= 0)
          for (r = this._first; r; ) {
            if (
              ((s = r._next), (r._act || i >= r._start) && r._ts && c !== r)
            ) {
              if (r.parent !== this) return this.render(t, e, n);
              if (
                (r.render(
                  r._ts > 0
                    ? (i - r._start) * r._ts
                    : (r._dirty ? r.totalDuration() : r._tDur) +
                        (i - r._start) * r._ts,
                  e,
                  n
                ),
                i !== this._time || (!this._ts && !l))
              ) {
                (c = 0), s && (v += this._zTime = -1e-8);
                break;
              }
            }
            r = s;
          }
        else {
          r = this._last;
          let a = t < 0 ? t : i;
          for (; r; ) {
            if (((s = r._prev), (r._act || a <= r._end) && r._ts && c !== r)) {
              if (r.parent !== this) return this.render(t, e, n);
              if (
                (r.render(
                  r._ts > 0
                    ? (a - r._start) * r._ts
                    : (r._dirty ? r.totalDuration() : r._tDur) +
                        (a - r._start) * r._ts,
                  e,
                  n || (Z_ && (r._initted || r._startAt))
                ),
                i !== this._time || (!this._ts && !l))
              ) {
                (c = 0), s && (v += this._zTime = a ? -1e-8 : cv);
                break;
              }
            }
            r = s;
          }
        }
        if (
          c &&
          !e &&
          (this.pause(),
          (c.render(i >= m ? 0 : -1e-8)._zTime = i >= m ? 1 : -1),
          this._ts)
        )
          return (this._start = u), Sy(this), this.render(t, e, n);
        this._onUpdate && !e && ex(this, "onUpdate", !0),
          ((v === g && this._tTime >= this.totalDuration()) || (!v && m)) &&
            ((u !== this._start && Math.abs(h) === Math.abs(this._ts)) ||
              this._lock ||
              ((t || !_) &&
                ((v === g && this._ts > 0) || (!v && this._ts < 0)) &&
                gy(this, 1),
              e ||
                (t < 0 && !m) ||
                (!v && !m && g) ||
                (ex(
                  this,
                  v === g && t >= 0 ? "onComplete" : "onReverseComplete",
                  !0
                ),
                this._prom &&
                  !(v < g && this.timeScale() > 0) &&
                  this._prom())));
      }
      return this;
    }
    add(t, e) {
      if ((vv(e) || (e = Uy(this, e, t)), !(t instanceof Ax))) {
        if (Ev(t)) return t.forEach((t) => this.add(t, e)), this;
        if (gv(t)) return this.addLabel(t, e);
        if (!_v(t)) return this;
        t = zx.delayedCall(0, t);
      }
      return this !== t ? wy(this, t, e) : this;
    }
    getChildren(t = !0, e = !0, n = !0, i = -1e8) {
      let r = [],
        s = this._first;
      for (; s; )
        s._start >= i &&
          (s instanceof zx
            ? e && r.push(s)
            : (n && r.push(s), t && r.push(...s.getChildren(!0, e, n)))),
          (s = s._next);
      return r;
    }
    getById(t) {
      let e = this.getChildren(1, 1, 1),
        n = e.length;
      for (; n--; ) if (e[n].vars.id === t) return e[n];
    }
    remove(t) {
      return gv(t)
        ? this.removeLabel(t)
        : _v(t)
        ? this.killTweensOf(t)
        : (my(this, t),
          t === this._recent && (this._recent = this._last),
          _y(this));
    }
    totalTime(t, e) {
      return arguments.length
        ? ((this._forcing = 1),
          !this._dp &&
            this._ts &&
            (this._start = ny(
              px.time -
                (this._ts > 0
                  ? t / this._ts
                  : (this.totalDuration() - t) / -this._ts)
            )),
          super.totalTime(t, e),
          (this._forcing = 0),
          this)
        : this._tTime;
    }
    addLabel(t, e) {
      return (this.labels[t] = Uy(this, e)), this;
    }
    removeLabel(t) {
      return delete this.labels[t], this;
    }
    addPause(t, e, n) {
      let i = zx.delayedCall(0, e || zv, n);
      return (
        (i.data = "isPause"), (this._hasPause = 1), wy(this, i, Uy(this, t))
      );
    }
    removePause(t) {
      let e = this._first;
      for (t = Uy(this, t); e; )
        e._start === t && "isPause" === e.data && gy(e), (e = e._next);
    }
    killTweensOf(t, e, n) {
      let i = this.getTweensOf(t, n),
        r = i.length;
      for (; r--; ) Cx !== i[r] && i[r].kill(t, e);
      return this;
    }
    getTweensOf(t, e) {
      let n,
        i = [],
        r = Hy(t),
        s = this._first,
        a = vv(e);
      for (; s; )
        s instanceof zx
          ? ry(s._targets, r) &&
            (a
              ? (!Cx || (s._initted && s._ts)) &&
                s.globalTime(0) <= e &&
                s.globalTime(s.totalDuration()) > e
              : !e || s.isActive()) &&
            i.push(s)
          : (n = s.getTweensOf(r, e)).length && i.push(...n),
          (s = s._next);
      return i;
    }
    tweenTo(t, e) {
      e = e || {};
      let n,
        i = this,
        r = Uy(i, t),
        { startAt: s, onStart: a, onStartParams: o, immediateRender: l } = e,
        c = zx.to(
          i,
          cy(
            {
              ease: e.ease || "none",
              lazy: !1,
              immediateRender: !1,
              time: r,
              overwrite: "auto",
              duration:
                e.duration ||
                Math.abs(
                  (r - (s && "time" in s ? s.time : i._time)) / i.timeScale()
                ) ||
                cv,
              onStart: () => {
                if ((i.pause(), !n)) {
                  let t =
                    e.duration ||
                    Math.abs(
                      (r - (s && "time" in s ? s.time : i._time)) /
                        i.timeScale()
                    );
                  c._dur !== t && Ly(c, t, 0, 1).render(c._time, !0, !0),
                    (n = 1);
                }
                a && a.apply(c, o || []);
              },
            },
            e
          )
        );
      return l ? c.render(0) : c;
    }
    tweenFromTo(t, e, n) {
      return this.tweenTo(e, cy({ startAt: { time: Uy(this, t) } }, n));
    }
    recent() {
      return this._recent;
    }
    nextLabel(t = this._time) {
      return tx(this, Uy(this, t));
    }
    previousLabel(t = this._time) {
      return tx(this, Uy(this, t), 1);
    }
    currentLabel(t) {
      return arguments.length
        ? this.seek(t, !0)
        : this.previousLabel(this._time + cv);
    }
    shiftChildren(t, e, n = 0) {
      let i,
        r = this._first,
        s = this.labels;
      for (; r; )
        r._start >= n && ((r._start += t), (r._end += t)), (r = r._next);
      if (e) for (i in s) s[i] >= n && (s[i] += t);
      return _y(this);
    }
    invalidate(t) {
      let e = this._first;
      for (this._lock = 0; e; ) e.invalidate(t), (e = e._next);
      return super.invalidate(t);
    }
    clear(t = !0) {
      let e,
        n = this._first;
      for (; n; ) (e = n._next), this.remove(n), (n = e);
      return (
        this._dp && (this._time = this._tTime = this._pTime = 0),
        t && (this.labels = {}),
        _y(this)
      );
    }
    totalDuration(t) {
      let e,
        n,
        i,
        r = 0,
        s = this,
        a = s._last,
        o = lv;
      if (arguments.length)
        return s.timeScale(
          (s._repeat < 0 ? s.duration() : s.totalDuration()) /
            (s.reversed() ? -t : t)
        );
      if (s._dirty) {
        for (i = s.parent; a; )
          (e = a._prev),
            a._dirty && a.totalDuration(),
            (n = a._start),
            n > o && s._sort && a._ts && !s._lock
              ? ((s._lock = 1), (wy(s, a, n - a._delay, 1)._lock = 0))
              : (o = n),
            n < 0 &&
              a._ts &&
              ((r -= n),
              ((!i && !s._dp) || (i && i.smoothChildTiming)) &&
                ((s._start += n / s._ts), (s._time -= n), (s._tTime -= n)),
              s.shiftChildren(-n, !1, -Infinity),
              (o = 0)),
            a._end > r && a._ts && (r = a._end),
            (a = e);
        Ly(s, s === Q_ && s._time > r ? s._time : r, 1, 1), (s._dirty = 0);
      }
      return s._tDur;
    }
    static updateRoot(t) {
      if ((Q_._ts && (ay(Q_, My(t, Q_)), (iv = px.frame)), px.frame >= Yv)) {
        Yv += av.autoSleep || 120;
        let t = Q_._first;
        if ((!t || !t._ts) && av.autoSleep && px._listeners.length < 2) {
          for (; t && !t._ts; ) t = t._next;
          t || px.sleep();
        }
      }
    }
  }
  cy(Rx.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
  let Cx,
    Px,
    Lx = function (t, e, n, i, r, s, a) {
      let o,
        l,
        c,
        h,
        u,
        d,
        p,
        f,
        m = new $x(this._pt, t, e, 0, 1, qx, null, r),
        g = 0,
        _ = 0;
      for (
        m.b = n,
          m.e = i,
          n += "",
          (p = ~(i += "").indexOf("random(")) && (i = Jy(i)),
          s && ((f = [n, i]), s(f, t, e), (n = f[0]), (i = f[1])),
          l = n.match(Cv) || [];
        (o = Cv.exec(i));

      )
        (h = o[0]),
          (u = i.substring(g, o.index)),
          c ? (c = (c + 1) % 5) : "rgba(" === u.substr(-5) && (c = 1),
          h !== l[_++] &&
            ((d = parseFloat(l[_ - 1]) || 0),
            (m._pt = {
              _next: m._pt,
              p: u || 1 === _ ? u : ",",
              s: d,
              c: "=" === h.charAt(1) ? iy(d, h) - d : parseFloat(h) - d,
              m: c && c < 4 ? Math.round : 0,
            }),
            (g = Cv.lastIndex));
      return (
        (m.c = g < i.length ? i.substring(g, i.length) : ""),
        (m.fp = a),
        (Pv.test(i) || p) && (m.e = 0),
        (this._pt = m),
        m
      );
    },
    Dx = function (t, e, n, i, r, s, a, o, l, c) {
      _v(i) && (i = i(r || 0, t, s));
      let h,
        u = t[e],
        d =
          "get" !== n
            ? n
            : _v(u)
            ? l
              ? t[
                  e.indexOf("set") || !_v(t["get" + e.substr(3)])
                    ? e
                    : "get" + e.substr(3)
                ](l)
              : t[e]()
            : u,
        p = _v(u) ? (l ? Gx : Hx) : Bx;
      if (
        (gv(i) &&
          (~i.indexOf("random(") && (i = Jy(i)),
          "=" === i.charAt(1) &&
            ((h = iy(d, i) + (ky(d) || 0)), (h || 0 === h) && (i = h))),
        !c || d !== i || Px)
      )
        return isNaN(d * i) || "" === i
          ? (!u && !(e in t) && Ov(e, i),
            Lx.call(this, t, e, d, i, p, o || av.stringFilter, l))
          : ((h = new $x(
              this._pt,
              t,
              e,
              +d || 0,
              i - (d || 0),
              "boolean" == typeof u ? jx : Xx,
              0,
              p
            )),
            l && (h.fp = l),
            a && h.modifier(a, this, t),
            (this._pt = h));
    },
    Ix = (t, e, n, i, r, s) => {
      let a, o, l, c;
      if (
        jv[t] &&
        !1 !==
          (a = new jv[t]()).init(
            r,
            a.rawVars
              ? e[t]
              : ((t, e, n, i, r) => {
                  if (
                    (_v(t) && (t = Ox(t, r, e, n, i)),
                    !xv(t) || (t.style && t.nodeType) || Ev(t) || bv(t))
                  )
                    return gv(t) ? Ox(t, r, e, n, i) : t;
                  let s,
                    a = {};
                  for (s in t) a[s] = Ox(t[s], r, e, n, i);
                  return a;
                })(e[t], i, r, s, n),
            n,
            i,
            s
          ) &&
        ((n._pt = o = new $x(n._pt, r, t, 0, 1, a.render, a, 0, a.priority)),
        n !== rv)
      )
        for (l = n._ptLookup[n._targets.indexOf(r)], c = a._props.length; c--; )
          l[a._props[c]] = o;
      return a;
    },
    Ux = (t, e, n) => {
      let i,
        r,
        s,
        a,
        o,
        l,
        c,
        h,
        u,
        d,
        p,
        f,
        m,
        g = t.vars,
        {
          ease: _,
          startAt: v,
          immediateRender: y,
          lazy: x,
          onUpdate: T,
          runBackwards: M,
          yoyoEase: S,
          keyframes: b,
          autoRevert: E,
        } = g,
        w = t._dur,
        A = t._startAt,
        R = t._targets,
        C = t.parent,
        P = C && "nested" === C.data ? C.vars.targets : R,
        L = "auto" === t._overwrite && !K_,
        D = t.timeline;
      if (
        (D && (!b || !_) && (_ = "none"),
        (t._ease = Tx(_, ov.ease)),
        (t._yEase = S ? yx(Tx(!0 === S ? _ : S, ov.ease)) : 0),
        S &&
          t._yoyo &&
          !t._repeat &&
          ((S = t._yEase), (t._yEase = t._ease), (t._ease = S)),
        (t._from = !D && !!g.runBackwards),
        !D || (b && !g.stagger))
      ) {
        if (
          ((h = R[0] ? Qv(R[0]).harness : 0),
          (f = h && g[h.prop]),
          (i = dy(g, Vv)),
          A &&
            (A._zTime < 0 && A.progress(1),
            e < 0 && M && y && !E
              ? A.render(-1, !0)
              : A.revert(M && w ? Hv : Bv),
            (A._lazy = 0)),
          v)
        ) {
          if (
            (gy(
              (t._startAt = zx.set(
                R,
                cy(
                  {
                    data: "isStart",
                    overwrite: !1,
                    parent: C,
                    immediateRender: !0,
                    lazy: !A && Tv(x),
                    startAt: null,
                    delay: 0,
                    onUpdate: T && (() => ex(t, "onUpdate")),
                    stagger: 0,
                  },
                  v
                )
              ))
            ),
            (t._startAt._dp = 0),
            (t._startAt._sat = t),
            e < 0 && (Z_ || (!y && !E)) && t._startAt.revert(Hv),
            y && w && e <= 0 && n <= 0)
          )
            return void (e && (t._zTime = e));
        } else if (M && w && !A)
          if (
            (e && (y = !1),
            (s = cy(
              {
                overwrite: !1,
                data: "isFromStart",
                lazy: y && !A && Tv(x),
                immediateRender: y,
                stagger: 0,
                parent: C,
              },
              i
            )),
            f && (s[h.prop] = f),
            gy((t._startAt = zx.set(R, s))),
            (t._startAt._dp = 0),
            (t._startAt._sat = t),
            e < 0 && (Z_ ? t._startAt.revert(Hv) : t._startAt.render(-1, !0)),
            (t._zTime = e),
            y)
          ) {
            if (!e) return;
          } else Ux(t._startAt, cv, cv);
        for (
          t._pt = t._ptCache = 0, x = (w && Tv(x)) || (x && !w), r = 0;
          r < R.length;
          r++
        ) {
          if (
            ((o = R[r]),
            (c = o._gsap || Jv(R)[r]._gsap),
            (t._ptLookup[r] = d = {}),
            Xv[c.id] && Wv.length && sy(),
            (p = P === R ? r : P.indexOf(o)),
            h &&
              !1 !== (u = new h()).init(o, f || i, t, p, P) &&
              ((t._pt = a =
                new $x(t._pt, o, u.name, 0, 1, u.render, u, 0, u.priority)),
              u._props.forEach((t) => {
                d[t] = a;
              }),
              u.priority && (l = 1)),
            !h || f)
          )
            for (s in i)
              jv[s] && (u = Ix(s, i, t, p, o, P))
                ? u.priority && (l = 1)
                : (d[s] = a =
                    Dx.call(t, o, s, "get", i[s], p, P, 0, g.stringFilter));
          t._op && t._op[r] && t.kill(o, t._op[r]),
            L &&
              t._pt &&
              ((Cx = t),
              Q_.killTweensOf(o, d, t.globalTime(e)),
              (m = !t.parent),
              (Cx = 0)),
            t._pt && x && (Xv[c.id] = 1);
        }
        l && Qx(t), t._onInit && t._onInit(t);
      }
      (t._onUpdate = T),
        (t._initted = (!t._op || t._pt) && !m),
        b && e <= 0 && D.render(lv, !0, !0);
    },
    Nx = (t, e, n, i) => {
      let r,
        s,
        a = e.ease || i || "power1.inOut";
      if (Ev(e))
        (s = n[t] || (n[t] = [])),
          e.forEach((t, n) =>
            s.push({ t: (n / (e.length - 1)) * 100, v: t, e: a })
          );
      else
        for (r in e)
          (s = n[r] || (n[r] = [])),
            "ease" === r || s.push({ t: parseFloat(t), v: e[r], e: a });
    },
    Ox = (t, e, n, i, r) =>
      _v(t) ? t.call(e, n, i, r) : gv(t) && ~t.indexOf("random(") ? Jy(t) : t,
    Fx = Zv + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
    kx = {};
  ty(
    Fx + ",id,stagger,delay,duration,paused,scrollTrigger",
    (t) => (kx[t] = 1)
  );
  class zx extends Ax {
    constructor(t, e, n, i) {
      "number" == typeof e && ((n.duration = e), (e = n), (n = null)),
        super(i ? e : py(e));
      let r,
        s,
        a,
        o,
        l,
        c,
        h,
        u,
        {
          duration: d,
          delay: p,
          immediateRender: f,
          stagger: m,
          overwrite: g,
          keyframes: _,
          defaults: v,
          scrollTrigger: y,
          yoyoEase: x,
        } = this.vars,
        T = e.parent || Q_,
        M = (Ev(t) || bv(t) ? vv(t[0]) : "length" in e) ? [t] : Hy(t);
      if (
        ((this._targets = M.length
          ? Jv(M)
          : Fv(
              "GSAP target " + t + " not found. https://gsap.com",
              !av.nullTargetWarn
            ) || []),
        (this._ptLookup = []),
        (this._overwrite = g),
        _ || m || Sv(d) || Sv(p))
      ) {
        if (
          ((e = this.vars),
          (r = this.timeline =
            new Rx({
              data: "nested",
              defaults: v || {},
              targets: T && "nested" === T.data ? T.vars.targets : M,
            })),
          r.kill(),
          (r.parent = r._dp = this),
          (r._start = 0),
          m || Sv(d) || Sv(p))
        ) {
          if (((o = M.length), (h = m && Wy(m)), xv(m)))
            for (l in m) ~Fx.indexOf(l) && (u || (u = {}), (u[l] = m[l]));
          for (s = 0; s < o; s++)
            (a = dy(e, kx)),
              (a.stagger = 0),
              x && (a.yoyoEase = x),
              u && hy(a, u),
              (c = M[s]),
              (a.duration = +Ox(d, this, s, c, M)),
              (a.delay = (+Ox(p, this, s, c, M) || 0) - this._delay),
              !m &&
                1 === o &&
                a.delay &&
                ((this._delay = p = a.delay),
                (this._start += p),
                (a.delay = 0)),
              r.to(c, a, h ? h(s, c, M) : 0),
              (r._ease = mx.none);
          r.duration() ? (d = p = 0) : (this.timeline = 0);
        } else if (_) {
          py(cy(r.vars.defaults, { ease: "none" })),
            (r._ease = Tx(_.ease || e.ease || "none"));
          let t,
            n,
            i,
            o = 0;
          if (Ev(_)) _.forEach((t) => r.to(M, t, ">")), r.duration();
          else {
            for (l in ((a = {}), _))
              "ease" === l || "easeEach" === l || Nx(l, _[l], a, _.easeEach);
            for (l in a)
              for (
                t = a[l].sort((t, e) => t.t - e.t), o = 0, s = 0;
                s < t.length;
                s++
              )
                (n = t[s]),
                  (i = {
                    ease: n.e,
                    duration: ((n.t - (s ? t[s - 1].t : 0)) / 100) * d,
                  }),
                  (i[l] = n.v),
                  r.to(M, i, o),
                  (o += i.duration);
            r.duration() < d && r.to({}, { duration: d - r.duration() });
          }
        }
        d || this.duration((d = r.duration()));
      } else this.timeline = 0;
      !0 !== g || K_ || ((Cx = this), Q_.killTweensOf(M), (Cx = 0)),
        wy(T, this, n),
        e.reversed && this.reverse(),
        e.paused && this.paused(!0),
        (f ||
          (!d &&
            !_ &&
            this._start === ny(T._time) &&
            Tv(f) &&
            yy(this) &&
            "nested" !== T.data)) &&
          ((this._tTime = -1e-8), this.render(Math.max(0, -p) || 0)),
        y && Ay(this, y);
    }
    render(t, e, n) {
      let i,
        r,
        s,
        a,
        o,
        l,
        c,
        h,
        u,
        d = this._time,
        p = this._tDur,
        f = this._dur,
        m = t < 0,
        g = t > p - cv && !m ? p : t < cv ? 0 : t;
      if (f) {
        if (
          g !== this._tTime ||
          !t ||
          n ||
          (!this._initted && this._tTime) ||
          (this._startAt && this._zTime < 0 !== m)
        ) {
          if (((i = g), (h = this.timeline), this._repeat)) {
            if (((a = f + this._rDelay), this._repeat < -1 && m))
              return this.totalTime(100 * a + t, e, n);
            if (
              ((i = ny(g % a)),
              g === p
                ? ((s = this._repeat), (i = f))
                : ((s = ~~(g / a)),
                  s && s === ny(g / a) && ((i = f), s--),
                  i > f && (i = f)),
              (l = this._yoyo && 1 & s),
              l && ((u = this._yEase), (i = f - i)),
              (o = Ty(this._tTime, a)),
              i === d && !n && this._initted && s === o)
            )
              return (this._tTime = g), this;
            s !== o &&
              (h && this._yEase && xx(h, l),
              this.vars.repeatRefresh &&
                !l &&
                !this._lock &&
                this._time !== f &&
                this._initted &&
                ((this._lock = n = 1),
                (this.render(ny(a * s), !0).invalidate()._lock = 0)));
          }
          if (!this._initted) {
            if (Ry(this, m ? t : i, n, e, g)) return (this._tTime = 0), this;
            if (
              !(d === this._time || (n && this.vars.repeatRefresh && s !== o))
            )
              return this;
            if (f !== this._dur) return this.render(t, e, n);
          }
          if (
            ((this._tTime = g),
            (this._time = i),
            !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
            (this.ratio = c = (u || this._ease)(i / f)),
            this._from && (this.ratio = c = 1 - c),
            i && !d && !e && !s && (ex(this, "onStart"), this._tTime !== g))
          )
            return this;
          for (r = this._pt; r; ) r.r(c, r.d), (r = r._next);
          (h &&
            h.render(
              t < 0 ? t : !i && l ? -1e-8 : h._dur * h._ease(i / this._dur),
              e,
              n
            )) ||
            (this._startAt && (this._zTime = t)),
            this._onUpdate &&
              !e &&
              (m && vy(this, t, 0, n), ex(this, "onUpdate")),
            this._repeat &&
              s !== o &&
              this.vars.onRepeat &&
              !e &&
              this.parent &&
              ex(this, "onRepeat"),
            (g !== this._tDur && g) ||
              this._tTime !== g ||
              (m && !this._onUpdate && vy(this, t, 0, !0),
              (t || !f) &&
                ((g === this._tDur && this._ts > 0) || (!g && this._ts < 0)) &&
                gy(this, 1),
              e ||
                (m && !d) ||
                !(g || d || l) ||
                (ex(this, g === p ? "onComplete" : "onReverseComplete", !0),
                this._prom &&
                  !(g < p && this.timeScale() > 0) &&
                  this._prom()));
        }
      } else
        ((t, e, n, i) => {
          let r,
            s,
            a,
            o = t.ratio,
            l =
              e < 0 ||
              (!e &&
                ((!t._start && Cy(t) && (t._initted || !Py(t))) ||
                  ((t._ts < 0 || t._dp._ts < 0) && !Py(t))))
                ? 0
                : 1,
            c = t._rDelay,
            h = 0;
          if (
            (c &&
              t._repeat &&
              ((h = Fy(0, t._tDur, e)),
              (s = Ty(h, c)),
              t._yoyo && 1 & s && (l = 1 - l),
              s !== Ty(t._tTime, c) &&
                ((o = 1 - l),
                t.vars.repeatRefresh && t._initted && t.invalidate())),
            l !== o || Z_ || i || t._zTime === cv || (!e && t._zTime))
          ) {
            if (!t._initted && Ry(t, e, i, n, h)) return;
            for (
              a = t._zTime,
                t._zTime = e || (n ? cv : 0),
                n || (n = e && !a),
                t.ratio = l,
                t._from && (l = 1 - l),
                t._time = 0,
                t._tTime = h,
                r = t._pt;
              r;

            )
              r.r(l, r.d), (r = r._next);
            e < 0 && vy(t, e, 0, !0),
              t._onUpdate && !n && ex(t, "onUpdate"),
              h && t._repeat && !n && t.parent && ex(t, "onRepeat"),
              (e >= t._tDur || e < 0) &&
                t.ratio === l &&
                (l && gy(t, 1),
                n ||
                  Z_ ||
                  (ex(t, l ? "onComplete" : "onReverseComplete", !0),
                  t._prom && t._prom()));
          } else t._zTime || (t._zTime = e);
        })(this, t, e, n);
      return this;
    }
    targets() {
      return this._targets;
    }
    invalidate(t) {
      return (
        (!t || !this.vars.runBackwards) && (this._startAt = 0),
        (this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0),
        (this._ptLookup = []),
        this.timeline && this.timeline.invalidate(t),
        super.invalidate(t)
      );
    }
    resetTo(t, e, n, i, r) {
      sv || px.wake(), this._ts || this.play();
      let s,
        a = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
      return (
        this._initted || Ux(this, a),
        (s = this._ease(a / this._dur)),
        ((t, e, n, i, r, s, a, o) => {
          let l,
            c,
            h,
            u,
            d = ((t._pt && t._ptCache) || (t._ptCache = {}))[e];
          if (!d)
            for (
              d = t._ptCache[e] = [], h = t._ptLookup, u = t._targets.length;
              u--;

            ) {
              if (((l = h[u][e]), l && l.d && l.d._pt))
                for (l = l.d._pt; l && l.p !== e && l.fp !== e; ) l = l._next;
              if (!l)
                return (
                  (Px = 1),
                  (t.vars[e] = "+=0"),
                  Ux(t, a),
                  (Px = 0),
                  o ? Fv(e + " not eligible for reset") : 1
                );
              d.push(l);
            }
          for (u = d.length; u--; )
            (c = d[u]),
              (l = c._pt || c),
              (l.s = (!i && 0 !== i) || r ? l.s + (i || 0) + s * l.c : i),
              (l.c = n - l.s),
              c.e && (c.e = ey(n) + ky(c.e)),
              c.b && (c.b = l.s + ky(c.b));
        })(this, t, e, n, i, s, a, r)
          ? this.resetTo(t, e, n, i, 1)
          : (by(this, 0),
            this.parent ||
              fy(
                this._dp,
                this,
                "_first",
                "_last",
                this._dp._sort ? "_start" : 0
              ),
            this.render(0))
      );
    }
    kill(t, e = "all") {
      if (!(t || (e && "all" !== e)))
        return (this._lazy = this._pt = 0), this.parent ? nx(this) : this;
      if (this.timeline) {
        let n = this.timeline.totalDuration();
        return (
          this.timeline.killTweensOf(t, e, Cx && !0 !== Cx.vars.overwrite)
            ._first || nx(this),
          this.parent &&
            n !== this.timeline.totalDuration() &&
            Ly(this, (this._dur * this.timeline._tDur) / n, 0, 1),
          this
        );
      }
      let n,
        i,
        r,
        s,
        a,
        o,
        l,
        c = this._targets,
        h = t ? Hy(t) : c,
        u = this._ptLookup,
        d = this._pt;
      if (
        (!e || "all" === e) &&
        ((t, e) => {
          let n = t.length,
            i = n === e.length;
          for (; i && n-- && t[n] === e[n]; );
          return n < 0;
        })(c, h)
      )
        return "all" === e && (this._pt = 0), nx(this);
      for (
        n = this._op = this._op || [],
          "all" !== e &&
            (gv(e) && ((a = {}), ty(e, (t) => (a[t] = 1)), (e = a)),
            (e = ((t, e) => {
              let n,
                i,
                r,
                s,
                a = t[0] ? Qv(t[0]).harness : 0,
                o = a && a.aliases;
              if (!o) return e;
              for (i in ((n = hy({}, e)), o))
                if ((i in n))
                  for (s = o[i].split(","), r = s.length; r--; ) n[s[r]] = n[i];
              return n;
            })(c, e))),
          l = c.length;
        l--;

      )
        if (~h.indexOf(c[l]))
          for (a in ((i = u[l]),
          "all" === e
            ? ((n[l] = e), (s = i), (r = {}))
            : ((r = n[l] = n[l] || {}), (s = e)),
          s))
            (o = i && i[a]),
              o &&
                (("kill" in o.d && !0 !== o.d.kill(a)) || my(this, o, "_pt"),
                delete i[a]),
              "all" !== r && (r[a] = 1);
      return this._initted && !this._pt && d && nx(this), this;
    }
    static to(t, e) {
      return new zx(t, e, arguments[2]);
    }
    static from(t, e) {
      return Ny(1, arguments);
    }
    static delayedCall(t, e, n, i) {
      return new zx(e, 0, {
        immediateRender: !1,
        lazy: !1,
        overwrite: !1,
        delay: t,
        onComplete: e,
        onReverseComplete: e,
        onCompleteParams: n,
        onReverseCompleteParams: n,
        callbackScope: i,
      });
    }
    static fromTo(t, e, n) {
      return Ny(2, arguments);
    }
    static set(t, e) {
      return (e.duration = 0), e.repeatDelay || (e.repeat = 0), new zx(t, e);
    }
    static killTweensOf(t, e, n) {
      return Q_.killTweensOf(t, e, n);
    }
  }
  cy(zx.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }),
    ty("staggerTo,staggerFrom,staggerFromTo", (t) => {
      zx[t] = function () {
        let e = new Rx(),
          n = zy.call(arguments, 0);
        return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n);
      };
    });
  let Bx = (t, e, n) => (t[e] = n),
    Hx = (t, e, n) => t[e](n),
    Gx = (t, e, n, i) => t[e](i.fp, n),
    Vx = (t, e, n) => t.setAttribute(e, n),
    Wx = (t, e) => (_v(t[e]) ? Hx : yv(t[e]) && t.setAttribute ? Vx : Bx),
    Xx = (t, e) => e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e),
    jx = (t, e) => e.set(e.t, e.p, !!(e.s + e.c * t), e),
    qx = function (t, e) {
      let n = e._pt,
        i = "";
      if (!t && e.b) i = e.b;
      else if (1 === t && e.e) i = e.e;
      else {
        for (; n; )
          (i =
            n.p +
            (n.m
              ? n.m(n.s + n.c * t)
              : Math.round(1e4 * (n.s + n.c * t)) / 1e4) +
            i),
            (n = n._next);
        i += e.c;
      }
      e.set(e.t, e.p, i, e);
    },
    Yx = function (t, e) {
      let n = e._pt;
      for (; n; ) n.r(t, n.d), (n = n._next);
    },
    Kx = function (t, e, n, i) {
      let r,
        s = this._pt;
      for (; s; ) (r = s._next), s.p === i && s.modifier(t, e, n), (s = r);
    },
    Zx = function (t) {
      let e,
        n,
        i = this._pt;
      for (; i; )
        (n = i._next),
          (i.p === t && !i.op) || i.op === t
            ? my(this, i, "_pt")
            : i.dep || (e = 1),
          (i = n);
      return !e;
    },
    Jx = (t, e, n, i) => {
      i.mSet(t, e, i.m.call(i.tween, n, i.mt), i);
    },
    Qx = (t) => {
      let e,
        n,
        i,
        r,
        s = t._pt;
      for (; s; ) {
        for (e = s._next, n = i; n && n.pr > s.pr; ) n = n._next;
        (s._prev = n ? n._prev : r) ? (s._prev._next = s) : (i = s),
          (s._next = n) ? (n._prev = s) : (r = s),
          (s = e);
      }
      t._pt = i;
    };
  class $x {
    constructor(t, e, n, i, r, s, a, o, l) {
      (this.t = e),
        (this.s = i),
        (this.c = r),
        (this.p = n),
        (this.r = s || Xx),
        (this.d = a || this),
        (this.set = o || Bx),
        (this.pr = l || 0),
        (this._next = t),
        t && (t._prev = this);
    }
    modifier(t, e, n) {
      (this.mSet = this.mSet || this.set),
        (this.set = Jx),
        (this.m = t),
        (this.mt = n),
        (this.tween = e);
    }
  }
  ty(
    Zv +
      "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
    (t) => (Vv[t] = 1)
  ),
    (Iv.TweenMax = Iv.TweenLite = zx),
    (Iv.TimelineLite = Iv.TimelineMax = Rx),
    (Q_ = new Rx({
      sortChildren: !1,
      defaults: ov,
      autoRemoveChildren: !0,
      id: "root",
      smoothChildTiming: !0,
    })),
    (av.stringFilter = (t) => {
      let e,
        n = t.join(" ");
      if (((ux.lastIndex = 0), ux.test(n)))
        return (
          (e = dx.test(n)),
          (t[1] = hx(t[1], e)),
          (t[0] = hx(t[0], e, cx(t[1]))),
          !0
        );
    });
  let tT = [],
    eT = {},
    nT = [],
    iT = 0,
    rT = 0,
    sT = (t) => (eT[t] || nT).map((t) => t()),
    aT = () => {
      let t = Date.now(),
        e = [];
      t - iT > 2 &&
        (sT("matchMediaInit"),
        tT.forEach((t) => {
          let n,
            i,
            r,
            s,
            a = t.queries,
            o = t.conditions;
          for (i in a)
            (n = $_.matchMedia(a[i]).matches),
              n && (r = 1),
              n !== o[i] && ((o[i] = n), (s = 1));
          s && (t.revert(), r && e.push(t));
        }),
        sT("matchMediaRevert"),
        e.forEach((t) => t.onMatch(t, (e) => t.add(null, e))),
        (iT = t),
        sT("matchMedia"));
    };
  class oT {
    constructor(t, e) {
      (this.selector = e && Gy(e)),
        (this.data = []),
        (this._r = []),
        (this.isReverted = !1),
        (this.id = rT++),
        t && this.add(t);
    }
    add(t, e, n) {
      _v(t) && ((n = e), (e = t), (t = _v));
      let i = this,
        r = function () {
          let t,
            r = J_,
            s = i.selector;
          return (
            r && r !== i && r.data.push(i),
            n && (i.selector = Gy(n)),
            (J_ = i),
            (t = e.apply(i, arguments)),
            _v(t) && i._r.push(t),
            (J_ = r),
            (i.selector = s),
            (i.isReverted = !1),
            t
          );
        };
      return (
        (i.last = r),
        t === _v ? r(i, (t) => i.add(null, t)) : t ? (i[t] = r) : r
      );
    }
    ignore(t) {
      let e = J_;
      (J_ = null), t(this), (J_ = e);
    }
    getTweens() {
      let t = [];
      return (
        this.data.forEach((e) =>
          e instanceof oT
            ? t.push(...e.getTweens())
            : e instanceof zx &&
              !(e.parent && "nested" === e.parent.data) &&
              t.push(e)
        ),
        t
      );
    }
    clear() {
      this._r.length = this.data.length = 0;
    }
    kill(t, e) {
      if (t) {
        let e,
          n = this.getTweens(),
          i = this.data.length;
        for (; i--; )
          (e = this.data[i]),
            "isFlip" === e.data &&
              (e.revert(),
              e
                .getChildren(!0, !0, !1)
                .forEach((t) => n.splice(n.indexOf(t), 1)));
        for (
          n
            .map((t) => ({
              g:
                t._dur || t._delay || (t._sat && !t._sat.vars.immediateRender)
                  ? t.globalTime(0)
                  : -1 / 0,
              t,
            }))
            .sort((t, e) => e.g - t.g || -1 / 0)
            .forEach((e) => e.t.revert(t)),
            i = this.data.length;
          i--;

        )
          (e = this.data[i]),
            e instanceof Rx
              ? "nested" !== e.data &&
                (e.scrollTrigger && e.scrollTrigger.revert(), e.kill())
              : !(e instanceof zx) && e.revert && e.revert(t);
        this._r.forEach((e) => e(t, this)), (this.isReverted = !0);
      } else this.data.forEach((t) => t.kill && t.kill());
      if ((this.clear(), e)) {
        let t = tT.length;
        for (; t--; ) tT[t].id === this.id && tT.splice(t, 1);
      }
    }
    revert(t) {
      this.kill(t || {});
    }
  }
  class lT {
    constructor(t) {
      (this.contexts = []), (this.scope = t);
    }
    add(t, e, n) {
      xv(t) || (t = { matches: t });
      let i,
        r,
        s,
        a = new oT(0, n || this.scope),
        o = (a.conditions = {});
      for (r in (J_ && !a.selector && (a.selector = J_.selector),
      this.contexts.push(a),
      (e = a.add("onMatch", e)),
      (a.queries = t),
      t))
        "all" === r
          ? (s = 1)
          : ((i = $_.matchMedia(t[r])),
            i &&
              (tT.indexOf(a) < 0 && tT.push(a),
              (o[r] = i.matches) && (s = 1),
              i.addListener
                ? i.addListener(aT)
                : i.addEventListener("change", aT)));
      return s && e(a, (t) => a.add(null, t)), this;
    }
    revert(t) {
      this.kill(t || {});
    }
    kill(t) {
      this.contexts.forEach((e) => e.kill(t, !0));
    }
  }
  const cT = {
    registerPlugin(...t) {
      t.forEach((t) => rx(t));
    },
    timeline: (t) => new Rx(t),
    getTweensOf: (t, e) => Q_.getTweensOf(t, e),
    getProperty(t, e, n, i) {
      gv(t) && (t = Hy(t)[0]);
      let r = Qv(t || {}).get,
        s = n ? ly : oy;
      return (
        "native" === n && (n = ""),
        t
          ? e
            ? s(((jv[e] && jv[e].get) || r)(t, e, n, i))
            : (e, n, i) => s(((jv[e] && jv[e].get) || r)(t, e, n, i))
          : t
      );
    },
    quickSetter(t, e, n) {
      if ((t = Hy(t)).length > 1) {
        let i = t.map((t) => dT.quickSetter(t, e, n)),
          r = i.length;
        return (t) => {
          let e = r;
          for (; e--; ) i[e](t);
        };
      }
      t = t[0] || {};
      let i = jv[e],
        r = Qv(t),
        s = (r.harness && (r.harness.aliases || {})[e]) || e,
        a = i
          ? (e) => {
              let r = new i();
              (rv._pt = 0),
                r.init(t, n ? e + n : e, rv, 0, [t]),
                r.render(1, r),
                rv._pt && Yx(1, rv);
            }
          : r.set(t, s);
      return i ? a : (e) => a(t, s, n ? e + n : e, r, 1);
    },
    quickTo(t, e, n) {
      let i = dT.to(t, hy({ [e]: "+=0.1", paused: !0 }, n || {})),
        r = (t, n, r) => i.resetTo(e, t, n, r);
      return (r.tween = i), r;
    },
    isTweening: (t) => Q_.getTweensOf(t, !0).length > 0,
    defaults: (t) => (
      t && t.ease && (t.ease = Tx(t.ease, ov.ease)), uy(ov, t || {})
    ),
    config: (t) => uy(av, t || {}),
    registerEffect({
      name: t,
      effect: e,
      plugins: n,
      defaults: i,
      extendTimeline: r,
    }) {
      (n || "")
        .split(",")
        .forEach(
          (e) =>
            e &&
            !jv[e] &&
            !Iv[e] &&
            Fv(t + " effect requires " + e + " plugin.")
        ),
        (qv[t] = (t, n, r) => e(Hy(t), cy(n || {}, i), r)),
        r &&
          (Rx.prototype[t] = function (e, n, i) {
            return this.add(qv[t](e, xv(n) ? n : (i = n) && {}, this), i);
          });
    },
    registerEase(t, e) {
      mx[t] = Tx(e);
    },
    parseEase(t, e) {
      return arguments.length ? Tx(t, e) : mx;
    },
    getById: (t) => Q_.getById(t),
    exportRoot(t = {}, e) {
      let n,
        i,
        r = new Rx(t);
      for (
        r.smoothChildTiming = Tv(t.smoothChildTiming),
          Q_.remove(r),
          r._dp = 0,
          r._time = r._tTime = Q_._time,
          n = Q_._first;
        n;

      )
        (i = n._next),
          (!e &&
            !n._dur &&
            n instanceof zx &&
            n.vars.onComplete === n._targets[0]) ||
            wy(r, n, n._start - n._delay),
          (n = i);
      return wy(Q_, r, 0), r;
    },
    context: (t, e) => (t ? new oT(t, e) : J_),
    matchMedia: (t) => new lT(t),
    matchMediaRefresh: () =>
      tT.forEach((t) => {
        let e,
          n,
          i = t.conditions;
        for (n in i) i[n] && ((i[n] = !1), (e = 1));
        e && t.revert();
      }) || aT(),
    addEventListener(t, e) {
      let n = eT[t] || (eT[t] = []);
      ~n.indexOf(e) || n.push(e);
    },
    removeEventListener(t, e) {
      let n = eT[t],
        i = n && n.indexOf(e);
      i >= 0 && n.splice(i, 1);
    },
    utils: {
      wrap: Ky,
      wrapYoyo: Zy,
      distribute: Wy,
      random: qy,
      snap: jy,
      normalize: (t, e, n) => Qy(t, e, 0, 1, n),
      getUnit: ky,
      clamp: (t, e, n) => Oy(n, (n) => Fy(t, e, n)),
      splitColor: lx,
      toArray: Hy,
      selector: Gy,
      mapRange: Qy,
      pipe:
        (...t) =>
        (e) =>
          t.reduce((t, e) => e(t), e),
      unitize: (t, e) => (n) => t(parseFloat(n)) + (e || ky(n)),
      interpolate: $y,
      shuffle: Vy,
    },
    install: Nv,
    effects: qv,
    ticker: px,
    updateRoot: Rx.updateRoot,
    plugins: jv,
    globalTimeline: Q_,
    core: {
      PropTween: $x,
      globals: kv,
      Tween: zx,
      Timeline: Rx,
      Animation: Ax,
      getCache: Qv,
      _removeLinkedListItem: my,
      reverting: () => Z_,
      context: (t) => (t && J_ && (J_.data.push(t), (t._ctx = J_)), J_),
      suppressOverwrites: (t) => (K_ = t),
    },
  };
  ty("to,from,fromTo,delayedCall,set,killTweensOf", (t) => (cT[t] = zx[t])),
    px.add(Rx.updateRoot),
    (rv = cT.to({}, { duration: 0 }));
  let hT = (t, e) => {
      let n = t._pt;
      for (; n && n.p !== e && n.op !== e && n.fp !== e; ) n = n._next;
      return n;
    },
    uT = (t, e) => ({
      name: t,
      rawVars: 1,
      init(t, n, i) {
        i._onInit = (t) => {
          let i, r;
          if ((gv(n) && ((i = {}), ty(n, (t) => (i[t] = 1)), (n = i)), e)) {
            for (r in ((i = {}), n)) i[r] = e(n[r]);
            n = i;
          }
          ((t, e) => {
            let n,
              i,
              r,
              s = t._targets;
            for (n in e)
              for (i = s.length; i--; )
                (r = t._ptLookup[i][n]),
                  r &&
                    (r = r.d) &&
                    (r._pt && (r = hT(r, n)),
                    r && r.modifier && r.modifier(e[n], t, s[i], n));
          })(t, n);
        };
      },
    });
  const dT =
    cT.registerPlugin(
      {
        name: "attr",
        init(t, e, n, i, r) {
          let s, a, o;
          for (s in ((this.tween = n), e))
            (o = t.getAttribute(s) || ""),
              (a = this.add(
                t,
                "setAttribute",
                (o || 0) + "",
                e[s],
                i,
                r,
                0,
                0,
                s
              )),
              (a.op = s),
              (a.b = o),
              this._props.push(s);
        },
        render(t, e) {
          let n = e._pt;
          for (; n; ) Z_ ? n.set(n.t, n.p, n.b, n) : n.r(t, n.d), (n = n._next);
        },
      },
      {
        name: "endArray",
        init(t, e) {
          let n = e.length;
          for (; n--; ) this.add(t, n, t[n] || 0, e[n], 0, 0, 0, 0, 0, 1);
        },
      },
      uT("roundProps", Xy),
      uT("modifiers"),
      uT("snap", jy)
    ) || cT;
  (zx.version = Rx.version = dT.version = "3.12.4"), (nv = 1), Mv() && fx();
  const {
    Power0: pT,
    Power1: fT,
    Power2: mT,
    Power3: gT,
    Power4: _T,
    Linear: vT,
    Quad: yT,
    Cubic: xT,
    Quart: TT,
    Quint: MT,
    Strong: ST,
    Elastic: bT,
    Back: ET,
    SteppedEase: wT,
    Bounce: AT,
    Sine: RT,
    Expo: CT,
    Circ: PT,
  } = mx;
  function LT() {
    window.localStorage.getItem("alreadyChat")
      ? YT()
      : ((document.querySelector(".startingAction").style.display = "none"),
        kd.fromTo(
          ".conversation h3 .animateNav",
          { opacity: 0 },
          {
            opacity: 1,
            stagger: 0.03,
            duration: 1.2,
            onComplete: () => {
              window.localStorage.setItem("alreadyChat", !0), I_();
            },
          }
        ),
        removeEventListener("click", LT));
  }
  async function DT(t, e, n, i, r, s) {
    const a = await (async function (t) {
      return new Promise((e, n) => {
        G_.load(
          t,
          (t) => {
            e(t.scene);
          },
          (t) => {},
          (t) => {
            n(`Error loading GLTF model: ${t}`);
          }
        );
      });
    })(t);
    return (
      a.scale.set(r, r, r),
      (a.position.x = e),
      (a.position.y = n),
      (a.position.z = i),
      { object: a, rotationIntensity: s, x: e, y: n, z: i, scale: r }
    );
  }
  kd.registerPlugin(rp),
    kd.registerPlugin(ug),
    kd.registerPlugin(rp),
    kd.registerPlugin(ug),
    b_(document.querySelector(".conversation h3"));
  const IT = [
    ' <p>Re-imagine is a web design contest by The Sheryians Coding School. It\'s all about giving Indian/International brand websites a modern makeover. Unlike other contests, we focus on making bold, fresh designs for real brands. We want students to learn by doing, with real-world examples.</p>\n  <div class="example">\n    <p class="tag">Example</p>\n    <p>Imagine your 3 favourite brands are McDonald\'s, Coca Cola, and Samsung. Choose any two of these brands and let your creativity flow. Re-imagine their website concepts with stunning details, animations, and micro-interactions. Create a responsive, awe-inspiring website for each brand. Your first submission is for Round 1, and the second is for Round 2 of the challenge.</p>\n  </div>',
    "<p>Every registered team will be welcomed to compete in round 1 of the challenge, after registering your team, you can start your preparation of reimagining and creating 2 websites for two different brands.</p>\n  <br>\n  <p>Round 1 submission goes from 1st July till 3rd July, make sure you follow these guidelines.</p>\n  <br>\n  <ol>\n    <li>Create your website and upload to github.</li>\n    <li>Make the website live with github pages, vercel or any other hosting platform </li>\n    <li>Every members will create a linkedIn post, which explains about the Re-imagine contest , teams project work and experience.</li>\n    <li>For submissions, login your Re-imagine account and submit code repo URL, live URL of your wbsite and every members linkedIn post link.</li>\n    <li>You can submit the details only once.</li>\n    <li>Dont commit anything after the deadlines, otherwise your team will be disqualified.</li>\n  </ol>",
    "<p>Every selected team will be welcomed to compete in round 2 of the challenge, if your team get selected for round 2, you can start your preparation of reimagining and creating and crafting 2nd website for the round 2 of the competition.</p>\n  <br>\n  <p>Start creating both of your websites from the start and not when your team get selected for the round 2, as there wont be much time for the round 2 of the challenge.</p>\n  <br>\n  <p>Round 2 submissions will start from 20th July till 22nd July, submit your second website before deadline and follow these deadlines :</p>\n  <br>\n  <ol>\n    <li>Create your website and upload to github.</li>\n    <li>Make the website live with github pages, vercel or any other hosting platform </li>\n    <li>Every members will create a linkedIn post, which explains about the Re-imagine contest , teams project work and experience.</li>\n    <li>For submissions, login your Re-imagine account and submit code repo URL, live URL of your wbsite and every members linkedIn post link.</li>\n    <li>You can submit the details only once.</li>\n    <li>Dont commit anything after the deadlines, otherwise your team will be disqualified.</li>\n  </ol>",
    "<p>Every team selected will be warmly welcomed to Round 3 of the challenge. If your team is chosen for Round 3, you will receive a confirmation email. Additionally, two of your top members will be invited to participate in a virtual interview round which is called round 3. They will be asked about the approach they took for website creation process, and their inspiration process, js functionalities and what they used and why.</p>\n  <br>\n  <br>\n  <p>Interview dates for your team will be shared with your team via mail and your team will be invited on the mentioned date and time.</p>",
    "<p>All of the teams who pass round 3 will be moved into the last and final round, round 4, which will be held at city of lakes, Bhopal.all of the teams who pass round 3 will be moved into the last and final round, round 4, which will be held at city of lakes, Bhopal.</p>\n  <br>\n  <p>All the teams will be invited to Bhopal city on 4th september 2024 to 5th september 2024, you will be our guest and we will take care of your hospitality, hotel rooms will be provided to the team members and the competition will start on 4th september at 1pm and will go till 6am next day.</p>\n  <br>\n  <p>Sheryians coding school will take care of the breakfast, lunch and dinner, so that students just need to work on the idea and the final output.</p>",
    ' <p>Re-imagine is a hackathon organized by The Sheryians Coding School. It aims to challenge participants to reimagine and redesign websites for real brands, fostering creativity and innovation in web design.</p>\n\n<div class="example">\n  <p class="tag">Prize Distribution</p>\n  <p>Re-imagine offers attractive prizes to recognize the top performers. Here\'s how the prizes will be distributed:</p>\n</div>\n\n<p>The total prize pool for the Re-imagine hackathon is 1.5 lakhs.</p>\n\n<ol>\n  <li>First Prize: 75,000</li>\n  <li>Second Prize: 50,000</li>\n  <li>Third Prize: 25,000</li>\n</ol>\n\n<p>Furthermore, all runner-up teams who are invited to Bhopal will be rewarded with exciting goodies and swags as a gesture of appreciation.</p>\n\n  ',
  ];
  let UT = 0;
  function NT() {
    (document.querySelector(".detail").style.display = "flex"),
      kd.to(".text .detail", {
        clipPath: "inset(0rem 0 0 0)",
        onComplete: () => {
          (document.querySelector(".text .detail").style.clipPath = "none"),
            (document.querySelector(".detail .details").innerHTML = IT[UT]),
            UT++;
        },
      });
  }
  async function OT() {
    NT();
    const t = await (async function (t = document.querySelector("#canvas")) {
        const e = { opacity: 0, objectScale: 0 },
          n = new xt();
        z_((t, e) => {
          (n.x = t), (n.y = e);
        });
        let i = [];
        var r = 1 * window.innerHeight;
        const s = new Qs(),
          a = new ri(66, window.innerWidth / r, 0.1, 1e3);
        a.position.z = 5;
        const o = [
          {
            path: "https://ik.imagekit.io/sheryians/re-imagine/calendar1_kG1zWEHpj.glb?updatedAt=1709819973648",
            initialState: {
              position: { x: -1.2, y: 1.6, z: 0 },
              opacity: 0,
              scale: { x: 0.7, y: 0.7, z: 0.7 },
              rotation: { x: 0, y: 0, z: 0 },
            },
            finalState: {
              position: { x: -1.3, y: 1.6, z: 1 },
              opacity: 1,
              scale: { x: 1, y: 1, z: 1 },
              rotation: { x: 0, y: 0.25 * Math.PI, z: 0.05 * -Math.PI },
            },
            modelAnimation: { positionRaf: "y", amplitude: 0.2 },
          },
          {
            path: "https://ik.imagekit.io/sheryians/re-imagine/loudSpeaker_Cc3xjafLO.glb?updatedAt=1709819851599",
            initialState: {
              position: { x: 1.2, y: 1.65, z: 0 },
              opacity: 0,
              scale: { x: 0.1, y: 0.1, z: 0.1 },
              rotation: { x: 0, y: 0, z: 0 },
            },
            finalState: {
              position: { x: 1.2, y: 1.8, z: 1 },
              opacity: 1,
              scale: { x: 0.2, y: 0.2, z: 0.2 },
              rotation: { x: 0, y: 0, z: 0.15 * -Math.PI },
            },
            modelAnimation: { positionRaf: "x", amplitude: 0.25 },
          },
          {
            path: "https://ik.imagekit.io/sheryians/re-imagine/fire23_1nAu26rnt.glb?updatedAt=1709819851559",
            initialState: {
              position: { x: 1, y: -0.8, z: 0 },
              opacity: 0,
              scale: { x: 0.1, y: 0.1, z: 0.1 },
              rotation: { x: 0, y: 0, z: 0 },
            },
            finalState: {
              position: { x: 1.25, y: -0.6, z: 0.9 },
              opacity: 1,
              scale: { x: 0.2, y: 0.2, z: 0.2 },
              rotation: { x: 0, y: 0, z: 0 },
            },
            modelAnimation: { rotationRaf: "y", amplitude: -0.3 },
          },
        ];
        let l;
        const c = await W_(o, s),
          h = new Js({ antialias: !0, alpha: !0, canvas: t });
        h.setSize(window.innerWidth, r),
          h.setPixelRatio(Math.min(devicePixelRatio, 2));
        const u = new Xs();
        (u.position.y = 0.75), s.add(u);
        var d = null;
        let p = 0;
        function f(t) {
          (d = requestAnimationFrame(f)),
            p || (p = t),
            t - p > 1e3 / 60 &&
              ((p = t),
              i.forEach((t) => {
                (t.rotation.y = kd.utils.interpolate(
                  t.rotation.y,
                  t.rotation.y - n.x * (k_() ? 0.75 : 0.35),
                  0.5
                )),
                  (t.rotation.x = kd.utils.interpolate(
                    t.rotation.x,
                    t.rotation.x - n.y * (k_() ? 0.75 : 0.35),
                    0.5
                  ));
              }),
              h.render(s, a));
        }
        return (
          window.addEventListener("resize", () => {
            (a.aspect = innerWidth / innerHeight),
              a.updateProjectionMatrix(),
              h.setSize(innerWidth, innerHeight),
              h.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          }),
          kd.to(e, { opacity: 1, objectScale: 1, duration: 0.75 }),
          () => (
            (l = c()),
            (i = l.models),
            (d = requestAnimationFrame(f)),
            () =>
              new Promise((t) => {
                kd.to(e, {
                  opacity: 0,
                  objectScale: 2,
                  ease: "power3.out",
                  onComplete: async () => {
                    cancelAnimationFrame(d),
                      (document.querySelector("#cards").style.display = "none"),
                      s.clear(),
                      h.clear(),
                      kd.ticker.remove(),
                      await l.cleanupMiniModels(),
                      t();
                  },
                });
              })
          )
        );
      })(),
      e = t(),
      n = new xt();
    0 == HT
      ? document.querySelector(".videoContainer").classList.add("landscape")
      : document.querySelector(".videoContainer").classList.remove("landscape");
    const i = z_((t, e) => {
      (n.x = t),
        (n.y = e),
        k_() ||
          (document.querySelector(
            ".videoContainer"
          ).style.transform = `translate(${-50 - 4 * n.x}%,${
            -50 - 2 * n.y
          }%) rotateX(${30 * n.y}deg) rotateY(${20 * n.x}deg)`);
    });
    return (
      (document.querySelector(".videoContainer .videoWrapper").style.display =
        "flex"),
      (document.querySelector(".videoContainer").style.display = "flex"),
      document
        .querySelector(".videoContainer .videoWrapper")
        .classList.remove("playing"),
      document
        .querySelector(".videoContainer video")
        .setAttribute("src", BT[HT]),
      document
        .querySelector(".videoContainer video")
        .setAttribute("poster", zT[HT]),
      document.querySelector(".videoContainer video").pause(),
      kd.fromTo(
        ".videoContainer .videoWrapper",
        { scale: 0.75, opacity: 0 },
        { opacity: 1, scale: 1, ease: "power3.out", duration: 1 }
      ),
      () => (
        kd.to(".text .detail", {
          clipPath: "inset(4rem 0 0 0)",
          onComplete: () => {
            document.querySelector(".detail").style.display = "none";
          },
        }),
        HT++,
        new Promise(async (t) => {
          document.querySelector(".videoContainer video").pause(),
            document.querySelector(".videoContainer").classList.add("playing"),
            await e(),
            i(),
            kd.to(".videoContainer .videoWrapper", {
              scale: 1.5,
              opacity: 0,
              duration: 1,
              ease: "power3.inOut",
              onComplete: async () => {
                (document.querySelector(
                  ".videoContainer .videoWrapper"
                ).style.display = "none"),
                  t();
              },
            });
        })
      )
    );
  }
  function FT(t) {
    const e = 0.09 * t.length * 2.5;
    return (
      setTimeout(() => {
        document.querySelectorAll(".animate").forEach((t) => {
          t.style.animation = `marquee ${e}s linear infinite`;
        });
      }, 0),
      `\n    <div class="marquee">\n      <h1 class="animate">${t} ${t}</h1>\n      <h1 class="animate">${t} ${t}</h1>\n      <div class="animateMarquee">\n        <h1 class="animate">${t} ${t}</h1>\n        <h1 class="animate">${t} ${t}</h1>\n      </div>\n    </div>`
    );
  }
  const kT = [
      [
        () => '<h1 class="heading">Re-Imagine</h1>',
        "Elevate your code at Web Hackathon",
        "Enrollment Closed",
        "Show some magic.",
        { backgroundColor: "#09b94c", color: "#ffffff" },
      ],
      [
        () =>
          FT(
            "Front end competition &#160;Create Modern Websites &#160;HTML CSS JS &#160;GSAP Scroll-trigger Locomotive.js &#160;"
          ),
        "make your team and participate",
        "Enrollment Closed",
        "Interesting, next.",
        { backgroundColor: "#df1029", color: "#ffffff" },
      ],
      [
        () =>
          FT(
            "Pick 2 brands &#160;Re-imagine their websites &#160;make better interfaces &#160;"
          ),
        "Re-imagine and code your 2 favourite brands",
        "Enrollment Closed",
        "Interesting, next.",
        { backgroundColor: "#ffcc00", color: "#000000" },
      ],
      [
        () =>
          FT(
            "Understand the competition &#160;What is Re-imagine ? &#160;Understand the competition &#160;What is Re-imagine ? &#160;"
          ),
        "understand, create, win.",
        "Enrollment Closed",
        "Amazing, move next.",
        { backgroundColor: "#062AE7", color: "#FFFFFF" },
      ],
      [
        () =>
          FT(
            "Round 1 &#160;first round &#160;first brand Re-imagine &#160;first round &#160;"
          ),
        "coding first brands website",
        "Enrollment Closed",
        "Amazing, move next.",
        { backgroundColor: "#062AE7", color: "#FFFFFF" },
      ],
      [
        () =>
          FT(
            "second round &#160;Second brand re-imagine &#160;second round &#160;Second brand re-imagine &#160;"
          ),
        "coding second brands website",
        "Enrollment Closed",
        "Great, move next.",
        { backgroundColor: "#F24E09", color: "#FFFFFF" },
      ],
      [
        () =>
          FT(
            "Third Round &#160;virtual interview &#160;Third round &#160;virtual interview &#160;"
          ),
        "2 members will be invited for virtual talk",
        "Enrollment Closed",
        "Fantastic, move next.",
        { backgroundColor: "#F24E09", color: "#FFFFFF" },
      ],
      [
        () =>
          FT(
            "Fourth Round &#160;Bhopal Awaits &#160;Fourth Round &#160;Bhopal Awaits &#160;"
          ),
        "you will be invited to the city of lakes, Bhopal.",
        "Enrollment Closed",
        "move Next,",
        { backgroundColor: "#e10025", color: "#FFFFFF" },
      ],
      [
        () =>
          FT(
            "1,50,000 Cash Prizes&#160;Goodies&#160;Swags&#160;Certificates&#160;"
          ),
        "for more details see more details below.",
        "Enrollment Closed",
        "Interesting, Next.",
        { backgroundColor: "#F24E09", color: "#FFFFFF" },
      ],
    ],
    zT = [
      "https://sheryians.b-cdn.net/sddefault.jpg",
      "https://sheryians.b-cdn.net/Screenshot%202024-03-21%20at%209.01.59%E2%80%AFPM-min.png",
      "https://sheryians.b-cdn.net/Screenshot%202024-03-21%20at%209.03.37%E2%80%AFPM-min.png",
      "https://sheryians.b-cdn.net/Screenshot%202024-03-21%20at%209.04.53%E2%80%AFPM-min.png",
      "https://sheryians.b-cdn.net/Screenshot%202024-03-21%20at%209.05.25%E2%80%AFPM-min.png",
    ],
    BT = [
      "https://sheryians.b-cdn.net/WHATISREshort.mp4",
      "https://sheryians.b-cdn.net/R1Compressed.mp4",
      "https://sheryians.b-cdn.net/R2Compressed.mp4",
      "https://sheryians.b-cdn.net/R3Compressed.mp4",
      "https://sheryians.b-cdn.net/R4Compressed.mp4",
    ];
  let HT = 0;
  const GT = [
    (t = document.querySelector("#canvas")) =>
      new Promise((e) => {
        const n = { width: window.innerWidth, height: window.innerHeight };
        let i,
          r,
          s,
          a,
          o,
          l,
          c,
          h,
          u,
          d,
          p,
          f,
          m,
          g = [];
        (p = new xt()),
          z_((t, e) => {
            (p.x = t * (k_() ? 0.5 : 0.4)), (p.y = e * (k_() ? 0.5 : 0.4));
          });
        const _ = [
          {
            path: "https://ik.imagekit.io/sheryians/re-imagine/calendar1_kG1zWEHpj.glb?updatedAt=1709819973648",
            initialState: {
              position: { x: 0, y: 0, z: 0 },
              opacity: 0,
              scale: { x: 0, y: 0, z: 0 },
              rotation: { x: 0, y: 0, z: 0 },
            },
            finalState: {
              position: { x: 0.2, y: 2.4, z: -3.5 },
              opacity: 1,
              scale: { x: 1.7, y: 1.7, z: 1.7 },
              rotation: {
                x: 5 * Math.PI + 1.3 * Math.PI,
                y: 1.65 * Math.PI,
                z: 0.1 * -Math.PI,
              },
            },
            modelAnimation: { positionRaf: "y", amplitude: 1 },
          },
          {
            path: "https://ik.imagekit.io/sheryians/re-imagine/loudSpeaker_Cc3xjafLO.glb?updatedAt=1709819851599",
            initialState: {
              position: { x: 0, y: 0, z: 0 },
              opacity: 0,
              scale: { x: 0, y: 0, z: 0 },
              rotation: { x: 0, y: 0, z: 0 },
            },
            finalState: {
              position: { x: -4.25, y: 2, z: 0 },
              opacity: 1,
              scale: { x: 0.3, y: 0.3, z: 0.3 },
              rotation: {
                x: Math.PI / 6,
                y: 1.2 * Math.PI + 2 * Math.PI,
                z: 0,
              },
            },
            modelAnimation: { positionRaf: "z", amplitude: 0.8 },
          },
          {
            path: "https://ik.imagekit.io/sheryians/re-imagine/fire23_1nAu26rnt.glb?updatedAt=1709819851559",
            initialState: {
              position: { x: 0, y: 0, z: 0 },
              opacity: 0,
              scale: { x: 0, y: 0, z: 0 },
              rotation: { x: 0, y: 0, z: 0 },
            },
            finalState: {
              position: { x: -4.9, y: 1, z: -2.5 },
              opacity: 1,
              scale: { x: 0.3, y: 0.3, z: 0.3 },
              rotation: {
                x: Math.PI / 6,
                y: 1.2 * Math.PI + 2 * Math.PI,
                z: 0,
              },
            },
            modelAnimation: { rotationRaf: "y", amplitude: 1.5 },
          },
        ];
        function v(t, e, n, i) {
          for (let r = 0; r < n; r++) {
            const s = t.clone(),
              o = new Kn(s, e);
            if (i)
              o.scale.set(1, 1, 1),
                (o.rotation.y = (-r / 100) * r),
                (o.position.y = (r / 7) * 1.5),
                x(s, "x", r / 30),
                x(s, "y", r / 30),
                setTimeout(() => {
                  a.remove(o), s.dispose();
                }, i);
            else {
              o.scale.set(1, 0, 0),
                kd.to(o.rotation, {
                  delay: 0.5,
                  y: (-r / 100) * r,
                  duration: 1,
                  ease: bu.easeInOut,
                });
              let l = null,
                c = 0,
                h = 10;
              function u(t) {
                c || (c = t),
                  t - c > 1e3 / h &&
                    ((c = t), x(s, "x", 0.005 * r), x(s, "y", 0.002 * r)),
                  (l = requestAnimationFrame(u));
              }
              (l = requestAnimationFrame(u)),
                setTimeout(() => {
                  cancelAnimationFrame(l);
                }, 1e3),
                kd.to(o.position, {
                  delay: 0.5,
                  y: (r / 7) * 1.5,
                  duration: 1,
                  ease: mT.easeInOut,
                }),
                kd.to(o.scale, {
                  delay: 0.5,
                  x: 1,
                  y: 1,
                  z: 1,
                  duration: 0.7,
                  ease: bu.easeInOut,
                }),
                g.push(o);
            }
            (o.castShadow = !0), (o.receiveShadow = !0), a.add(o);
          }
        }
        function y() {
          return new Promise((t) => {
            kd.to("#ticketBackground", { opacity: 0 }),
              g.forEach((e) => {
                kd.to(l, { intensity: 0, duration: 1 }),
                  kd.to(c, { intensity: 0, duration: 1 }),
                  kd.to(o, { intensity: 0, duration: 1 }),
                  kd.to(u, { intensity: 0, duration: 1 }),
                  kd.to(h, { delay: 0.2, intensity: 1, duration: 0.5 }),
                  kd.to(h.position, { y: 1.8, duration: 2, ease: bu.easeIn }),
                  kd.to(h.position, { x: 4, duration: 4, ease: bu.easeInOut }),
                  m.cleanupMiniModels(),
                  kd.to("#canvas", {
                    background:
                      "radial-gradient(circle at 50% 40%, rgba(216, 151, 0, 0),transparent, transparent)",
                    duration: 1,
                    delay: 0.4,
                  }),
                  kd.to(h, {
                    delay: 3,
                    intensity: 0,
                    duration: 1,
                    onComplete: () => {
                      a.remove(e),
                        e.geometry.dispose(),
                        e.material.dispose(),
                        i.remove(o, l, c, h, u),
                        o.dispose(),
                        l.dispose(),
                        c.dispose(),
                        h.dispose(),
                        u.dispose(),
                        s.dispose(),
                        window.removeEventListener("resize", d),
                        cancelAnimationFrame(T);
                      const n = document.querySelector(".startingAction");
                      (n.style.paddingBottom = "min(8vh, 9rem)"),
                        n.querySelectorAll("button").forEach((t) => {
                          (t.style.padding =
                            innerWidth > 600 ? "1rem 1.5rem" : "0.8rem 1rem"),
                            (t.style.fontSize =
                              innerWidth > 600 ? "1.2rem" : "1rem");
                        }),
                        (document.querySelector(
                          ".effectText .text"
                        ).style.height =
                          window.innerWidth < 600
                            ? "min(35vh, max(15rem, 30vh))"
                            : "min(40vh, max(20rem, 35vh))"),
                        (document.querySelector(
                          ".effectText .heading"
                        ).style.transform = "initial"),
                        (document.querySelector(
                          "#ticketBackground"
                        ).style.display = "none"),
                        t();
                    },
                  });
              });
          });
        }
        function x(t, e, n) {
          let i = 0;
          if (0 !== n) {
            const r = t.attributes.position.array;
            for (let t = 0; t < r.length; t += 3) {
              let s = r[t],
                a = r[t + 1],
                o = r[t + 2];
              i = "x" === e ? o * n : s * n;
              let l = Math.sin(i),
                c = Math.cos(i);
              switch (e) {
                case "x":
                  (r[t] = s),
                    (r[t + 1] = (a - 1 / n) * c + 1 / n),
                    (r[t + 2] = -(a - 1 / n) * l);
                  break;
                case "y":
                  (r[t] = -(o - 1 / n) * l),
                    (r[t + 1] = a),
                    (r[t + 2] = (o - 1 / n) * c + 1 / n);
                  break;
                default:
                  (r[t] = -(a - 1 / n) * l),
                    (r[t + 1] = (a - 1 / n) * c + 1 / n),
                    (r[t + 2] = o);
              }
            }
            t.attributes.position.needsUpdate = !0;
          }
        }
        var T;
        const M = 0.03;
        let S = 0;
        function b(t) {
          S || (S = t),
            t - S > 1e3 / 45 &&
              ((S = t),
              (a.rotation.y = kd.utils.interpolate(
                a.rotation.y,
                a.rotation.y + p.x,
                M
              )),
              (a.rotation.x = kd.utils.interpolate(
                a.rotation.x,
                a.rotation.x + p.y,
                M
              )),
              (a.position.x = kd.utils.interpolate(
                a.position.x,
                a.position.x + 5 * p.x,
                M
              )),
              (a.position.y = kd.utils.interpolate(
                a.position.y,
                a.position.y - 5 * p.y,
                M
              )),
              m &&
                m.models[0] &&
                m.models.forEach((t) => {
                  (t.rotation.y = kd.utils.interpolate(
                    t.rotation.y,
                    t.rotation.y - 0.75 * p.x,
                    0.5
                  )),
                    (t.rotation.x = kd.utils.interpolate(
                      t.rotation.x,
                      t.rotation.x - 0.75 * p.y,
                      0.5
                    ));
                }),
              s.render(i, r)),
            (T = window.requestAnimationFrame(b));
        }
        !(async function () {
          (i = new Qs()),
            new qo(5),
            (r = new ri(85, n.width / n.height, 0.1, 100)),
            r.rotation.set(-0.08, 0.0251327412287183, -0.358141562509236),
            k_() ? r.position.set(-1, -0.2, 9) : r.position.set(-0.3, -0.2, 8),
            i.add(r),
            (s = new Js({ alpha: !0, canvas: t, antialias: !0 })),
            (s.shadowMap.enabled = !0),
            (s.outputColorSpace = q),
            s.setSize(n.width, n.height),
            s.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)),
            (a = new Xs()),
            a.rotation.set(
              0.955044166691297,
              2.1865484868985,
              -0.207345115136926
            ),
            a.position.set(0, 2.18752202305694, 0),
            i.add(a),
            (f = await W_(_, a, 0.3)),
            (d = window.addEventListener("resize", () => {
              (n.width = window.innerWidth),
                (n.height = window.innerHeight),
                (r.aspect = n.width / n.height),
                r.updateProjectionMatrix(),
                s.setSize(n.width, n.height),
                s.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            })),
            (function () {
              const t = new Ig(),
                n = new N_();
              n.setDecoderConfig({ type: "js" }),
                n.setDecoderPath("https://www.gstatic.com/draco/v1/decoders/"),
                t.setDRACOLoader(n),
                t.load(
                  "https://ik.imagekit.io/sheryians/re-imagine/tick53_KOtA2uz_b.glb?updatedAt=1710336508972",
                  (t) => {
                    (t.scene.children[0].children[0].material.metalness = 0.4),
                      (t.scene.children[0].children[0].material.roughness = 0.7),
                      (t.scene.children[0].children[0].material.map.colorSpace =
                        q),
                      v(
                        t.scene.children[0].children[0].geometry,
                        t.scene.children[0].children[0].material,
                        7,
                        3500
                      ),
                      v(
                        t.scene.children[0].children[1].geometry,
                        t.scene.children[0].children[1].material,
                        7,
                        3500
                      ),
                      setTimeout(() => {
                        a.position.set(5, 5, -10),
                          kd.to(a.position, {
                            z: 0,
                            x: 0,
                            y: 2.18752202305694,
                            duration: 1.5,
                            ease: bu.easeInOut,
                          }),
                          kd.to(l, { intensity: 1, duration: 0.5 }),
                          kd.to(c, { intensity: 1, duration: 0.5 }),
                          kd.to(u, { intensity: 1.5, duration: 0.5 }),
                          kd.to("#canvas", {
                            background:
                              "radial-gradient(circle at 50% 40%, rgba(0, 194, 65, 0.18), transparent)",
                            duration: 1,
                            delay: 0.4,
                          }),
                          kd.to("#ticketBackground", {
                            opacity: 0.3,
                            delay: 0.7,
                          }),
                          e(y),
                          (m = f()),
                          v(
                            t.scene.children[0].children[0].geometry,
                            t.scene.children[0].children[0].material,
                            7
                          ),
                          v(
                            t.scene.children[0].children[1].geometry,
                            t.scene.children[0].children[1].material,
                            7
                          );
                      }, 3500);
                  }
                );
            })(),
            (o = new No(16777215, 0)),
            (l = new Uo(16777215, 0)),
            (l.castShadow = !k_()),
            (l.shadow.bias = -1e-4),
            (l.shadow.mapSize.width = 2048),
            (l.shadow.mapSize.height = 2048),
            l.rotation.set(0, 0, 0.182212373908208),
            l.position.set(-53.7, 66.6, 94.3),
            (c = new Uo(16777215, 0)),
            (c.castShadow = !k_()),
            (c.shadow.bias = -1e-4),
            (c.shadow.mapSize.width = 2048),
            (c.shadow.mapSize.height = 2048),
            c.position.set(8.9, 10.9, 3.5),
            (h = new Do(16777215, 1)),
            (h.castShadow = !0),
            (h.shadow.bias = -1e-4),
            (h.shadow.mapSize.width = 2048),
            (h.shadow.mapSize.height = 2048),
            h.position.set(15, 2.32, 2.3),
            (u = new Do(16777215, 0)),
            (u.castShadow = !0),
            (u.shadow.bias = -1e-4),
            (u.shadow.mapSize.width = 2048),
            (u.shadow.mapSize.height = 2048),
            u.position.set(1.3, 2.7, 2.9),
            i.add(o, l, c, h, u),
            kd.to(h.position, {
              x: -8,
              duration: 5,
              ease: bu.easeOutCirc,
              onComplete: () => {},
            }),
            kd.to(h.position, {
              delay: 1,
              y: 20,
              duration: 5,
              ease: bu.easeInOut,
              onComplete: () => {
                (h.intensity = 0), h.position.set(-2.6, 2.4, 3.1);
              },
            }),
            b();
        })();
      }),
    function () {
      k_() &&
        DeviceMotionEvent &&
        "function" == typeof DeviceMotionEvent &&
        F_();
      const t = {
          rotationRate: 0.3,
          scale: 0.7,
          opacity: 0,
          threshold: 1e-4,
          strength: 0.4,
        },
        e = document.querySelector("#canvas");
      var n = window.innerHeight;
      const i = new Qs(),
        r = new ri(66, window.innerWidth / n, 0.1, 1e3);
      r.position.z = 5;
      const s = new Js({ canvas: e });
      s.setSize(window.innerWidth, n),
        s.setPixelRatio(Math.min(devicePixelRatio, 2)),
        (s.autoClear = !0);
      const a = new Cg(i, r),
        o = new Rg(s);
      let l = new Lg(new xt(window.innerWidth, n), 0.35, 1.6, 5e-4);
      o.setSize(window.innerWidth, n), o.addPass(a), o.addPass(l);
      const c = new Wa(1.25, 1.25, 1.25, 64, 32, !0, 0, (2 * Math.PI) / 3.2),
        h = Y_(
          c,
          "https://ik.imagekit.io/sheryians/re-imagine/333_1HGllmdhx.png?updatedAt=1710335805066"
        ),
        u = Y_(
          c,
          "https://ik.imagekit.io/sheryians/re-imagine/temp63_5YmSbIO1q.png?updatedAt=1710336272838"
        ),
        d = Y_(
          c,
          "https://ik.imagekit.io/sheryians/re-imagine/Screenshot%20(27)_6GjTJqVDF.png?updatedAt=1710336272642"
        ),
        p = new Xs();
      i.add(p),
        p.add(h),
        p.add(u),
        p.add(d),
        (u.rotation.y += (2 * Math.PI) / 3),
        (d.rotation.y += ((2 * Math.PI) / 3) * 2),
        (p.rotation.z -= 0.05 * Math.PI),
        (p.position.z -= 0.45),
        innerWidth < 600 && ((p.position.y += 0.5), (r.position.z -= 1.3)),
        k_() || (r.position.z = 3),
        (p.position.y += 0.34),
        z_((t, e) => {
          k_() || (p.rotation.y += 0.15 * t),
            (p.position.x += 0.03 * t),
            (p.rotation.x +=
              e *
              (k_() ? 0.1 : 0.04) *
              ((function () {
                const t = navigator.userAgent.toLowerCase();
                return (
                  /iphone|ipod|ipad/i.test(t) ||
                  (t.includes("crios") && "applewebkit" in navigator)
                );
              })()
                ? -1
                : 1)),
            (p.position.y -= 0.01 * e);
        });
      const f = 1e3 / 30;
      let m = 0;
      p.scale.set(t.scale, t.scale, t.scale),
        kd.to(t, {
          scale: 1,
          rotationRate: 0.01,
          opacity: 1,
          duration: 1.3,
          ease: "expo.inOut",
        });
      var g = requestAnimationFrame(function e(n) {
        const i = n - m;
        i >= f &&
          ((m = n - (i % f)),
          (q_.x *= 0.9),
          (l.threshold = t.threshold),
          (l.strength = t.strength),
          p.traverse((e) => {
            e.material &&
              ((e.material.uniforms.uOpacity.value = t.opacity),
              (e.material.transparent = !0));
          }),
          p.scale.set(t.scale, t.scale, t.scale),
          (p.rotation.y += t.rotationRate),
          o.render()),
          (g = requestAnimationFrame(e));
      });
      function _() {
        const t = window.innerWidth,
          e = window.innerHeight;
        (r.aspect = t / e),
          r.updateProjectionMatrix(),
          s.setPixelRatio(devicePixelRatio),
          s.setSize(t, e);
      }
      return (
        window.addEventListener("resize", _),
        function () {
          return new Promise((e) => {
            kd.to(t, {
              rotationRate: 0.25,
              duration: 0.8,
              scale: 1.5,
              opacity: 0,
              ease: Eu.easeInOut,
              onComplete: () => {
                p.traverse((t) => {
                  t.geometry && (t.material.dispose(), t.geometry.dispose());
                }),
                  s.clear(),
                  cancelAnimationFrame(g),
                  window.removeEventListener("resize", _),
                  e();
              },
            });
          });
        }
      );
    },
    async function () {
      let t = {
          opacity: 0,
          scale: 0.75,
          objectScale: 0,
          cards: document.querySelector("#cards"),
        },
        e = { progress: 0.5 };
      var n = 1 * window.innerHeight;
      const i = new xt();
      z_((t, e) => {
        (i.x = 0.6 * t), (i.y = 0.6 * e);
      });
      const r = new Qs(),
        s = new ri(66, window.innerWidth / n, 0.1, 1e3);
      s.position.z = 3;
      const a = document.querySelector("#canvas"),
        o = new Js({ antialias: !0, transparent: !0, canvas: a });
      o.setSize(window.innerWidth, n),
        o.setPixelRatio(Math.min(devicePixelRatio, 2)),
        o.setClearColor(0, 0),
        (o.autoClear = !0);
      const l = new Xs();
      l.position.y = 0.75;
      const c = [];
      r.add(l);
      const h = await DT(
          "https://ik.imagekit.io/sheryians/re-imagine/calendar1_kG1zWEHpj.glb?updatedAt=1709819973648",
          -0.45,
          -0.1,
          0.9,
          0.45,
          0.3
        ),
        u = await DT(
          "https://ik.imagekit.io/sheryians/re-imagine/loudSpeaker_Cc3xjafLO.glb?updatedAt=1709819851599",
          0.6,
          0.15,
          0.5,
          0.1,
          0.8
        ),
        d = await DT(
          "https://ik.imagekit.io/sheryians/re-imagine/fire23_1nAu26rnt.glb?updatedAt=1709819851559",
          0.52,
          -0.85,
          1,
          0.1,
          k_() ? -0.1 : 1.7
        );
      c.push(h),
        c.push(u),
        c.push(d),
        l.rotation.x,
        Math.PI,
        l.add(h.object),
        l.add(u.object),
        l.add(d.object),
        (d.object.rotation.y -= Math.PI / 2),
        (function (t, e) {
          const n = document.getElementById("cardCenter"),
            i = document.getElementById("cards");
          if (n && i) {
            const t = i.offsetWidth,
              e = n.offsetWidth,
              r = n.offsetLeft + e / 2 - t / 2;
            return i.scrollTo(r, 0), r;
          }
          console.error(
            "Child or parent element with the provided ID not found."
          );
        })();
      var p = (function (t) {
        var n = null;
        document.querySelector(".conversation").style.display = "none";
        let i = 0;
        const r = new Gt(0, 0, 0, 0);
        addEventListener("mousemove", (t) => {
          (r.z = -(innerWidth / 2 - t.clientX) / innerWidth),
            (r.w = (innerHeight / 2 - t.clientY) / innerHeight);
        });
        const s = document.querySelectorAll(".card"),
          a = document.querySelector("#cards");
        var o = kd.utils.snap([0, 0.5, 1]);
        const l = { x: 0, y: 0 };
        return (
          (n = requestAnimationFrame(function t() {
            k_() ||
              (document.querySelector(".cards").style.transform = `translate(${
                -1 * r.x
              }%,${-1 * r.y}%) rotateX(${13 * r.y}deg) rotateY(${
                11 * r.x
              }deg)`),
              (r.x = kd.utils.interpolate(r.x, r.z, 0.1)),
              (r.y = kd.utils.interpolate(r.y, r.w, 0.1));
            const c =
              (a.scrollLeft /
                (a.scrollWidth + s[0].getBoundingClientRect().width)) *
              2;
            var h;
            (h = c), (e.progress = h);
            const u = o(c);
            (i = 80 * u + (u * a.scrollWidth) / 2),
              s.forEach((t, e) => {
                const n = t.getBoundingClientRect();
                let i = innerWidth / 2 - (n.left + n.width / 2);
                Math.sign(i),
                  (i = 1 - Math.max(((Math.abs(i) / n.width) * 1.1) / 3.5, 0));
                const r = Math.max(i, 0.75);
                t.style.transform = `translate(0,0) scale(${r})`;
              }),
              (l.x = kd.utils.interpolate(a.scrollLeft, i, 0.05)),
              (n = requestAnimationFrame(t));
          })),
          () => {
            n && cancelAnimationFrame(n);
          }
        );
      })();
      const f = 1e3 / 60;
      let m = 0;
      var g = requestAnimationFrame(function n(a) {
        g = requestAnimationFrame(n);
        const l = a - m;
        l >= f &&
          ((m = a - (l % f)),
          c.forEach((n) => {
            n.object.traverse((e) => {
              e.material &&
                ((e.material.transparent = !0),
                (e.material.opacity = t.opacity));
            }),
              (n.object.rotation.y = kd.utils.interpolate(
                n.object.rotation.y,
                e.progress * n.rotationIntensity * 14 + 6 * i.x,
                0.1
              )),
              (n.object.rotation.x = kd.utils.interpolate(
                n.object.rotation.x,
                e.progress * n.rotationIntensity * 0.05 + 6 * i.x,
                0.1
              )),
              (n.object.position.x = kd.utils.interpolate(
                n.object.position.x,
                n.object.position.x + 0.1 * i.x,
                0.1
              )),
              (n.object.position.y = kd.utils.interpolate(
                n.object.position.y,
                n.object.position.y + 0.1 * i.y,
                0.1
              )),
              n.object.scale.set(
                n.scale * t.objectScale,
                n.scale * t.objectScale,
                n.scale * t.objectScale
              );
          }),
          (t.cards.style.opacity = t.opacity),
          (t.cards.style.scale = t.scale),
          o.clear(),
          o.render(r, s));
      });
      function _() {
        const t = window.innerWidth,
          e = 1 * window.innerHeight;
        (s.aspect = t / e),
          s.updateProjectionMatrix(),
          o.setPixelRatio(devicePixelRatio),
          o.setSize(t, e);
      }
      return (
        kd.to(t, {
          opacity: 1,
          scale: 1,
          duration: 0.75,
          objectScale: 1,
          ease: "power3.out",
        }),
        window.addEventListener("resize", _),
        function () {
          return new Promise((e) => {
            p(),
              kd.to(t, {
                opacity: 0,
                scale: 1.5,
                duration: 0.75,
                objectScale: 2,
                ease: "power3.out",
                onComplete: () => {
                  removeEventListener("resize", _),
                    cancelAnimationFrame(g),
                    (document.querySelector("#cards").style.display = "none"),
                    c.forEach((t) => {
                      t.object.traverse((t) => {
                        t.geometry &&
                          (t.material.dispose(), t.geometry.dispose());
                      });
                    }),
                    r.clear(),
                    o.clear(),
                    kd.ticker.remove(),
                    e();
                },
              });
          });
        }
      );
    },
    OT,
    OT,
    OT,
    OT,
    OT,
    async function () {
      return new Promise(async (t) => {
        const e = {
            initialState: {
              position: { x: 1, z: -5, y: 0.5 },
              rotation: { x: 0.5 * Math.PI, y: 0.5 * Math.PI, z: 0 },
              opacity: 0,
            },
            finaleState: {
              position: { x: 0, z: 0.5, y: 0 },
              rotation: {
                x: 0.02 * Math.PI,
                y: 0.15 * -Math.PI,
                z: 0.03 * -Math.PI,
              },
              opacity: 1,
            },
            duration: 1,
            ease: "power3.inOut",
          },
          n = [
            {
              path: "https://ik.imagekit.io/sheryians/re-imagine/calendar1_kG1zWEHpj.glb?updatedAt=1709819973648",
              initialState: {
                position: { x: 1, z: -5, y: 0.5 },
                opacity: 0,
                scale: { x: 0.2, y: 0.2, z: 0 },
                rotation: { x: 0, y: 0, z: 0 },
              },
              finalState: {
                position: { x: -1, y: 0.5, z: 1.5 },
                opacity: 1,
                scale: { x: 0.78, y: 0.78, z: 0.78 },
                rotation: { x: 0.1 * Math.PI, y: 0.4 * Math.PI, z: 0 },
              },
              modelAnimation: { positionRaf: "y", amplitude: 0.2 },
            },
            {
              path: "https://ik.imagekit.io/sheryians/re-imagine/loudSpeaker_Cc3xjafLO.glb?updatedAt=1709819851599",
              initialState: {
                position: { x: 1, z: -5, y: 0.5 },
                opacity: 0,
                scale: { x: 0, y: 0, z: 0 },
                rotation: { x: 0, y: 0, z: 0 },
              },
              finalState: {
                position: { x: 0.9, y: 0.4, z: 1.3 },
                opacity: 1,
                scale: { x: 0.2, y: 0.2, z: 0.2 },
                rotation: { x: 0, y: 0.1 * Math.PI, z: 0.2 * -Math.PI },
              },
              modelAnimation: { positionRaf: "x", amplitude: 0.25 },
            },
            {
              path: "https://ik.imagekit.io/sheryians/re-imagine/fire23_1nAu26rnt.glb?updatedAt=1709819851559",
              initialState: {
                position: { x: 1, z: -5, y: 0.5 },
                opacity: 0,
                scale: { x: 0.2, y: 0.2, z: 0.2 },
                rotation: { x: 0, y: 0, z: 0 },
              },
              finalState: {
                position: { x: 0.78, y: -1.3, z: 0.8 },
                opacity: 1,
                scale: { x: 0.2, y: 0.2, z: 0.42 },
                rotation: { x: 0, y: 0, z: 0.1 * Math.PI },
              },
              modelAnimation: { rotationRaf: "y", amplitude: -0.3 },
            },
          ],
          i = new Gt(),
          r =
            (z_((t, e) => {
              (i.x = 0.9 * t), (i.y = 0.9 * e);
            }),
            new Ig()),
          s = new N_();
        s.setDecoderConfig({ type: "js" }),
          s.setDecoderPath("https://www.gstatic.com/draco/v1/decoders/"),
          r.setDRACOLoader(s);
        var a = window.innerHeight;
        const o = new Qs(),
          l = new Xs();
        o.add(l);
        const c = new ri(66, window.innerWidth / a, 0.1, 1e3);
        c.position.z = 5;
        const h = document.querySelector("#canvas"),
          u = new Js({ antialias: !0, transparent: !0, canvas: h });
        u.setSize(window.innerWidth, a),
          u.setPixelRatio(Math.min(devicePixelRatio, 2)),
          u.setClearColor(0, 0),
          (u.autoClear = !0);
        let d,
          p = null;
        const f = await W_(n, l, 0.1, !0);
        r.load(
          "https://ik.imagekit.io/sheryians/re-imagine/trophy_uS22_N0wz.glb?updatedAt=1710336416884",
          (n) => {
            n.scene.traverse(async (t) => {
              t.isMesh &&
                ((p = t),
                p.position.copy(e.initialState.position),
                p.rotation.set(
                  e.initialState.rotation.x,
                  e.initialState.rotation.y,
                  1
                ),
                (p.material.transparent = !0),
                (p.material.opacity = e.initialState.opacity),
                l.add(p),
                kd.to(p.position, {
                  x: e.finaleState.position.x,
                  y: e.finaleState.position.y,
                  z: e.finaleState.position.z,
                  duration: e.duration,
                  ease: e.ease,
                }),
                kd.to(p.rotation, {
                  x: e.finaleState.rotation.x,
                  y: e.finaleState.rotation.y,
                  z: e.finaleState.rotation.z,
                  duration: e.duration,
                  ease: e.ease,
                }),
                kd.to(p.material, {
                  opacity: e.finaleState.opacity,
                  duration: e.duration,
                  ease: e.ease,
                }),
                kd.to("#canvas", {
                  background:
                    "radial-gradient(circle at 50% 40%, rgba(216, 151, 0, 0.18),transparent, transparent)",
                  duration: 1,
                  delay: 0.3,
                }),
                (d = f()));
            }),
              (document.querySelector(".next.start").style.display = "none"),
              (document.querySelector(".staringButton").style.justifyContent =
                "center"),
              NT(),
              t(_);
          }
        );
        const m = 1e3 / 60;
        let g = 0;
        async function _() {
          await d.cleanupMiniModels(),
            (document.querySelector(".teamForm").style.display = "flex");
        }
        (l.position.y = 0.5),
          requestAnimationFrame(function t(e) {
            const n = performance.now() / 1e3;
            requestAnimationFrame(t);
            const r = e - g;
            r >= m &&
              ((g = e - (r % m)),
              u.render(o, c),
              (l.position.y += 5e-4 * Math.sin(n)),
              (l.rotation.y += 2e-4 * i.x),
              (l.rotation.x += 2e-4 * i.y),
              (l.position.y -= 0.05 * i.y),
              (l.position.x += 0.05 * i.x),
              d &&
                d.models.forEach((t) => {
                  (t.rotation.y += 0.1 * i.x),
                    (t.rotation.x += 0.1 * i.y),
                    (t.position.y -= 0.01 * i.y),
                    (t.position.x += 0.01 * i.x);
                }));
          }),
          window.addEventListener("resize", function () {
            const t = window.innerWidth,
              e = window.innerHeight;
            (c.aspect = t / e),
              c.updateProjectionMatrix(),
              u.setPixelRatio(devicePixelRatio),
              u.setSize(t, e);
          });
      });
    },
  ];
  let VT = 0,
    WT = -1,
    XT = null;
  var jT = {};
  function qT(t) {
    return new Promise((e) => {
      t.to("button.next", {
        clipPath: "polygon(100% 0%, 100% 0%, 100% 100%, 100% 100%)",
        transform: "translate3d(0,0,100px)",
        duration: jT.outDuration,
        onComplete: () => {
          try {
            document.documentElement.style.setProperty(
              "--borderRadius",
              "0.5rem"
            ),
              document.documentElement.style.setProperty(
                "--buttonFontSize",
                "1rem"
              ),
              (document.querySelector("button.next").style.backgroundColor =
                kT[WT][kT[WT].length - 1].backgroundColor),
              (document.querySelector("button.next").style.color =
                kT[WT][kT[WT].length - 1].color),
              document.querySelectorAll(".effectTExtChild").forEach((t, e) => {
                t.innerHTML = 0 == e ? kT[WT][e]() : kT[WT][e];
              }),
              document.querySelectorAll("button.start").forEach((t, e) => {
                t.textContent = kT[WT][e + 2];
              });
          } catch (t) {
          } finally {
            e();
          }
        },
      })
        .to("button.previous", {
          clipPath: "polygon(0% 0%, 0% 0%, 0% 100%, 0% 100%)",
          transform: "translate3d(0,0,100px)",
          duration: jT.outDuration,
          delay: -jT.outDuration,
        })
        .to(".effectTExtChild", {
          delay: -jT.outDuration,
          opacity: 0,
          duration: jT.outDuration,
        });
    });
  }
  async function YT(t) {
    if (XT && VT == GT.length) return void (await X_());
    (jT = { outDuration: 1, inDuration: 1 }), WT++, (WT %= kT.length);
    const e = kd.timeline();
    qT(e),
      XT
        ? (await XT(), (XT = await GT[VT]()), VT++)
        : ((XT = await GT[VT]()), VT++, (VT %= GT.length)),
      (function (t) {
        kd.timeline().to(".effectText", {
          opacity: 1,
          onComplete: () => {
            document.querySelector(".effectText").style.display = "flex";
          },
        }),
          (document.querySelector(".staringButton").style.display = "flex"),
          t
            .to("button.next", {
              clipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
              duration: jT.inDuration,
              ease: "power4.inOut",
            })
            .to("button.previous", {
              clipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
              duration: jT.inDuration,
              delay: -jT.inDuration,
              ease: "power4.inOut",
            })
            .to(".effectTExtChild", {
              opacity: 1,
              duration: jT.inDuration,
              delay: -jT.inDuration,
            });
      })(e);
  }
  document.querySelector(".next").addEventListener("click", YT),
    addEventListener("load", () => {
      kd.fromTo(
        ".navHeading .animateNav",
        { opacity: 0 },
        { opacity: 1, stagger: 0.06, duration: 1.2 }
      );
    }),
    document.querySelectorAll(".showForm").forEach((t) => {
      t.addEventListener("click", async () => {
        const t = kd.timeline();
        await qT(t), XT && (await XT()), await X_();
      });
    }),
    addEventListener("load", async () => {
      const t = await (async function () {
        return (
          b_(document.querySelector(".startPage .center .text h1")),
          await new Promise((t) => {
            kd.to(".preLoader", {
              opacity: 0,
              onComplete: () => {
                (document.querySelector(".preLoader").style.display = "none"),
                  t();
              },
            });
          }),
          new Promise((t) => {
            kd.timeline();
            const e = kd.fromTo(
              ".startPage .center .text h1 .animateNav",
              { opacity: 0, scale: 0 },
              {
                opacity: 1,
                scale: 1,
                stagger: 0.02,
                duration: 0.8,
                onComplete: () => {
                  const n = kd.to(".startPage .center button", {
                    clipPath: "inset(0% 0% 0% 0%)",
                    duration: 0.8,
                    onComplete: () => {
                      document
                        .querySelectorAll(".startPage .center button")
                        .forEach((t) => {
                          t.style.clipPath = "none";
                        }),
                        kd.fromTo(
                          ".startPage .center button .bloom",
                          { filter: "blur(0px)" },
                          { filter: "blur(70px)" }
                        ),
                        t(
                          () =>
                            new Promise((t) => {
                              (document.querySelector(
                                "button .bloom"
                              ).style.display = "none"),
                                e.reverse().duration(1),
                                n.reverse(),
                                setTimeout(() => {
                                  (document.querySelector(
                                    ".startPage"
                                  ).style.display = "none"),
                                    t();
                                }, 1e3);
                            })
                        );
                    },
                  });
                },
              }
            );
          })
        );
      })();
      document
        .querySelector(".startPage .startButton")
        .addEventListener("click", async () => {
          DeviceMotionEvent &&
            DeviceOrientationEvent.requestPermission &&
            (await DeviceOrientationEvent.requestPermission()),
            await t(),
            LT();
        }),
        await (async function () {
          const t = [
            "https://ik.imagekit.io/sheryians/re-imagine/notification_3QcqOe1rhQ.mp3?updatedAt=1710334752635",
            "https://ik.imagekit.io/sheryians/re-imagine/imessage_send_xNzi_HqeQf.mp3?updatedAt=1710334824849",
            "https://ik.imagekit.io/sheryians/re-imagine/calendar1_kG1zWEHpj.glb?updatedAt=1709819973648",
            "https://ik.imagekit.io/sheryians/re-imagine/loudSpeaker_Cc3xjafLO.glb?updatedAt=1709819851599",
            "https://ik.imagekit.io/sheryians/re-imagine/fire23_1nAu26rnt.glb?updatedAt=1709819851559",
            "https://ik.imagekit.io/sheryians/re-imagine/tick53_KOtA2uz_b.glb?updatedAt=1710336508972",
            "https://ik.imagekit.io/sheryians/re-imagine/trophy_uS22_N0wz.glb?updatedAt=1710336416884",
            "https://ik.imagekit.io/sheryians/re-imagine/333_1HGllmdhx.png?updatedAt=1710335805066",
            "https://ik.imagekit.io/sheryians/re-imagine/temp63_5YmSbIO1q.png?updatedAt=1710336272838",
            "https://ik.imagekit.io/sheryians/re-imagine/Screenshot%20(27)_6GjTJqVDF.png?updatedAt=1710336272642",
            "https://sheryians.b-cdn.net/sddefault.jpg",
            "https://sheryians.b-cdn.net/Screenshot%202024-03-21%20at%209.01.59%E2%80%AFPM-min.png",
            "https://sheryians.b-cdn.net/Screenshot%202024-03-21%20at%209.03.37%E2%80%AFPM-min.png",
            "https://sheryians.b-cdn.net/Screenshot%202024-03-21%20at%209.04.53%E2%80%AFPM-min.png",
            "https://sheryians.b-cdn.net/Screenshot%202024-03-21%20at%209.05.25%E2%80%AFPM-min.png",
          ];
          try {
            await Promise.all(
              t.map(async (t) => {
                await fetch(t);
              })
            );
          } catch (t) {
            console.error("Failed to cache resources:", t);
          }
        })();
    });
})();
